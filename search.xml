<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Bootstrap 学习]]></title>
      <url>%2F2017%2F04%2F12%2FBootstrap%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[最近做的项目都是偏向pc端的，包括项目用的样式，也是写成组件封装好的，之前也接触过bootstrap。重新学习一边，认真写笔记 bootstrap 考虑到移动设备的开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Interview_Javascript]]></title>
      <url>%2F2017%2F04%2F08%2FInterview_Javascript%2F</url>
      <content type="text"><![CDATA[一些比较饶人的js题的自测和学习 lesson11123(function () &#123; return typeof arguments;&#125;) (); // 'object' arguments只是个类数组 21234var f = function g() &#123; return 23;&#125;typeof g(); // error 312345(function(x)&#123; delete x; return x;&#125;)(1); // 1 delete 只能删除数组或者对象 412var y = 1, x = y = typeof x;x; // 'undefined' 运算顺序从右向左 5123(function f(f)&#123; return typeof f(); &#125;)(function()&#123; return 1; &#125;); // 'number' 传进去整个函数 返回1 61234567var foo = &#123; bar: function() &#123; return this.baz; &#125;, baz: 1&#125;;(function()&#123; return typeof arguments[0]();&#125;)(foo.bar); // 'undefined' 此处this指向window arguemnts[0] 为undefined 7 12345var foo = &#123; bar: function()&#123; return this.baz; &#125;, baz: 1&#125;typeof (f = foo.bar)(); // 同上 同上 8 12var f = (function f()&#123; return "1"; &#125;, function g()&#123; return 2; &#125;)(); typeof f; // 2 这种括号的运算符，会弹出最后一个值 912345var x = 1; if (function f()&#123;&#125;) &#123; x += typeof f; &#125; x; // 'iundefined' if 里面的函数运算是true, 而f没有定义 undfined 10123var x = [typeof x, typeof y][1];typeof typeof x; // 'string' typeof 输出的类型是字符串类型 111234(function(foo)&#123; return typeof foo.bar;&#125;)(&#123; foo: &#123; bar: 1 &#125; &#125;); // 'undefined' { foo: { bar: 1 } } 作为整个实参传入 而调用的只用一个属性就是 foo 1212345(function f()&#123; function f()&#123; return 1; &#125; return f(); function f()&#123; return 2; &#125;&#125;)(); // 2 跟进预解析个规则，会先走一遍所有的function 1312function f()&#123; return f; &#125; new f() instanceof f; // false instanceof 的作用是看前面的数据 是否是后面的的构造函数，但是如果这个构造函数里面存在return,就指向了return的数据 1412with (function(x, undefined)&#123;&#125;) length; // 2 形参的个数 lesson 2 运行题变量的作用域外层的变量，内层可以找到（全局）内层的变量，外层找不到（局部） 1234567891011var a = 10;function aaa () &#123; alert(a);&#125;function bbb () &#123; var a = 20; aaa();&#125;bbb (); // 10 涉及到作用域的问题， 运行到bbb() 返回到 bbb()函数里面 遇到aaa() ,返回aaa(),只能找到外层的10 变量不加 var 它会变成全局变量12345678function aaa() &#123; var a = b = 10;&#125;aaa()alert(a) // 局部变量undefinedalert(b) // 全局变量 弹出 10 变量的查找是就近原则去寻找var定义的变量，当就近没有找到，就会查找外城， 如果没有找到，找外层的外层12345678var a = 10;function aaa() &#123; alert(a); // 就近查找发现var, 函数做预解析， 所以变量是undefined.所以在定义变量的时候要写在上面，防止出现undefined var a = 20&#125;aaa(); // undefined 123456789var a = 10;function aaa() &#123; var a = 20; alert(a); // 20 寻找就近var定义的变量，&#125;aaa(); 123456789var a = 10;function aaa() &#123; a = 20; alert(a); // 20 寻找就近var定义的变量,寻找到外层定义的a,a进函数后被替换成20&#125;aaa(); 12345678910var a = 10;function aaa() &#123; alert(a); // 10 a = 20;&#125;aaa(); 12345678910var a = 10;function aaa() &#123; bbb(); alert(a); // 10 function bbb() &#123; var a = 20; &#125;&#125; 参数和局部变量重名的时候，优先级是等同，不分彼此12345678var a = 10;function aaa(a) &#123; alert(a); var a = 20;&#125;aaa(a); // 10 基本类型赋值不存在引用关系，对象类型赋值才存在引用关系,除非对象重新赋值，导致地址断开123456var a = 5;var b = a;b += 3;alert(a); // 8 基本类型赋值不存在引用关系 123456var a = [1, 2, 3];var b = a ;b.push(4);alert(a); // [1,2,3,4] 123456var a = [1, 2, 3];var b = a ;b = [1,2,3,4];alert(a); // [1,2,3] 对象赋值后，地址断开 12345678var a = 10; function aaa (a) &#123; a += 3;&#125;aaa(a);alert(a); // 10 传参尽量就相当于重新赋值，不会受函数影响 12345678var a = [1,2,3]function aaa (a) &#123; a.push(4)&#125;aaa(a); // [1,2,3,4]对象的传参相当于引用 alert(a); // [1,2,3,4] 12345678var a = [1,2,3]function aaa (a) &#123; a = [1,2,3,4];&#125;aaa(a); alert(a); // [1,2,3] 对象重新赋值就是断开了引用地址 lesson 3 写一个字符串转成驼峰的方式 border-bottom-color &gt; borderBottomColor 课程方法 123456789function transform(str) &#123; var arr= str.split('-'); arr.forEach(function(data,index) &#123; if(index&gt;=1) &#123; arr[index] = data.charAt(0).toUpperCase() + data.substring(1); &#125; &#125;) return arr.join('') &#125; 正则方法 12345678910var str = 'border-radius';transform(str);function transform(str) &#123; var re = /-(\w)/g // \w就是字母的意思, 括起来的代表正则的子项 return str.replace(re,function($0, $1) &#123; // 第一个参数代表正则的整体，第二个参数担保正则的子祥 return $1.toUpperCase(); &#125;)&#125; 查找字符串中最多的字符和个数 字符串操作 123456789101112131415161718192021222324252627var str = 'sasfdsgdsafdfagfassss';function count(str) &#123; var obj = &#123;&#125;; var num = 0; var value = ''; for (var i = 0; i &lt; str.length; i++) &#123; if(!obj[str[i]]) &#123; obj[str[i]] = []; &#125; obj[str[i]].push(str[i]); &#125; for (item in obj) &#123; if(num &lt; obj[item].length) &#123; num = obj[item].length; value = obj[item][0] &#125; &#125; return '最多出现的字母是' +value+ '重复' + num + '次';&#125;count(str); 正则操作 如何给字符串加千分符 324423143141 &gt; 324,423,143,141 自己方法 12345678910111213141516171819202122var str = '1324423143141';console.log(transform(str));function transform (str) &#123; var arr = str.split(''); var arrh = '' var iNum = arr.length % 3; if(iNum != 0) &#123; var arrh = arr.splice(0,iNum); arrh.push(','); &#125; for(var i = arr.length - 1; i &gt;= 0; i--) &#123; if(i%3 === 0 &amp;&amp; i &gt;= 3) &#123; arr.splice(i, 0, ',') &#125; &#125; return arrh.concat(arr).join('');&#125; 课程方法 1234567891011121314151617181920212223242526272829var str = '1324423143141';console.log(transform(str));function transform (str) &#123; var iNum = str.length % 3; var arr = []; var current = 0; var tmp =''; if(iNum != 0) &#123; prev = str.substring(0, iNum); arr.push(prev) &#125; str = str.substring(iNum); for (var i = 0; i &lt; str.length; i++) &#123; current++; tmp += str[i]; if(current === 3 &amp;&amp; tmp) &#123; arr.push(tmp); current = 0; tmp = ''; &#125; &#125; return arr.join(',')&#125; 正则 // (?=) :前向声明 // (?!) :反前向声明 匹配所有ab变成星号1234567var str = 'abacad';var re = /a/g;str = str.replace(re, '*');console.log(str) // *b*c*d 匹配只有a后有b的才变* 1234567var str = 'abacad';var re = /a(?=b)/g;str = str.replace(re, '*');console.log(str) // *bacad 这就是前向声明的用法 匹配除了a后是b的其他，全都替换成* 1234567var str = 'abacad';var re = /a(?!=b)/g;str = str.replace(re, '*');console.log(str) // ab*c*d 和前向声明相反，匹配 根据上面正则，实现12345678910var str = '1324423143141';function tranform(str) &#123; var re = /(?=(?!\b)(\d&#123;3&#125;)+$)/g; // \b 代表开始结束的位置 return str.replace(re, ',')&#125;console.log(tranform(str)); 返回一个只包含数字类型的数组 js123ldsdkfsf234234 &gt; [123,234234] 字符串 123456789101112131415161718var str = 'js123lf234d234';transform(str);function transform (str) &#123; var arr = str.split('') var tmp = ''; var arrNew = [] for (var i = 0; i &lt; arr.length; i++) &#123; if(!isNaN(arr[i]) &amp;&amp; !isNaN(arr[i+1]) )&#123; tmp += arr[i]; &#125; if (!isNaN(arr[i]) &amp;&amp; isNaN(arr[i+1])) &#123; arrNew.push(tmp+arr[i]); tmp = ''; &#125; &#125; console.log(arrNew);&#125; 正则 lesson 4限制条件补全代码 有a，b两个变量，不用第三个变量来切换两个变量值 12345678var a = 5;var b = 6; a = a + b; // 11 b = a - b; // 6 a = a - b; console.log(a); console.log(b); 以上方法局限于数字，如果是字符串该如何呢？ 12345678var a = 'hello';var b = 'hi';a = [a, b];b = a[0];a = a[1]; console.log(a); console.log(b); 有一个数n = 5, 不要循环返回 [1,2,3,4,5] 不用循环可以考虑递归，不能考虑定时器，它是异步的 递归 123456789101112131415var n = 5;function show (n) &#123; var arr = []; return (function () &#123; arr.unshift(n) n--; if(n!=0) &#123; arguments.callee; &#125; return arr; &#125;)&#125;console.log(show(n)) 正则 利用replace 1234567891011121314var n = 5;function show (n) &#123; var arr = []; var arrNew = []; arr.length = n+1; // 通过数组的逗号替换，所以要多一位 var str = arr.join('a') // aaaaa str.replace(/a/g, function() &#123; arrNew.unshift(n--) &#125;) return arrNew&#125;console.log(show(n)) 一个数n,当n小于100就返回n,否则返回100 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// iffunction show(n) &#123; if(n&lt;100) &#123; return n &#125; else &#123; return 100; &#125;&#125;alert(show(n))// 三目function show(n) &#123; return n&lt;100?n:100;&#125;//switchfunction show(n) &#123; switch(n &lt; 100)&#123; case true: return n; break; case false: return 100; break; &#125;&#125;// Mathfunction show(n) &#123; return Math.min(n,100)&#125;// 数组function show(n) &#123; var arr = [n, 100]; arr.sort(function (a, b) &#123; a - b; &#125;) return arr[0];&#125;// 循环function show (n) &#123; var m = '' + n; //转成字符串 for (var i = 2; i &lt; m.length &amp;&amp; n &gt; 0; i++)&#123; return 100; &#125; return n;&#125;// for infunction show(n) &#123; var json = &#123;name: 'may'&#125; var m = n &lt; 100 || json; for(item in m) &#123; return 100 &#125; return n&#125;// 表达式function show (n) &#123; var m = n &gt;= 100 &amp;&amp; 100; return m || n;&#125; lesson 5 30.38 斐波那契数列 (两个数的和等于第三个数) [1,1,2,3,5…] 递归 123456789function F(n) &#123; if(n&lt;=2) &#123; return 1 &#125; return F(n-1) + F(n-2);&#125;console.log(F(8)) 迭代 1234567891011121314function F(n) &#123; var num1 = 1; var num2 = 1; var num3 =0; for(var i= 0; i &lt; n -2 ;i++) &#123; num3 = num1 + num2; num1 = num2; num2 = num3; &#125; return num3;&#125;console.log(F(8)) 数组排序 冒泡排序是两个两个进行比较 如果前面的数&gt;后面的数，进行位置切换。如果前面的数&lt;后面的数,不进行位置切换。 1234567原数据 4，5，1，7，2第一轮第一次排序 4，5，1，7，2第二次排序 4，1，5，7，2第三次排序 4，1，5，7，2第四次排序 4，1，5，2，7 找到最大值 第二轮 ... 123456789101112131415161718var arr = [ 4,5,1,7,2];for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; arr.length - i; j++) &#123; toCon(j, j+1); &#125; &#125;function toCon(pre,next)&#123; var tmp =''; if(arr[pre] &gt; arr[next]) &#123; tmp = arr[pre]; arr[pre] = arr[next]; arr[next] = tmp; &#125;&#125;console.log(arr); 快速排序 先从数列中取出一个数作为基准数区别过程，将比这个数大的书全放到右边，小于或者等于的数放在左边再对左右区间重复第二步，知道各区间只有一个数 123456789101112131415161718192021function quickSort(arr) &#123; if(arr.length &lt;=1) return arr; var index = Math.floor(arr.length/2); var pivot = arr.splice(index,1)[0]; var left = []; var right = []; for(var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat([pivot], quickSort(right))&#125; 简单排序, 每次找到最小值，把最小值放在前面 12345678910111213141516171819202122var arr = [ 4,5,1,7,2];function sort(arr) &#123; if(arr.length === 1) &#123; return arr &#125; var index = 0; var iMin = arr[0] for (var i = 0 ; i &lt; arr.length; i++ ) &#123; if(arr[i] &lt; iMin) &#123; iMin = arr[i]; index = i; &#125; &#125; var pre = arr.splice(index,1); return pre.concat(sort(arr))&#125;console.log(sort(arr)) 数组去重 12345678910111213141516171819202122232425var arr = [3,5,2,4,3,5,4,1];function q(arr) &#123; var result = [arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if(toCont(arr[i])) &#123; result.push(arr[i]) &#125; &#125; function toCont (val) &#123; for (var i = 0; i &lt; result.length; i++) &#123; if(result[i] === val) &#123; return false &#125; &#125; return true; &#125; return result&#125;console.log(q(arr)) 12345678910111213141516171819var arr = [3,5,2,4,3,5,4,1];function q(arr) &#123; var result = []; var obj = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; if(!obj[arr[i]]) &#123; result.push(arr[i]); obj[arr[i]] = 1; &#125; &#125; return result &#125;console.log(q(arr)) es6 12345678910111213function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))&#125;// orfunction unique (arr) &#123; return Array.from(new Set(arr))&#125;function unique(arr) &#123; return Array.from(new Set(arr))&#125; 随机生成指定长度的字符串 比如给定 长度 8 输出 4ldkfg9j 123456789function randomstring(n) &#123; var str = 'abcdefghijklmnopqrstuvwxyz9876543210'; var tmp = ''; for (var i = 0; i &lt; n; i++) &#123; tmp += str.charAt(Math.random() * 1); &#125; return tmp;&#125; js打乱数组的最搞笑方法 12345678910var arr = [];for (var i = 0; i &lt; 100; i++) &#123; arr[i] = i;&#125;arr.sort(function() &#123; return 0.5 - Math.random()&#125;)var str = arr.join() Javascript中callee和caller的作用 caller是返回一个对函数的引用，该函数调用了当前函数； callee是返回正在被执行的function函数，也就是所指定的function对象的正文。 JSONP原理 可以把需要跨域的请求改成用script脚本加载即可，服务器返回执行字符串，但是这个字符串是在window全局作用域下执行的，你需要把他返回到你的代码的作用域内，这里就需要临时创建一个全局的回调函数，并把到传到后台，最后再整合实际要请求的数组，返回给前端，让浏览器直接调用，用回调的形式回到你的原代码流程中。 JavaScript事件模型 原始事件模型，捕获型事件模型，冒泡事件模型， 原始事件模型就是ele.onclick=function(){}这种类型的事件模型 冒泡事件模型是指事件从事件的发生地（目标元素），一直向上传递，直到document 捕获型则恰好相反，事件是从document向下传递，直到事件的发生地（目标元素） event.stopPropagation()event.preventDefault 取消默认时间 JavaScript的继承 li标签间有空白是怎么回事？ 消除li横排后空隙 需要将其设置为display:inline-block;此时会页面效果是两个之间会有一个大约8px的空白间隙.浏览器的默认行为是把inline元素间的空白字符（空格换行tab）渲染成一个空格 既然是因为换行导致的，那就可以将代码全部写在一排 .wrap ul{font-size:0px;} .wrap ul{letter-spacing: -4px;} javascript的本地对象，内置对象和宿主对象 本地对象为array obj regexp等可以new实例化内置对象为gload Math 等不可以实例化的宿主为浏览器自带的document,window 等 CSS中一个冒号和两个冒号有神马区别？ 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax原理]]></title>
      <url>%2F2017%2F04%2F05%2Fajax%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[ajax 学习总结 什么是ajax?异步的的js和xml,用js异步形式操作xml,工作主要是数据交互 借阅用户操作时间，减少数据请求，可以无刷新请求数据 创建一个对象123456789101112131415oBtn.onclick = function () &#123; // 打开浏览器 var xhr = new XMLHttpRequest(); // 打开地址 xhr.open('get', './1.txt', true); // 提交 xhr.send(); // 等待服务器返回内容 xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; alert(xhr.responseText); &#125; &#125;&#125; 不兼容ie6一下，需要写判断 window.XMLHttpRequest 1234567try &#123; &#125; catch(e) &#123; &#125;// 代码尝试执行这个`try`块中的内容，如果有错误，则会执行catch&#123;&#125;不会影响程序执行 1xhr = new XMLHttpRequest(); open 方法参数 打开的方式，数据地址，是否异步 异步： 非阻塞 前面的代码不会影响后面代码的执行 setTimeout true 一般用异步的形式同步： 阻塞 当前面的工作没有做完，后面会阻塞 比如jq库的加载 false 后续的内容需要前面挂钩， 表单 数据提交action: 数据提交的地址，默认的当前页面method: 数据提交的方式，默认get方式 get把数据名称和数据值用=连接，如果有多个数据，会用&amp;进行连接，然后把数据放到url?后面不要通过get传递过多的数据，数据多少根据各个浏览器决定 post数据在请求头，发送数据是串联形式，但是位置不一样，理论上没有限制enctype: 提交的数据格式，默认application/x-www-form-urlencoded需要在表格中 method=&quot;post&quot; get请求和post一般用于何种需求 get 方式的历史记录会被记录，影响用户隐私，不太安全，只能传字符串 post 通过请求头，可以用于多种数据类型 数据的获取怎么得到ajax 返回的数据 xhr.responseText: 返回的数据会放在这个属性，类型是字符串类型 readyState: ajax工作状态 0 1 2 3 4 0 初始化 1 调用xhr.send() 2 载入完成，请求已经发送，收到响应内容 3 解析 正在解析内容 4 解析完成 onreadychange 当状态值改变的时候触发 12345xhr.onreadystatechange = function() &#123; if(xhr.readyState = 4) &#123; // code &#125;&#125; 请求资源的时候，服务器会返回一个状态值 1 代表消息 2 成功类型 3 重定向 调到其他页面，缓存就是一种重定向 4 错误 5 服务器性错误 可以做更好的容错处理123456789xhr.onreadystatechange = function() &#123; if(xhr.readyState = 4) &#123; if(xhr.status === 200) &#123; // 请求正确 &#125; else &#123; alert('error'); &#125; &#125;&#125; 请求的处理 get 请求文件，传输数据 1234567891011121314151617var oBtn = document.getElementById('btn');oBtn.onclick = function () &#123; var xhr = new XMLHttpRequest(); xhr.open('get','form.get.php?username=may&amp;age=30',true); xhr.send(); xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; alert(xhr.responseText) &#125; else &#123; alert('error') &#125; &#125; &#125;&#125; 注意： 1 如果不想存在缓存问题 可以给请求后面加随机数或者时间戳 1xhr.open('get','form.get.php?username=may&amp;age=30&amp;' + new Date(),true); 2 中文乱码问题，可以用编码 encodeURI 1xhr.open('get','form.get.php?username='+encodeURI('文件') +'&amp;age=30&amp;' + new Date(),true); post 方式请求文件 数据作为参数放在send方法里面，并且设置请求头 12345678910111213141516var oBtn = document.getElementById('btn');oBtn.onclick = function ()&#123; var xhr = new XMLHttpRequest(); xhr.open('post', 'form.post.php', true); xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded'); // 需要告诉后端发送数据的类型 xhr.send('username=may&amp;age=30'); xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if(xhr.status = 200) &#123; alert(xhr.responseText); &#125; &#125; &#125; &#125; post没有缓存问题，它本身就是提交数据post没有转码的问题 数据获取的问题 JSON.stringify(arr): 可以把一个对象转成对应字符串 JSON.parse(str); key值必须是双引号才可以转为json 123456789101112131415161718192021var oBtn = document.getElementById('btn');var oul = document.getElementById('ul');oBtn.onclick = function () &#123; var xhr = new XMLHttpRequest(); xhr.open('get', 'getNew.php', true); xhr.send(); xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if(xhr.status === 200) &#123; var data = JSON.parse(xhr.responseText); var html = ''; for (var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;&lt;a href=""&gt;' + data[i].title + '&lt;/a&gt;&lt;span&gt;' + data[i].date+ '&lt;/span&gt;&lt;/li&gt;' &#125; oul.innerHTML = html; &#125; &#125; &#125;&#125; 瀑布流展示demo瀑布流布局 每次最短的li,然后添加位置 需要知道图片的高度，否则图片加载还没有加载完成，就会自动计算那一列最短而去添加。可以有两种解决方案 拉到最底下加载 计算最短的li的高度 + top值 &lt; 可视区的高度 + 滚动条的高度 document.documentElement.scrollTop || document.body.scrollTop 往下拉， 不仅仅加载一次，可能会触发 第二页 第三页，可以设置个标识位 数据加载完的时候 应该对每次取到的数据进行判断，如果没有数据， return 出去 后端传值宽高 如果宽度确定 200 高度就是 123element.height * (200/element.width)document.createElement() 预加载 跨域解决一个域名的文件去请求和它不一样的域名下的资源文件，就会产生跨域请求 浏览器因为安全问题不允许跨域请求，可以采用 通过本地代理 本地建立一个代理，这个代理请求服务器，需要资源的时候，在请求服务器 通过flash flash请求资源，服务器端有xml文件，里面存一些资源域名，如果能找到允许你访问 通过jsonp （json with Padding） 从另外的域名，把资源拿取过来 script标签， 可以加载.js以外的文件类型吗？文件的后缀名是辨识的不是文件类型决定， 跟根据文件里面的实质内容。只认内容，不认文件名字 用script标签加载资源没有跨域问题 在资源加载进来之前定义好一个函数，这个函数接收一个参数（数据），函数利用这个参数做一些事情然后需要的时候通过script标签加载对应远程文件资源，当远程的问价资源被加载进来的时候，就会去执行我们前面定义好的函数，并且把数据当做这个函数的参数传入进来 如果想实现按需加载，比如当用户点击的时候？ 当用户点击的时候创建 script 标签，加载到 body标签后面，从而实现按需加载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[问题总结]]></title>
      <url>%2F2017%2F04%2F05%2F%E8%AF%84%E7%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[记录之前面试的总结.. BOM和DOM 含义，全拼document object model 文档对象模型，把文档当做一个对象来看待browser object model 浏览器对象模型 把浏览器当做一个对象来看 javascript基础数据类型数字、字符串、undefined、对象、null、boolean 如何判断数据类型：typeof 常见类型的判断instanceof 对已知对象类型的判断其中typeof返回的类型都是字符串形式，在判断object类型是比较方便instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支 如何判断一个数据是数组类型：constructorinstanceofisArray 判断浮点数正则将这个浮点数转为字符串，判断里面是否有点 有一个div，它内部宽度不确定，我想让它相对于父元素垂直水平居中，如何设计？flex布局line-height 垂直， margin: 0 autoclentWidth - offsetWidthtransform: translate(-50%, -50%);利用伪类实现123456789101112131415161718192021.wrapper &#123; width: 200px; height: 200px; text-align: center; background-color: #ccc; &#125; .goal &#123; display: inline-block; width: 100px; height: 100px; vertical-align: middle; background-color: deeppink; &#125; .wrapper:after &#123; content: ' '; display: inline-block; width: 0; height: 100%; vertical-align: middle; background-color: deeppink; &#125; html语义化的理解便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析方便其他设备解析 http状态码：1 开头 代表消息2 代表成功3 重定向4 请求错误5，6 服务器错误 cookie，sessionStorage与localStorage区别 共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不能在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。。 css3新特性 css3 选择器 css3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是 ::selection. 媒体查询，多栏布局 border-image css选择器 兄弟选择器 属性选择器 引入normalize的作用。是保留浏览器的原来样式并且做到每个浏览显示一致 性能优化：减少请求、简化页面结构、优化代码、压缩机制、图片。css雪碧图的优缺点优点：减少请求，提升页面性能减少图片的字节数解决了图片命名的困扰更换风格方便统一缺点在图片合并的时候，多张图片合并在一张图片，要保留好足够的空间，防止出现不必要的背景图片可维护性查，每次的修改都要在这个图片上修改，如果图片较多，你要记住位置图片的位置需要固定绝对值定位，失去了灵活性 display有哪些值:none、block、inline、inline-block,table。img元素是什么元素？inlineXMLHttpRequest原生12345678var xhr = new XMLHttpRequest();xhr.open(method, url, true);xhr.send();xhr.onreadystatechange = function() &#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; &#125;&#125; 哪些事件会触发脏检查？当在view绑定数据，触发事件都会触发脏检测 ng-model ng-click $digest和$apply有什么区别？$scope.$apply()会自动调用$rootScope.$digest()。$apply()函数可以以两种方式运行。第一种是将函数作为参数，并且评估他，然后触发$digest循环。第二种并不传入任何参数，仅仅是执行一个$digest循环。如果我们更改一个不在AngularJS执行上下文中的数据模型(model)，就需要人为的调用$apply()来提醒AngularJS数据发生变化了。就像是要告诉AngularJS，我们改变了一些数据，他应该启用监听器以便于让我们所做的改变能够反映出来。当你为$apply()传入函数的时候，这个函数在调用的时候是包含在try..catch中的，并且，任何发生的异常都能够被$exceptionHandler服务所接收。 https://segmentfault.com/a/1190000004523893 数据请求和前端资源优化？配置超长时间的本地缓存 —— 节省带宽，提高性能采用内容摘要作为缓存更新依据 —— 精确的缓存控制静态资源CDN部署 —— 优化网络请求资源发布路径实现非覆盖式发布 —— 平滑升级 html5的新特性 标签语义化，比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签 音视频元素，video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。 新增很多api，比如获取用户地理位置的window.navigator.geoloaction， websocketwebsocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端， webstorage，webstorage是本地存储，存储在客户端，包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了， 缓存 web worker，web worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。 js继承 http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html 第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color; &#125; var cat1 = new Cat("大毛","黄色"); alert(cat1.species); // 动物 第二种代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。 原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。 这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。 1234Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; var cat1 = new Cat("大毛","黄色"); alert(cat1.species); // 动物 第三种由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。现在，我们先将Animal对象改写： 123456function Animal()&#123; &#125; Animal.prototype.species = "动物";Cat.prototype = Animal.prototype; Cat.prototype.constructor = Cat; var cat1 = new Cat("大毛","黄色"); alert(cat1.species); // 动物 什么时候需要清浮动，清楚浮动都有哪些方法通常使用浮动来实现某些元素的布局，但是往往这些元素浮动会影响其他元素的布局，因此会产生副作用。浮动不再占据文档流的位置，也使浮动元素周围的元素表现的如同浮动元素不存在一样，给布局带来了一些副作用如果我们不希望要这些效果，就需要清除浮动来解决后患 绝对定位与相对定位相对定位 position: relative; 相对定位是相对于元素在文档中的初始位置绝对定位 position: absolute; 绝对定位是相对于元素最近的已定位的祖先元素 字符串转对象JSON.parse 从对象解析到字符串json.stringify 响应布局px 与 remjquery append()方法与html()方法用法区别如果美化一个弹出对话框闭包的用途一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。123.p &#123;vertical-align: middle;&#125; angularjs作用域AngularJS中，子作用域一般都会通过JavaScript原型继承机制继承其父作用域的属性和方法。但有一个例外：在directive中使用scope: { … }，这种方式创建的作用域是一个独立的”Isolate”作用域，它也有父作用域，但父作用域不在其原型链上，不会对父作用域进行原型继承。 angularjs 指令的封装事件委托es6 与之前 相比有什么新特性作用链和作用域let const 作用域和 var 有什么区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack]]></title>
      <url>%2F2017%2F04%2F02%2Fwebpack%2F</url>
      <content type="text"><![CDATA[webpack说的很简单，项目中也一直在用别人搭好的脚手架，一直很忙没有功夫细细研究下，这次一定认真研究下，以后使用再有问题和坑一并记录到这来 参考api http://webpack.github.io/docs/configuration.html中文api https://doc.webpack-china.org/guides/get-started/简易使用指南 https://github.com/petehunt/webpack-howto 当你拿到一个项目你需要 初始化项目1npm init 一路回车生成package.json 接下来你需要全局安装webpack 1npm i -g webpack 在项目中安装 1npm i -D webpack 创建如下目录结构 1234+ src - app.js+ distpackage.json 就可以使用webpack 进行简单的打包 app.js 1console.log(&apos;hello from app.js&apos;) 可以使用webpack进行简单打包 1webpack ./src/app.js ./dist/app.bundle.js 1webpack ./src/app.js ./dist/app.bundle.js -p //打包出来的文件被压缩处理 1webpack ./src/app.js ./dist/app.bundle.js --watch //打包出来的文件被压缩处理,并且实时监听文件的变化 可以看到打包好的文件生成在dist文件中，现在我们简化指令 创建webpack.config.js 123456module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; filename: &apos;./dist/app.bundle.js&apos; &#125;&#125; 再输入 1webpack 修改package.json 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack -d --watch&quot; //这条是添加的&#125; 这时我们在终端只需输入 1npm run dev 而实际上线我们需要代码压缩 12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack -d --watch&quot;, &quot;prod&quot;: &quot;webpack -p&quot; // 对代码进行压缩&#125;, webpack plugins 创建自定义的index在dist目录中创建index.html,并进入打包好的js文件 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;content goes here&lt;/p&gt; &lt;script src="./app.bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此刻我们不想通过手动在dist中创建html文件，利用webpack的plugin来帮我们创建 1npm i html-webpack-plugin --save-dev 修改webpack.config.js,并删除dist目录中的index.html 12345678910var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;app.bundle.js&apos; &#125;, plugins: [new HtmlWebpackPlugin()]&#125; 然后运行 1npm run dev 这时候你会看见目录里面自动生成index.html文件 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果想根据自己的模板创建index.html,需要修改webpack.config.js 12345678910111213141516171819var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;app.bundle.js&apos; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;myApp&apos;, minify: &#123; collapseWhitespace: true //生成被压缩的html文件 &#125;, hash: true, template: &apos;./src/index.html&apos;, // 自定义的html路径 &#125;) ]&#125; 在src目录添加index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is my template&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; css-load、sass-loadcss-load1npm install css-loader style-loader --save-dev 在app目录下生成app.css 1234567html,body&#123; height:100%; margin:0; background:green; color:#fff; font-size:20px;&#125; 修改webpack.config.js 123456module: &#123; rules: [ &#123;test: /\.css$/, loaders: &apos;style-loader!css-loader&apos;&#125; // &#123;test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;]&#125; ] &#125;, 修改app.js 12import &apos;./app.css&apos;console.log(&apos;hello from app.js again&apos;) sass-loader1npm install --save-dev sass-loader node-sass 修改webpack.config.js 123456module: &#123; rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;]&#125;, &#123;test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;]&#125; ] &#125;, 修改app.js 12import &apos;./main.scss&apos;console.log(&apos;hello from app.js again&apos;) 在src目录新建main.scss 1body&#123;background:#ff0;&#125; 这样的打包方式最终加载页面head里面，但是如果吓你文件的方式引入进去 1npm install --save-dev extract-text-webpack-plugin 修改webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);var path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;app.bundle.js&apos; &#125;, module: &#123; rules: [ &#123;test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [&apos;css-loader&apos;] &#125;)&#125;, &#123;test: /\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [&apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;)&#125; ] &#125;, plugins: [ new ExtractTextPlugin(&#123; filename: (getPath) =&gt; &#123; return getPath(&apos;css/[name].css&apos;).replace(&apos;css/js&apos;, &apos;css&apos;); &#125;, allChunks: true &#125;), new HtmlWebpackPlugin(&#123; title: &apos;myApp&apos;, minify: &#123; collapseWhitespace: true //生成被压缩的html文件 &#125;, hash: true, template: &apos;./src/index.html&apos;, // Load a custom template (ejs by default see the FAQ for details) &#125;) ]&#125; webpack-dev-server1npm i webpack-dev-server -D 修改package.json 12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;, // 这里是刚修改的 &quot;prod&quot;: &quot;webpack -p&quot;&#125; 然后 1npm run dev 修改webpack.config.js，添加如下 1234567devServer: &#123; contentBase: path.join(__dirname, &apos;dist&apos;), compress: true, port: 8080, stats: &apos;errors-only&apos;, open: true // 启动后自动打开浏览器窗口&#125;, 清理dist1npm i -D rimraf package.json修改 123456&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;, &quot;prod&quot;: &quot;npm run clean &amp;&amp; webpack -p&quot;, &quot;clean&quot;: &quot;rimraf ./dist/*&quot;&#125; 这样的话会在每次打包的时候将dist目录清空，然后重新生成，以确保dist目录没有多余的无用文件 多模块的使用一般情况一个项目肯定不止一个页面吧，解析来创建contact模块，修改webpack.config.js,在plugins中添加： 123456new HtmlWebpackPlugin(&#123; title: &apos;contact&apos;, hash: true, filename: &apos;contact.html&apos;, template: &apos;./src/contact.html&apos;&#125;) 在src根目录创建一个新的html模板contact.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is contact!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 新建contact.js 12console.log('contact page') 由于有多个入口文件，修改webpack.config.js的entry和output 12345678entry: &#123; app: &apos;./src/app.js&apos;, contact: &apos;./src/contact.js&apos;&#125;,output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos;&#125;, 这时候再次启动服务器，我们发现contact.js被调用，这不是我们需要的，指向在contact.js在contact页面中被调用 1234567891011121314new HtmlWebpackPlugin(&#123; title: 'myApp', hash: true, filename: './index.html', excludeChunks: ['contact'], //新增 template: './src/index.html',&#125;),new HtmlWebpackPlugin(&#123; title: 'contact', hash: true, filename: 'contact.html', chunks: ['contact'], //新增 template: './src/contact.html'&#125;) 这样两个模块就不会互相干扰 css js的局部刷新伴随项目越来越大，每次保存都会从新刷新打包，现在我们需要局部刷新 修改webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);var path = require(&apos;path&apos;)var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &#123; app: &apos;./src/app.js&apos;, contact: &apos;./src/contact.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos; &#125;, module: &#123; rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;]&#125;, &#123;test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;]&#125;, &#123;test: /\.pug$/, use: [&apos;html-loader&apos;, &apos;pug-html-loader&apos;]&#125; ] &#125;, devServer: &#123; contentBase: path.join(__dirname, &apos;dist&apos;), compress: true, port: 8080, stats: &apos;errors-only&apos;, hot: true, open: true // 启动后自动打开浏览器窗口 &#125;, plugins: [ new ExtractTextPlugin(&#123; filename: (getPath) =&gt; &#123; return getPath(&apos;css/[name].css&apos;).replace(&apos;css/js&apos;, &apos;css&apos;); &#125;, disable: true, allChunks: true &#125;), new HtmlWebpackPlugin(&#123; title: &apos;myApp&apos;, // minify: &#123; // collapseWhitespace: true //生成被压缩的html文件 // &#125;, hash: true, filename: &apos;./index.html&apos;, excludeChunks: [&apos;contact&apos;], template: &apos;./src/index.pug&apos;, // Load a custom template (ejs by default see the FAQ for details) &#125;), new HtmlWebpackPlugin(&#123; title: &apos;contact&apos;, hash: true, filename: &apos;contact.html&apos;, chunks: [&apos;contact&apos;], template: &apos;./src/contact.html&apos; &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin() ]&#125; 打包图片1npm i -D file-loader 123456// add &#123;test: /\.jpg$/, use: &apos;file-loader&apos;&#125;``` 在html中增加使用 12 npm i -D image-webpack-loader 12 { test: /.(png|jpe?g|svg|gif|webp)$/, use: [ ‘file-loader?name=images/[name].[ext]’, // ‘file-loader?name=[hash:6].[ext]&amp;publicPath=images/‘, ‘image-webpack-loader?{optimizationLevel: 7, interlaced: false, pngquant:{quality: “65-90”, speed: 4}, mozjpeg: {quality: 65}}’ ]}1234&gt; 具体参考：https://www.npmjs.com/package/image-webpack-loader# babel的使用 npm i -D babel babel-preset-es2015 babel-loader babel-core 12 //add{ test: /.js$/, use: ‘babel-loader’, exclude: /node_modules/},1在根目录新增.babelrc文件 { “presets”: [“es2015”]} ``` 具体参考 http://babeljs.io/docs/setup/#installation webpack 详解 http://www.viscode.cn/2017/03/30/webpack%E8%AF%A6%E8%A7%A3/#more]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angularjs问题总结]]></title>
      <url>%2F2017%2F04%2F01%2Fangularjs%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[之前在知乎上看过一个问题 如何衡量一个人的 AngularJS 水平？ https://www.zhihu.com/question/36040694 感觉自己也用了快一年了，但是很多会用答不上来，吓得我赶紧打开我的项目，发现我用angularjs啦，难道我遇见假的angularjs了。而且用完就忘了，开此贴特来记录一些问题和坑！ angular的数据采用什么机制？ 详述原理脏检测机制 angular在scope模型上设置了一个监听队列，用来监听数据变化并更新view。当绑定一个东西到view上时angular就会往$watch队列里插入一条$watch,用来检测它监听的model里面是否有变化的东西。当浏览器接收可以被angular content 处理的事件是，$digest循环就会触发，遍历所有$watch, 最后更新dom 举个例子 1&lt;button ng-click = 'val=val+1'&gt;&lt;/button&gt; click 时会产生一次更新的操作（至少触发两次$digest循环） 按下按钮 浏览器接收一个事件，进入到angular context $digest循环开始执行，查询每个$watch是否变化 由于监听$scope.val的$watch报告了变化，因此强制再执行一次$digest循环 新的$digest循环没有检测到变化 浏览器拿回控制器，更新$scope.val新值对应的dom $digest的循环上限是10次 两个平级界面a和b,如果a触发一个时间，有哪些方式能让b知道，详述原理其实就是两个评级界面模块进行通信。有两种方式 共用服务 基于事件 eventBus 事件发布和订阅的框架 共用服务在angular中，通过factory可以生成一个单例对象，在与需要通信的模块a和b中注入这个对象即可 基于事件 借助父controller.在子controller中向父controller触发$emit事件，然后在父controller中监听$on事件，再广播$broadcast给子controller,这样通过事件携带参数，实现了数据经过父controller,在同级controller之间传播 借助$rootScope。每个angular应该默认一个根作用域$rootScope,根作用域位于最顶层，从它往下挂着各种作用域。所以，如果子控制器直接使用$rootScope广播和接收事件，那么久可以实现同级之间的通信 EventBus 事件发布、订阅总线提供事件订阅，事件发布，事件解绑 将定义的事件和事件函数push到一个数组里面这个是事件订阅，当需要触发函数通过事件发布，完成后事件解绑 一个angular应用应当如何良好的分层 目录结构的划分 如果是小型的文件类型，可以按照文件类型组织 cssjs controller model services filters templates 但如果是规模较大的项目，最好按照业务模块划分 业务文件夹最好还有个公共的common文件来存放公共的东西，比如抽出的组件，图片，css 逻辑代码的划分 作为一个mvvm框架，angular应用本身应该按照模型，视图模型，视图来划分 这里的逻辑代码的拆分，尽量让controller这一层很薄。提取共用的逻辑到service中，比如后台数据的请求，数据的共享和缓存，基于事件的模块间通信，提取共同的界面操作到directive中，提取共用的格式化造作到filter中 在复杂的应用中，也可以为实体建立对应的构造函数 angular应用常用那些路由库，各自的区别angular1.x中常用ngRoute 和 ui.router,还有一种为angular2设计的new router ngRouter 是angular自带的angular模块，ui.router是第三方提供的模块 ui.router是基于state状态的，ngRouter是基于url的，ui.router模块具有强大的功能，主要体现在视图的嵌套方面 使用ui.router能够定义有明确父子关系的路由，并通过ui-view指令将子路由模板插入到父路由模板的中去，从而实现视图嵌套。而在ngRouter中不能这样定义，如果同时在父子视图中使用的会陷入死循环 如果angular的directive规划一套全组件化体系，会遇到哪些挑战？ 对外暴露的接口是否满足不断变化的需求 能否做到一套组件化的细节例如disabled 默认值 css等细节的统一 能否做到统一的版本控制，当升级组件版本时，基础逻辑不会影响，做到兼容 及时fix bug 分属不同团队进行开发的angular应用，如果要做整合，会遇到哪些问题，如何解决可能会遇到模块之间的冲突，一个在moduleA中，一个在moduleB中，导致两个module在会发生覆盖 最好在开发的时候就统一空间命名，避免冲突 angular缺点有哪些？ 约束性强学习成本高，对前端不友好 不利于seo, 一种解决的办法是对应正常用户的访问，响应angular,对于搜索引擎访问，响应针对seo的html页面 性能问题 作为MVVM框架，因为实现了数据的双向绑定，对应大数组，复杂对象会存在性能问题 优化angular应用性能的办法 减少监控项 对不会变化的使用单向绑定 1&#123;&#123;::yourModel&#125;&#125; 主动设置索引 指定track by， 无限滚动加载避免用ng-repeat 降低渲染数量 设置分页，每次渲染有限的数量 数据扁平化 (对于树状结构，使用扁平化解构，构建一个map和梳妆数据，对数操作) 如何看待 controller as 的语法在1.2以前，view任何的绑定都是直接绑定$scope。使用controllerAs,不需要再注入$scope, controller 变成一个简单的js对象，一个更纯粹的viewModel 从源码实现上来看，controllerAs语法只是把controller这个对象的实例用as别名在$scope上创建一个属性 避免遇到angular作用域相关的一个坑（比如ng-if，会产生以及作用域的坑，其实也是js原型链继承中值类型继承的坑）使用controllerAs的话view上所有的字符都绑定在一个引用的属性上，就可以避免这个坑 不过不引入$scope会导致$emit $broadcast $on $watch等方法无法使用，这些个跟事件相关的操作可以封装起来统一处理，或者在单个controller中引入 $scope 详述angular的依赖注入angular是通过构造函数的参数名字来推断依赖服务名称，通过toString来找到这个定义的function的字符串，然后用正则解析出其中的参数，再去依赖映射种渠道的对应的依赖，实例化之后传入 因为angular的inject是假设函数的参数名字就是依赖名字，如果去查找依赖项，代码压缩后，参数会重命名，就无法查找到依赖项 依赖注入写法数组注释法123myApp.controller('myCtrl', ['$scope', function ($scope) &#123;&#125;]) 显示$inject1myCtrl.$inject = ['$scope', '$http'] 对于依赖注入必须具备三个要素：依赖项的注册，依赖关系的声明和对象的获取，在angularjs中，module和$provide都可以提供依赖项的注入，内置的injector可以获取对象 ng-if和ng-show区别ng-if 为true 才创建dom节点，ng-show起始就创建了。用样式控制 ng-if 会隐式的产生新作用域，ng-switch，ng-include等会动态创建一块界面也是如此 ng-repeat 迭代数组，有相同值可以加$track by $index可以解决，也可以任何一个普通的值，只要能唯一标识数组中的每一项即可（建立dom和数据之间的关系） ng-click中写的表达式，能使用js原生对象上的方法，比如math.max之类的吗不可以。只要在页面中，就不能直接调用原生的js方法，因为这些并不属于在页面对应的controller的$scope,除非在$scope中添加这个函数 下面这种表达实例，实现后面的参数通过什么方法自定义12&#123;&#123;now | 'yyyy-mm-dd'&#125;&#125;` filter 有两种使用方法1&lt;p&gt;&#123;&#123;now | data: 'yyyy-mm-dd'&#125;&#125;&lt;/p&gt; 另一种在js里面用 1$filter('date')(now, 'yyyy-mm-dd') 自定义12345app.filter('过滤器名字', function() &#123; return function (需要过滤的对象,过滤参数,过滤参数) &#123; return 处理后的对象 &#125;&#125;) factory、service和provider是什么关系？factory把service的方法和数据放在一个对象里面，并返回一个对象 12345678app.factory('FooService', function()&#123; return &#123; target: 'factory', sayHello: function()&#123; return 'hello ' + this.target; &#125; &#125;&#125;); service通过构造函数方式创建service，返回一个实例化对象 1234567app.service('FooService', function()&#123; var self = this; this.target = 'service'; this.sayHello = function()&#123; return 'hello ' + self.target; &#125;&#125;); provider创建一个可通过config配置的service,$get中返回的，就是用factory创建的service 12345678910111213141516171819202122app.provider('FooService', function()&#123; this.configData = 'init data'; this.setConfigData = function(data)&#123; if(data)&#123; this.configData = data; &#125; &#125; this.$get = function()&#123; var self = this; return &#123; target: 'provider', sayHello: function()&#123; return self.configData + ' hello ' + this.target; &#125; &#125; &#125;&#125;);// 此处注入的是 FooService 的 providerapp.config(function(FooServiceProvider)&#123; FooServiceProvider.setConfigData('config data');&#125;); 从底层实现来看，service调用了factory,返回其实例，factory调用了provider,返回其$get中定义的内容， $factory和service功能类似，只不过factory是普通的函数，可以返回任何东西service是构造器，可以不返回provider是加强版的factory,返回一个可配置的factory $rootscope和$scope的区别$rootScope页面所有的$scope的父亲 angular 解析ng-app然后在内存中创建$rootScopeangular会继续解析找到双括号表达式表达式，并解析变量 接着会解析带有ng-controller的div然后指向某个controller函数，这个时候在这个controller函数变成一个$scope对象的实例 表达式是如何工作的每出现一个双括号表达式就会设置一个$watch而$interpolation会返回一个带有上下文参数的函数，最后改函数执行，算是表达式$parse作用域上 angular的digest周期angular总会对比scope module的值，一般digest周期都是自动触发的，也可以使用$apply进行手动触发 取消 $timeout,停止$watch取消1$timeout.cancel(customTime) 停止 12345678var deregisterWatchFn = $rootScope.$watch('someGloballyAvailableProperty', function (newVal) &#123; if (newVal) &#123; // we invoke that deregistration function, to disable the watch deregisterWatchFn(); &#125;&#125;); 要取消watch的话，一开始将$watch的返回值保存就好啦，要取消watch的时候，在调用。 angular directive中restrict中分别怎么设置A 属性匹配E 标签匹配C class匹配M 注释匹配 在scope中 @ 设置一个字符串= 双向绑定&amp; 用于执行父级scope上的一些表达式 $apply 和 $digest的区别$apply 可以接收一个参数作为function，这个参数会被包装在try..catch中，一旦异常就会被$exceptionHandler service 处理 $apply会使ng进入$digest cycle,并从$rootScope开始遍历检查数据变更 $digest仅会检查scope和它的子scope 写controller逻辑 需要注意简化代码 尽量减少dom节点操作，dom最好出现在指令中，angular提倡驱动开发，service或者controller中出现dom操作意味这，测试驱动无法通过，angular专注上相数据绑定，无需关系一对dom操作 angular是mvc还是mvvm首先说明一下mvc 和 mvvm理解 为什么需要mvc,随着代码规模化，必须切分职责，方便后期的维护，修改一块功能，不能影响其他功能，也方便复用，mvc只是一种手段，终极目标的模块化和复用 mvvm的优点 低耦合 可复用 独立开发 可测试 angularjs的mvvm 模式分为四个部分 view 专注界面的显示和渲染，在angular中则是包含一堆声明式的directive视图模板 viewModel 是view和model的粘合体，负责view和model的交互和协作，负责给view提供显示的数据，以及view中事件的操作 model 它是应用程序的业务逻辑相关的数据的封装载体，是业务领域的对象，model不会关心如何显示或操作，大部分model来自服务端返回数据或者全局配置angualr的service则是封装和处理相关业务逻辑的场所 controller 它负责初始化viewModel，将组合一个或者多个service来获取业务领域model放在viewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态 angularjs 核心 mvc 模块化 双向绑定 语义化标签 注入依赖 directive中compile和link的区别使用compile函数可以改变原始的dom,在ng创建原始dom实例以及创建scope之前 可以应用于当需要生成多个element实例，compile函数阶段改变原始的dom生成多个原始dom节点,然后每个又生成element实例.因为compile只会运行一次,所以当你需要生成多个element实例的时候是可以提高性能的. pre-link 可以运行一些业务代码在ng执行完compile函数之后，但是在它所有子指令的post-link函数将要执行之前 post-link 来执行业务逻辑，这个阶段，它已经知道所有的子指令已经编译完成并且pre-link以及post-link函数已经执行完成 当同时设置compile和link函数，compile所返回的函数当做link函数，而link选择本书则会被忽略，如果注释掉compile，link就起作用了 默认的angular路由中，#号怎么去掉这个原因是因为angular框架提供一种html5模式的路由可以设置$locationProvider1$locationProvider.html5Mode(true) 缺点是无法刷新，404需要配置服务器来修复]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angularjs组件化开发]]></title>
      <url>%2F2017%2F03%2F30%2Fangularjs%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[正在码字中。。。 特点： MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等 模块化来分隔组织打包软件，每个模块完成一个特定的子功能，所有的模块按某种特定的方法组装起来。成为一个整体，完成整个系统，完成整个系统所要求的功能 模块化的目的就是为了降低程序复杂度，使程序设计、调试和维护等操作简单化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[软件测试基础教程]]></title>
      <url>%2F2017%2F03%2F28%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[和测试沟通，了解测试的黑白测试，知己知彼，少出bug 第五章 动态分析-测试设计技术软件测试被看成是在计算机上执行测试对象的过程。这个过程被称为动态分析，这里的测试对象程序必须是可以执行的，程序执行之前需要提供输入数据。在低级别的测试阶段，测试对象往往无法单独运行，为了能运行测试对象，必须将测试对象继承到测试台。 测试对象通常需要通过事先定义的接口来调用程序的不同部分，当程序的某些部分还没有完成，也就是还不能够调用程序的不同部分。可以用桩来模拟。 桩模拟程序通常由测试对象调用的那部分的输入/输出行为。 测试台必须能够为测试对象提供输入数据，有时还需要模拟程序中调用测试对象的部分，这就是驱动器的工作。 驱动器和桩组合构成了测试台，测试台和测试对象一起形成了一个可执行的程序。 测试人员要创建测试台，扩展或修改标准的测试台，为了适合测试对象的接口调整测试台。这个过程可以使用测试台生成器完成。 在执行是，测试必须以尽可能少的成本尽量多地发现失效，验证尽量多的需求。采用系统化的测试方法，理想的当然是对测试对象工作的所有可能情况都进行测试。 测试执行的主要步骤 确定测试条件和前置条件，以及测试需要达到的目标 指定单个测试用例 确定如何执行 在设计测试用例是，必须确定如何将每个需求和测试用例之间想关联，从而可以确定测试对需求的覆盖率 执行单个测试用例没有意义，需要按照一定的方式进行组合，从而按照一定的顺序执行，这样的测试记录应该记录在测试规程规格说明，同时应该包含测试优先级，以及测试与回归测试用例之间的技术上和逻辑上的依赖关系 为了使测试用例按顺序执行，需要使用测试脚本，测试脚本包含是测试自动按顺序执行的指令 JUnit 对象测试有几种不同的方法黑盒测试和白盒测试 黑盒测试/功能测试/行为测试 测试对象呗看成一个黑色的盒子，测试用例从测试对象的规格说明中获取，测试用例的设计基于测试对象的规格说明或者需求文档，值观察程序的输入输出行为 白盒测试/结构测试 需要熟悉代码进行测试设计，实行测试用例的时候，需要分析测试对象内部的工作过程以及测试输出，白盒测试技术可以应用在低级别的测试中，如组件测试和集成测试 黑盒测试技术测试人员不用考虑内部结构和具体设计 等价类划分每个输入数据元素的各种可能的输入值的域被划分为等价类。等价类是测试人员认为测试对象将以相同的方式来处理的一组数据值，对等价类的一个代表性数据进行测试就够了，而对等价类中的任何其他输入值进行测试，对象都不会有不同的反应和行为。在测试过程中不仅要对有效输入的等价类进行测试，而且还要对无效输入值得等价类进行测试。 最好的测试值是验证等价类边界的那些值 由所有代表值组合而成的测试用例按使用频率进行排序，并按照这个序列设置优先级 优先级考虑包含边界值或者边界值组合的测试用例 将一个等价类的每个代表值和其他等价类的 保证满足最小原则，一个等价类的每个代表值至少在一个测试用例中出现 无效等价类的代表值不与其他无效等价类的代表值进行组合 独立测试无效值 边界值分析边界值分析是对等价类划分导出的测试用例的一个非常合理的补充。程序中错误经常出现在等价类的边界值上，出现这种现象的原因是没有明确定义边界值 在每个边界值上，需要测试一个边界值和两个最近值，测试的边界值一个在等价类内部，另一个在等价类外部 状态转换测试很多情况下，测试对象的输出和行为方式不仅受当前输入数据的影响，同时还与测试对象之前的执行情况，或之前的状况或者以前输入的数据有关。为了说明测试对象和历史数据之间的关系，引入了状态图。 因果图技术和决策表技术白盒测试技术基于代码的测试，基本思想是吧测试对象的每个部分代码至少执行一次，分析程序逻辑，然后执行用例 语句覆盖确定执行了那些语句，当达到实现定义的测试覆盖率后，就可以认为测试已经足够并且可以终止测试 分支覆盖更加有效的覆盖准则是控制流图的分支覆盖控制流图中的边是分支覆盖关注的交单，它不考虑每条语句的执行情况，而是考虑判定的执行情况，判定的解构决定接下来执行那条语句]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[犀牛书第三章]]></title>
      <url>%2F2017%2F03%2F15%2F%E7%8A%80%E7%89%9B%E4%B9%A6%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[重读犀牛书 第三章 ##chapter 3 类型、值和变量 能表示或操作的值的类型叫做操作类型 变量是一个值的符号名称，通过名称来获得对值得引用。 javascript的数据类型分数据类型为原始数据类型和对象数据类型。 原始数据类型包括数字、字符串、布尔值、null和undefined。对象数据类型除了上面的类型都是对象，对象是property的集合。以下属于对象数组是特殊的对象，带编号有序列的集合。函数是特殊的对象，具有与它相关联的可执行代码的对象，通过调用函数来运行可执行代码，并返回结果。构造函数使用 new运算符来初始化函数类每个构造函数定义了一类（class）对象—由初始化的对象组成的集合。类可以看做是对象类型的子类型。日期正则错误 javascript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收。按需创建，不用担心销毁和回收。 javascript面向对象的语言，不用全局定义函数去操作不同类型的值，数据类型本身可以定义方法来使用。 javacript 还可以分为可变类型和不可变类型。对象和数组可以修改为可变类型。数字、布尔值、字符串、null和undefined 不可变类型。 javascript 中变量是无类型的，不在任何函数内声明的变量叫做全局变量 数字（p35）javascript 不区分整数值和浮点值。均用浮点表示。（IEEE 754：一种二进制表示法，可以精确的表示分数）一个数字出现在javascript程序中，叫做数字直接量。任何数字直接量前添加负号，得到负值。负号是一元求反运算符，不是直接量语法。 整型直接量javascript支持十进制、十六进制。不直接支持八进制，但某些实现支持八进制，八进制的某些数字已0开始。严格模式下不支持。 浮点型直接量浮点型由整数、小数、小数部分组成。还可以使用指数计数法使用浮点型直接量。 javascript中的算术运算符 + - * / % Math对象的属性定义 函数 说明 Math.pow (2, 53) 2的53次幂 Math.round(.6) 四舍五入 Math.ceil(.6) 向上求整 Math.floor(.6) 向下求整 Math.abs(-5) 求绝对值 Math.max(x, y, z) 求最大值 Math.min(x, y, z) 求最小值 Math.random() 生成一个大于0 小于1.0的随机数 Math.PI 圆周率 打乱arr数组的顺序1234567891011121314151617181920212223var arr = [1, 2, 3, 4, 5];arr.sort(function (a, b) &#123; return 0.5 - Math.random();&#125;)``` javascript的算术运算符在溢出、下溢、被0整除不会报错。- 当数字溢出的时候，结果作为无穷大。- 当出现下溢的时候，结果返回0- 被0整除，返回无穷大或者负无穷大- 0除0， 无穷大除无穷大，无法转换的数字都用NAN表示Infinity(无穷大值)、NaN(非数字)。NaN和任何都不相等，包括本身。**isNaN()** 如果参数是NaN或者是一个非数字值，返回true**isFinite()** 参数不是NaN、Infinity、-Infinity，返回true## 二进制浮点数和四舍五入 javascript通过浮点数的形式只能表示其中有限的个数, 采用IEEE-754浮点数表示法，是一种二进制表示法，可以精确表示分数，不能正确表示十进制分数。因此带来误差，要使用大整数来解决。## 日期和时间 var then = new Date(2011,0,1) //Sat Jan 01 2011 00:00:00 GMT+0800 (中国标准时间)var later = new Date(2011,0,1,17,10,30) //Sat Jan 01 2011 17:10:30 GMT+0800 (中国标准时间)var now = new Date() //当前日期 //Tue Mar 22 2016 16:18:30 GMT+0800 (中国标准时间)var elapsed = now - then; //时间间隔是毫秒 164823510655later.getFullYear(); //年 2011later.getMonth(); //月 0later.getDate(); //天 1later.getDay() // 星期几 6later.getHours() // 时间 17later.getUTChours() // 时区时间 91234567891011121314# 文本**字符串**是一组有16位组成的不可变的有序数列，每个字符通常来自于Unicode字符集。 Javascript通过字符串类型便是文本。**空字符串**长度为0，Javacript中没有表示单个字符的‘字符型’一个长度为2的字符串可能表示一个Unicode字符。## 字符串直接量字符串必须写在一行中，可以拆分数行每行以(\)结束。如果希望另起一行可以用\n。单引号和撇号同用时 ，撇号可以用 \&apos; 可以作为区分。## 转义字符```js&apos;You\&apos; re right, it can\&apos;t be a quote &apos; \n换行符\&#39;撇号（单引号） 字符串的使用+运用于数字，表示两数相加。用于字符串，可以链接字符串。 注意: 字符串调用的方法不会改变字符串本身，都是返回一个新的。 模式匹配正则表达式 和 Date 都是一种具有实用API的特殊对象 布尔值任意的js值可以转为布尔值。undefined null 0 -0 NaN &quot;&quot; 都是false其他都是true 布尔值包含toString()方法 null和defined 值 typeof 说明 null object 表示数字、字符串、对象无值 undefined undefined 未定义的空值，元素不存在 ==认为两者相等===不等null 和 undefined 不包含任何属性和方法赋值给变量首选null 全局对象全局对象是全局定义的符号，js可以直接使用 比如 Math JSON 在代码的最顶级——不在任何js代码内可以使用this来引用全局对象 window对象充当全局对象如果代码声明一个全局变量，则这个全局变量就是全局对象的一个属性 包装对象对象是一种复合值，通过.符号引用属性值，当属性值是一个函数的时候，称其为方法。 12var s = 'hello';var world = s.substring(s.indexOf('')+1, s.length); 只要引用了字符串s的属性，js将字符串通过 new String(s)方式转换成对象，这个对象继承了字符串的方法。一旦属性引用结束，这个新建对象就会销毁。 123var s = &quot;test&quot;;s.len = 4; //对象包装var t = s.len //undefine 字符串、数字和布尔值读取属性值的时候，如果试图给其赋值，则会忽略操作，而临时创建的对象叫做包装对象原始值和包装对象的typeof是不同的 12var s = &quot;test&quot;; //stringvar S = new String(s); //Object 他们类型不一样 不可变的原始值和可变的引用对象（p47） 原始值不可更改，比较的是值。比如字符串必须长度字符都相等才是相等。对象是可变的，它们的值可以修改。两个对象包含同样的属性及相同的值，它们也不等。各个索引值相等也不相等，对象称为引用类型。对象的比较均是引用比较，当且仅当他们引用同一个基对象，才相等。 12345var a = [];var b = a;b[0] = 1;console.log(a[0]); // 1a === b // true 复制一个数组对象12345var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var b = [];for(var i = 0; i &lt; a.length; i++)&#123; b[i] = a[i]&#125; 比较两个数组对象 123456789function equal (a,b)&#123; if( a.length != b.length) return false; for( var i = 0; i &lt; a.length; i++)&#123; if(a[i]!=b[i])&#123; return false &#125; &#125; return true;&#125; 类型转换 值 转换为字符串 数字 布尔 对象 undefined “undefined” NaN false throws TypeError null “null” NaN 0 false throws TypeError true “true” 1 new Boolean(true) false “false” 0 false new Boolean(false) “” (空字符串) 0 false new String(“”) “1.2”（非空，数字） 1.2 true new String(“1.2”) “one”（非空，非数字） NaN true new String(“one”) 0 “0” false new Number(0) -0 “0” false new Number(0) NaN “NaN” false new Number(NaN) Infinity “Infinity” true new Number(Infinity) Infinity “-Infinity” true new Number(-Infinity) 1(无穷大，非0) “1” true new Number(1) {} (任意对象) “1” true “” 0 true ‘[ ‘ 9 ‘]’ ( 1个数字元素 ) “9” 9 true ‘[‘ a ‘]’( 其他数组 ) 使用join()方法 NaN true functtion (){} (任意函数) NaN true 转换和相等性 undefined 可以转换为布尔值，但是不表明 undefined == false显示类型转换 Boolean()、Number()、String() toString() Object()隐式转换 + !123x + &quot; &quot; //等价与String()+x //等价Number.!!x //等价于Boolean(x) toString()可以接受转换基数12var n =17;n.toString(2); //转化为10001 Number 定义了三种数字转换字符串的场景 n.toFixed(m); 根据m的值确定小数点后数字个数。12var n = 123456.789n.toFixed(2) // 123456.78 n.toExponential (m);用指数计数法，其中小数点前只有一位，小数点后有m-1位。12var n = 123456.789n.toExponential (2) //1.2e+5 n.toPrecision(m) 有效的数字位数将数字转换为字符串。1n.toPrecision(7) //123456.8 Number()转换传入一个字符串，会试图转换为一个整数或者浮点，这个方法只能基于十进制书。 parseInt() 只能解析整数，parseFloat() 可以解析整数和浮点数。如果字符串前是0x或者0X，则parseInt()将解释为十六进制数。如果是非法字符，返回NaN。parseFloat() 可以跳过前空格并可以解析’.1’，而parseInt不可以解析’.1’。第二个可选参数是转换的基数。12parseInt(&apos;11&apos;,2); // 3parseInt(&apos; ff &apos;, 16); //255 对象转换为原始值(p52) #####toString() 1234[1,2,3].toString(); //1,2,3(function(x)&#123; f(x)&#125;).toString() //function (x)&#123; f(x)&#125;/\d+/g.toString() ///\d+/gnew Date(2010,0,1).toString() //Fri Jan 01 2010 00:00:00 GMT+0800 (中国标准时间) #####valueOf()返回对象本身，而不是返回一个原始值。 1234[1,2,3].valueOf(); //[ 1, 2, 3 ](function(x)&#123; f(x)&#125;).valueOf() //[Function]/\d+/g.valueOf() ///\d+/gnew Date(2010,0,1).valueOf() //1262275200000 方法 对象 toString原始值结果 valueOf原始值结果 toString() 数组 字符串 数组 toString() 函数 函数的实现定义的表示方法 [Function] toString() 日期 可读的日期和时间字符串 以毫秒来表示 toString() 正则 表示正则的表达式直接量 表示正则的表达式直接量 对象到字符串转换先用toString返回字符串，如果不成功再用valueOf()返回字符串,否则抛出异常。对象到数字转换先用到valueOf返回数字，如果不成功再用toString()返回数字,否则抛出异常。 数组继承了valueOf方法，这也就是为什么空数组和单个的数组转换原始值会一个0或者数字。“+”、“==”都是将对象转换为原始值。对象到原始值的转换基本都是对象到数字的转换。而日期对象通过valueOf或toString()可以直接用。 12345var now = new Date()typeof (now +1 ) //stringtypeof (now -1) //numbernow == now.toString() //隐式和显式的字符串转换now &gt; (now -1) // &gt; 将日期转为数字 声明变量var 声明 初始undefine 变量作用域函数体内局部变量的优先级高于全局变量，声明局部变量时候一定写var 否则赋值就是给全局变量js使用函数作用域，变量在声明函数体以及这个函数体的任意嵌套都是有定义的。 1234567891011121314function test(o)&#123; var i = 0; if(typeof o == &quot;object&quot;)&#123; var j = 0; for(var k = 0; k &lt; 10 ; k++)&#123; console.log(k); &#125; console.log(k); &#125; console.log(&apos;j =&apos; + j) // undefine&#125; test(5); JS 可以声明提前。在函数体内局部变量遮盖了同名全局变量。123456var name=&quot;global&quot;; if(true)&#123; var name=&quot;local&quot;; console.log(name) //local&#125; console.log(name); // local 当声明了一个js全局变量时，实际是定义了全局对象的一个属性。如果没有通过var 声明变量，那么他们都可以通过delete删除。12345678910function t(flag)&#123; if(flag)&#123; s=&quot;ifscope&quot;; for(var i=0;i&lt;2;i++) ; &#125; console.log(i); &#125; t(true); console.log(s); // ifsope s是全局变量 js关键子来引用全局对象，却没有办法引用局部变量。 js最顶层代码中，作用域由一个全局对象组成。 不嵌套的函数体，有两个对象，一是函数参数和局部变量的对象，二是全局对象。 嵌套函数至少在三个以上。 当调用一个函数的时候，创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的的那个作用域链上，同时创建一个新的更长的表示函数调用作用的“链”。 参考文件https://segmentfault.com/a/1190000002692982https://segmentfault.com/a/1190000003935661http://www.2cto.com/kf/201405/298344.htmlhttp://web.jobbole.com/84041/http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react 慕课网入门笔记]]></title>
      <url>%2F2017%2F03%2F15%2Freact%E5%85%A5%E9%97%A8%E6%85%95%E8%AF%BE%E7%BD%91%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[学习慕课网的react 入门教程 视频地址 http://www.imooc.com/learn/504 API http://reactjs.cn/react/docs/getting-started-zh-CN.html React 介绍 react 不是完整的mvc框架，mvvm框架 用组件的方式，通过组合来实现大的模块 应用场景 复杂场景的高性能 组件高度可重用 JSX = JS + XML 语法糖，计算机语言中没有添加的某种语法，对功能没有影响，增加可阅读性，减少出错。例如 JSX 最终都会编译成JS react 里面的 不能看成 dom ,而是react component的实例 React 的 style demo http://jsfiddle.net/reactjs/69z2wepo/ React-components-lifecycleMounted -&gt; Update -&gt; Unmounted Mounted React Components被render解析生成对应的dom节点并被插入浏览器的DOM解构的一个过程,当在浏览器从无到有的渲染的一个过程，就是Mounted结束，我们就说这个component组件已经被Mounted Update 一个mounted的react Components 被重新render的过程,而这个重新被渲染的过程并不是说dom解构会发生改变，react 会把这个component的当前state 和最近一次state进行对比，只有发现确实发生的改变并且影响的当前的DOM结构，react 才会改变对应的dom解构 Unmounted 一个Mounted的React Components 对应的DOM节点被从DOM解构中移除的一个过程 hook() 函数每一个状态react都封装了对应的hook函数，设计思想是will和did, 将要做什么了和已经做了什么。 Mounted getDefaultProps() -&gt; getInitialState() -&gt; componentWillMount() -&gt; render -&gt; componentDidMount() componentWillMount() 将要Mounted调用 componentDIdMount() 已经Mounted调用 getInitialState() 初始化react state的 props和state都可以设置css样式state值是可变的，props是通过组件调用方，通过组件决定，一旦定义不改变 this 指调用函数的对象 当前this compoentent 的实例 如果在setTimeout里面this指代globl对象 如果在构造函数中，this就指这个新生成的对象 通过调用apply call bind 调用后的this对象 demo http://codepen.io/mayufo/pen/EWQmKN state 值每次变化，会进入updating 状态，使其进入一个render的过程 updating componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate - componentWillReceiveProps() Mounted Component将要接收新的props时，这个函数会被调用，其函数参数就是新的props对象，可以通过参数和this.props进行比较，来执行一些例如修改state的操作 - shouldComponentUpdate 当接收到新的props和state之后，判断是否有必要去更新dom结构，有两个参数，一个是新的props对象，另一个是新的state对象，可以分别对比，来决定是否更新dom,返回true是更新dom节点，返回false是不更新dom节点。 Unmounting componentWillUnmount() 可以释放内存资源，图片资源 react component state的更新，会触发页面更新，而传统的页面更新时通过修改页面dom实现 传统的事件处理通过 event listener， demo http://codepen.io/mayufo/pen/GWQvxM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dom详解]]></title>
      <url>%2F2017%2F03%2F13%2Fdom%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[用mvc框架多了，已经忘了dom 看dom详解，做的一些笔记。方便以后巩固加强，方便自己查询。 初始DOMjs由三部分组成ECMAscript 是js的核心标准，也是一个解析器DOM 是document提供的一些方法或熟悉用来操作页面BOM是window提供的一些方法或者属性用来操作浏览器 （拉倒底部数据加载） DOM (document object model) 文本对象模型 就是document提供一些api赋予开发者操作页面的能力 DOM结构是树形，顶端为DOM -&gt; 根元素 -&gt; …一般分为三大关系 父级关系 只有一层上下级关系（从当前往上走） 子级关系 只有一层以下一层的关系 兄弟关系 同一个父级 （同一级） 按照层级划分 父子节点： 上下两层节点之间的关系 祖先节点： 当前节点上面的所有节点 子孙节点： 当前节点下面的所有节点的统称 节点类型按照节点的类型划分 查看某个节点类型 nodeType 返回一个数字 表示节点的类型 整个页面都是节点都可以看做节点 节点分类 元素节点 nodeType: 1 element 就是一个标签 document nodeType: 9 元素中的文字(包括空格回车换行) nodeType: 3 注释节点 nodeType: 8 attributes 代表元素的属性 是一个集合 nodeType代表数字2 找到属性查看值nodeValue, nodeName查看节点的属性名 如果是&lt;p&gt; 输出P 如果是&lt;div&gt; 输出DIV 如果是文字输出 #text 子节点childNodes 某个节点下的所有子节点，是一个类数组下标为0 的时候可以打出标签的内容 1&lt;div id='div'&gt;12345&lt;/div&gt; 1234var odiv = document.getElementById('div');console.log(odiv.childNodes) // [text] 类数组console.log(odiv.childNodes[0]) // 12345console.log(odiv.childNodes[0].nodeType) demo https://jsfiddle.net/mayufo/6p26L8wd/ 12&lt;div id='div'&gt;&lt;!--注释--&gt;2222&lt;/div&gt; 两个子节点之所以没有空格 因为空格回车代表节点3类型 12345var odiv = document.getElementById('div');console.log(odiv.childNodes[0].nodeType); // 8console.log(odiv.childNodes[1].nodeType); // 3console.log(odiv.childNodes.length); // 2 demo https://jsfiddle.net/mayufo/qk3znLft/ 注释节点如果查看注释的值? div.childNode[0].nodeValue demo 当点击页面的时候 li 改变宽度 123456li &#123; transition: 1s; width: 20px; height: 20px; background: red;&#125; 12345678&lt;ul id="ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; childNodes查找到除元素外还能查找到空格回车元素123456789var ul = document.getElementById('ul');var lis = ul.childNodes; // 11 个 包括空格和换行 &lt;li&gt;标签前后的document.onclick = function () &#123; for (var i = 0; i &lt; lis.length; i++ )&#123; if(lis[i].nodeType === 1 ) &#123; lis[i].style.width = '150px'; &#125; &#125;&#125; children: 不是标准的属性，但是所有浏览器都支持，找到摸个元素下所有元素子节点1234567var ul = document.getElementById('ul');var lis = ul.children; // 5 document.onclick = function () &#123; for (var i = 0; i &lt; lis.length; i++ )&#123; lis[i].style.width = '150px'; &#125;&#125; demo https://jsfiddle.net/mayufo/0h1yfdox/ 父节点parentNode查找某个元素的父节点 12345678&lt;ul id="ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 12345678 var ul = document.getElementById('ul'); var alis = ul.children; console.log(alis[0].innerHTML); // 1console.log(alis[0].parentNode); // &lt;ul id="ul"&gt;..&lt;/ul&gt;console.log(alis[0].parentNode. parentNode); // &lt;body&gt;console.log(alis[0].parentNode. parentNode. parentNode); // 页面中最大的父元素是document 再大就是null demo https://jsfiddle.net/mayufo/27q1dacp/ parentNode 例子 12345&lt;ul&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;22&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;22&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 123456var a = document.getElementsByTagName('a');for (var i = 0; i &lt; a.length; i++) &#123; a[i].onclick = function () &#123; this.parentNode.style.display = 'none'; &#125;&#125; demo https://jsfiddle.net/mayufo/5r41hv2e/ 兄弟节点nextElementSibling 找到某个元素的下个兄弟节点 nextElementSibling举例 12345&lt;ul id='ul'&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;22&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;33&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 12345var ul = document.getElementById('ul');var alis = ul.children;console.log(alis[0].nextElementSibling); // &lt;li&gt;22&lt;/li&gt;console.log(alis[0].nextElementSibling. nextElementSibling); // &lt;li&gt;33&lt;/li&gt; 超出为null previousElementSibling 找到某个元素的上个兄弟节点 previousElementSibling 举例同 nextElementSibling firstElementChild找到第一个子节点 lastElementChild 找到最后一个子节点 1234var ul = document.getElementById('ul');ul.firstElementChild; // &lt;li&gt;111&lt;/li&gt;ul.lastElementChild; // &lt;li&gt;333&lt;/li&gt; offsetLeft、offsetParentoffsetParent 最近的有定位属性的祖先节点, 如果父节点都没有定位，默认定位是body，否则是定位该元素父级上设置position: relative的元素。 12345&lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12var div3 = document.getElementById('div3'); console.log(div3.offsetParent); 123456789101112131415div &#123; padding: 100px;&#125;#div1 &#123; background: red; position: relative;&#125;#div2 &#123; background: blue;&#125;#div3 &#123; background: green;&#125; demo https://jsfiddle.net/mayufo/pnkcogjy/ offsetLeft、offsetTopoffsetLeft 外边框到有定位父级的内边框的距离, 如果没有父级position: relative的定位，子级也没有position: absolute,定位默认到body。和offsetParent有关, 得到的数字没有单位。 offsetTop 上边框到有定位父级的上呗边框的距离 这里注意没有offsetRight和offsetBottom 使用场景：方便获取元素的位置 getComputedStyle(div3).left 也可以得到，有单位。 例子 当点击按钮，将div3移动到左顶边 12345678&lt;input type="button" id="btn" value="btn"&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132*&#123; margin: 0; padding: 0;&#125;#div1&#123; background: red; width:100px; height:100px; margin-left: 50px; position: relative; border: 10px solid #000;&#125;#div2&#123; background: blue; position: relative; width:60px; height:60px; top:20px; left:30px; border: 10px solid #000;&#125;#div3&#123; width:30px; height:30px; background: yellow; position: absolute; top:20px; border: 1px solid #000; left:0; transition:1s left;&#125; 1234567891011121314151617var div3 = document.getElementById('div3');var btn = document.getElementById('btn');var div3Border = parseInt(getComputedStyle(div3).borderLeftWidth); // 减去自身的边框btn.onclick = function () &#123; var left = 0; var elem = div3; while(elem) &#123; left += elem.offsetLeft + parseInt(getComputedStyle(elem).borderLeftWidth); elem = elem.offsetParent; &#125; left -= div3Border; div3.style.left = - left + 'px';&#125; demo https://jsfiddle.net/mayufo/q7d1bozj/ 计算绝对位置getBoundingClientRect()getBoundingClientRect()获取某个元素的信息，left、top、bottom、right、width、height,返回值是一个对象。 注意： 获取的值会根据滚动条变化 123&lt;input type="button" id="btn" value="btn"&gt;&lt;div id="div1"&gt;&lt;/div&gt; 123456var div = document.getElementById('div1');var btn = document.getElementById('btn');btn.onclick = function () &#123; console.log(div.getBoundingClientRect()) // bottom:130,height:100,left:58, right:158, top:30, width:10&#125; demo https://jsfiddle.net/mayufo/cL50o17d/ 元素属性操作getAttribute获取元素属性,操作某个元素的行间属性.不是行间无法获取到。 1&lt;div id="div1" index="2"&gt;&lt;/div&gt; 12345678910111213141516171819var div = document.getElementById('div1');// 想获取id的值console.log(div['id']); // div1console.log(div.getAttribute('id'));// 如果是div.index = 2 直接设置，getAttribute无法获取到index的值div.index = 2;console.log(div['index']); // 主要取对象属性的值，有时候不能取到行间属性的值console.log(div.getAttribute('index')); // 主要取对象属性的值，无法取到对象属性设置的值div.setAttribute('index', '4'); // 删除元素行间属性div.removeAttribute('index'); demo https://jsfiddle.net/mayufo/ng629u96/ setAttribute设置元素的行间属性 removeAttribute 删除元素的行间属性 上面三种方法可以获取href或src的相对路径 如果图片中存在中文的路径，打出图片地址的时候，有的浏览器中文的路径会显示乱码。所有通常情况不能直接拿此console.log(img.src)作为判断 可以通过getAttribute来得到写的路径 元素宽高的获取clientWidth 可视内容的宽度，没有单位，不计算边框border, 不会计算padding， 不计算margin clientHeight 可视内容的高度，没有单位，不计算边框border, 不会计算padding, 不计算margin 注意：如果div内容超出，只算div显示的宽高 1234#div1 &#123; height: 200px; width: 200px;&#125; 1&lt;div id="div1"&gt;&lt;/div&gt; 123var odiv = document.getElementById('div1');console.log(odiv.clientWidth);console.log(odiv.offsetWidth); offsetWidth 获取某个元素的宽度，会计算border的, 计算padding, 不计算margin offsetHeight 获取某个元素的宽度，会计算border的, 计算padding, 不计算margin document.documentElement.clentWidth 可视区的宽度 document.documentElement.clentHeight 可视区的高度 让一个不确定宽高的元素居中显示 元素的left = （可视区 - 元素的宽）/ 2 元素的top = (可视区 - 元素的高) / 2 1&lt;div id='div1'&gt;2222&lt;/div&gt; 123456#div1 &#123; height: 100px; width: 100px; background: red; position: absolute;&#125; 123456789101112var odiv = document.getElementById('div1'); // 记得div1 position: absolutevar clientW = document.documentElement.clientWidth;var clientH = document.documentElement.clientHeight;console.log(odiv);var iW = odiv.offsetWidth;var iH = odiv.offsetHeight;odiv.style.left = (clientW - iW) / 2 + 'px';odiv.style.top = (clientH - iH) / 2 + 'px'; demo https://jsfiddle.net/mayufo/eLLuspjp/ 创建元素 点击添加元素 可以通过字符串的拼接 通过createElement(‘标签的名字’), 如果创建没有的标签，也会出现自定义的标签 插入元素 parentNode.appendChild(childNode) 向父级的尾部添加一个元素 插入元素 插入元素 parentNode.inserBefore (新添加的元素， 添加的元素位置，会添加到这个元素之前) 向父级中的某个元素前插入元素 特性 如果第二个参数为假的，则将这个元素添加到父元素的第一个 删除元素 父级.removeChild（自定的子级点) 如果指定的子节点没有会报错 1234&lt;input type="button" id="btn" value="button"&gt;&lt;ul id="ul"&gt; &lt;li&gt;0&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526272829303132333435363738var btn = document.getElementById('btn');var oul = document.getElementById('ul');var html = '';var num = 0;btn.onclick = function() &#123; num++; html += '&lt;li&gt;' + num + '&lt;/li&gt;'; oul.innerHTML = html;&#125;;// appendChildbtn.onclick = function() &#123; num++; var li = document.createElement('li'); //创建li标签 li.innerHTML = num; ul.appendChild(li); console.log(li.nodeType); // 1 元素节点&#125;;// insertBefore btn.onclick = function() &#123; num++; var li = document.createElement('li'); //创建li标签 li.innerHTML = num; ul.insertBefore(li, ul.children[0]);// 将ul的第一个子节点插入元素 console.log(li.nodeType); // 1 元素节点 &#125;; // removeChild btn.onclick = function() &#123; if(ul.lastElementChild) &#123; ul.removeChild(ul.lastElementChild); &#125; &#125; demo https://jsfiddle.net/mayufo/vyzxgmnf/1/ 元素替换 当点击按钮的时候，将红色替换成蓝色 123456&lt;input type="button" id="btn" value="button"&gt;&lt;div id="box"&gt; &lt;div id="red"&gt;&lt;/div&gt; &lt;hr id="hr"&gt; &lt;div id="blue"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910var red = document.getElementById('red');var hr = document.getElementById('hr');var blue = document.getElementById('blue');var btn = document.getElementById('btn');var box = document.getElementById('box');btn.onclick = function () &#123; box.replaceChild(red, blue);&#125; demo https://jsfiddle.net/mayufo/ofp5Lv19/ 父级.replaceChild(node(要替换成什么), childNode（谁被替换）) 都是剪切的操作 克隆 将蓝色方块克隆，放到红色方块下 要复制的元素.cloneNode(false); 克隆某个元素，克隆只克隆元素本身，克隆不会克隆下面的子节点, 如果参数改为true 就可以默认赋值子节点,默认值为false.事件不会被克隆的克隆才是真正的赋值 12345678var red = document.getElementById('red');var hr = document.getElementById('hr');var blue = document.getElementById('blue');var btn = document.getElementById('btn');var box = document.getElementById('box');var elem = blue.cloneNode();box.insertBefore(elem,hr); demo https://jsfiddle.net/mayufo/cymoh67c/ 表格12345678910111213141516171819202122232425262728293031323334 &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;head1&lt;/th&gt; &lt;th&gt;head2&lt;/th&gt; &lt;th&gt;head3&lt;/th&gt; &lt;th&gt;head4&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;content1&lt;/td&gt; &lt;td&gt;content2&lt;/td&gt; &lt;td&gt;content3&lt;/td&gt; &lt;td&gt;content4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;content1&lt;/td&gt; &lt;td&gt;content2&lt;/td&gt; &lt;td&gt;content3&lt;/td&gt; &lt;td&gt;content4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;foot1&lt;/td&gt; &lt;td&gt;foot2&lt;/td&gt; &lt;td&gt;foot3&lt;/td&gt; &lt;td&gt;foot4&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; 123456789101112var table = document.getElementById('box');table.tHead.style.borderColor = 'red';table.rows[1].style.background= 'blue';console.log(table.tBodies);table.tBodies[0].style.background = 'red';table.rows[1].cells[2].style.background = 'pink'; table.tHead 选取表格的表头 table.rows 获取tr 获取表格中所有的tr, 得到一个数组，指定某个需要下标 表头和表尾也会算入tr的list中, 比tbody优先级高 table.tBodies 获取表格中所有的tbody, 得到一个数组，指定某个需要下标 table.row[n].cells[i] 获取表格中其中一个td,需要指定下标。前面也可以结合tBodies demo https://jsfiddle.net/mayufo/aum5cz9n/ 渲染一个表格 demo https://jsfiddle.net/mayufo/uLLmm7t6/ #练习 - 留言板 https://jsfiddle.net/mayufo/4u5v6tno/2/ - 上移下移 https://jsfiddle.net/mayufo/sLj50rwx/ - 排序 https://jsfiddle.net/mayufo/LvenLyy3/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[犀牛书第二章 词法结构]]></title>
      <url>%2F2017%2F03%2F13%2F%E7%8A%80%E7%89%9B%E4%B9%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[重读犀牛书 第二章 2.1 字符集 javascript 程序是Unicode字符集编写的。 javascript 区分大小写。 HTML 不区分大小写。 Unicode允许多种方法进行编码，显示结果一样，但是处理方式不一样。 2.2 注释 可以使用 // 或者 /**/注释，但是不能嵌套。(P27) 2.3 直接量 可以直接使用的数据值 2.4 标识符和保留字标识符就是用来对变量和函数进行命名，或者循环语句中位置标记JavaScript必须以字母，下划线或$开始。后接的可以字母，数字，下划线，美元符。（数字不能出现在首字母）也可以用非英文语言或数字作为标识符，比如π也不能使用保留字作为标识符。 2.5 可选分号语句用分号分开。（P30）如果独占一行可以省略分号。无法解析的两个例外 return break和continue随后的表达式之间不能换行，系统会自动添加分号。 ++ --作为表达式的后缀，应该和表达式在同一行。 否则，行尾将填补分号。 1234567var aa=3//解析为 // var a // a = 3 如果以 （ [ / + - 开始极有可能和之前语句合在一起解析。1234var y = x+ f(a+b).toString()//解析//var y = x+ f(a+b).toString(); 涉及return、break、continue。则不能换行 12345returntrue //解析 //teturn; //true 涉及到 ++ 或 – 123456x++y//解析//x;//++y;]]></content>
    </entry>

    
  
  
</search>
