<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ajax原理]]></title>
      <url>%2F2017%2F04%2F05%2Fajax%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[评级问题总结]]></title>
      <url>%2F2017%2F04%2F05%2F%E8%AF%84%E7%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[BOM和DOM 含义，全拼document object model 文档对象模型，把文档当做一个对象来看待browser object model 浏览器对象模型 把浏览器当做一个对象来看 javascript基础数据类型数字、字符串、undefined、对象、null、boolean 如何判断数据类型：typeof 常见类型的判断instanceof 对已知对象类型的判断其中typeof返回的类型都是字符串形式，在判断object类型是比较方便instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支 如何判断一个数据是数组类型：constructorinstanceofisArray 判断浮点数正则将这个浮点数转为字符串，判断里面是否有点 作用域和全局变量考察有一个div，它内部宽度不确定，我想让它相对于父元素垂直水平居中，如何设计？flex布局line-height 垂直， margin: 0 autoclentWidth - offsetWidth html语义化的理解便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析方便其他设备解析 http状态码：1 开头 代表消息2 代表成功3 重定向4 请求错误5，6 服务器错误 cookie，sessionStorage与localStorage区别 共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。。 css3新特性 css3 选择器 css3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是 ::selection. 媒体查询，多栏布局 border-image css选择器 兄弟选择器 属性选择器 引入normalize的作用。是保留浏览器的原来样式并且做到每个浏览显示一致 性能优化：减少请求、简化页面结构、优化代码、压缩机制、图片。css雪碧图的优缺点优点：减少请求，提升页面性能减少图片的字节数解决了图片命名的坤荣更换风格方便统一缺点在图片合并的时候，多张图片合并在一张图片，要保留好足够的空间，防止出现不必要的背景图片可维护性查，每次的修改都要在这个图片上修改，如果图片较多，你要记住位置图片的位置需要固定绝对值定位，失去了灵活性 display有哪些值:none、block、inline、inline-block,table。img元素是什么元素？inline17、XMLHttpRequest原生 哪些事件会触发脏检查？当在view绑定数据，触发事件都会触发脏检测 ng-model ng-click $digest和$apply有什么区别？$scope.$apply()会自动调用$rootScope.$digest()。$apply()函数可以以两种方式运行。第一种是将函数作为参数，并且评估他，然后触发$digest循环。第二种并不传入任何参数，仅仅是执行一个$digest循环。如果我们更改一个不在AngularJS执行上下文中的数据模型(model)，就需要人为的调用$apply()来提醒AngularJS数据发生变化了。就像是要告诉AngularJS，我们改变了一些数据，他应该启用监听器以便于让我们所做的改变能够反映出来。当你为$apply()传入函数的时候，这个函数在调用的时候是包含在try..catch中的，并且，任何发生的异常都能够被$exceptionHandler服务所接收。 https://segmentfault.com/a/1190000004523893 数据请求和前端资源优化？配置超长时间的本地缓存 —— 节省带宽，提高性能采用内容摘要作为缓存更新依据 —— 精确的缓存控制静态资源CDN部署 —— 优化网络请求资源发布路径实现非覆盖式发布 —— 平滑升级]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack]]></title>
      <url>%2F2017%2F04%2F02%2Fwebpack%2F</url>
      <content type="text"><![CDATA[webpack说的很简单，项目中也一直在用别人搭好的脚手架，一直很忙没有功夫细细研究下，这次一定认真研究下，以后使用再有问题和坑一并记录到这来 参考api http://webpack.github.io/docs/configuration.html中文api https://doc.webpack-china.org/guides/get-started/简易使用指南 https://github.com/petehunt/webpack-howto 当你拿到一个项目你需要 初始化项目1npm init 一路回车生成package.json 接下来你需要全局安装webpack 1npm i -g webpack 在项目中安装 1npm i -D webpack 创建如下目录结构 1234+ src - app.js+ distpackage.json 就可以使用webpack 进行简单的打包 app.js 1console.log(&apos;hello from app.js&apos;) 可以使用webpack进行简单打包 1webpack ./src/app.js ./dist/app.bundle.js 1webpack ./src/app.js ./dist/app.bundle.js -p //打包出来的文件被压缩处理 1webpack ./src/app.js ./dist/app.bundle.js --watch //打包出来的文件被压缩处理,并且实时监听文件的变化 可以看到打包好的文件生成在dist文件中，现在我们简化指令 创建webpack.config.js 123456module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; filename: &apos;./dist/app.bundle.js&apos; &#125;&#125; 再输入 1webpack 修改package.json1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack -d --watch&quot; //这条是添加的&#125; 这时我们在终端只需输入 1npm run dev 而实际上线我们需要代码压缩 12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack -d --watch&quot;, &quot;prod&quot;: &quot;webpack -p&quot; // 对代码进行压缩&#125;, webpack plugins 创建自定义的index在dist目录中创建index.html,并进入打包好的js文件 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;content goes here&lt;/p&gt; &lt;script src="./app.bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;``` 此刻我们不想通过手动在dist中创建html文件，利用webpack的plugin来帮我们创建 npm i html-webpack-plugin –save-dev1修改webpack.config.js,并删除dist目录中的index.html var HtmlWebpackPlugin = require(‘html-webpack-plugin’);var path = require(‘path’)module.exports = { entry: ‘./src/app.js’, output: { path: path.resolve(__dirname, ‘dist’), filename: ‘app.bundle.js’ }, plugins: [new HtmlWebpackPlugin()]}12然后运行 npm run dev12这时候你会看见目录里面自动生成index.html文件 &lt;!DOCTYPE html&gt; Webpack App 12如果想根据自己的模板创建index.html,需要修改webpack.config.js var HtmlWebpackPlugin = require(‘html-webpack-plugin’);var path = require(‘path’)module.exports = { entry: ‘./src/app.js’, output: { path: path.resolve(__dirname, ‘dist’), filename: ‘app.bundle.js’ }, plugins: [ new HtmlWebpackPlugin({ title: ‘myApp’, minify: { collapseWhitespace: true //生成被压缩的html文件 }, hash: true, template: ‘./src/index.html’, // 自定义的html路径 }) ]}12在src目录添加index.html &lt;!DOCTYPE html&gt; &lt;%= htmlWebpackPlugin.options.title %&gt; This is my template1234# css-load、sass-load## css-load npm install css-loader style-loader –save-dev1234567891011在app目录下生成app.css```csshtml,body&#123; height:100%; margin:0; background:green; color:#fff; font-size:20px;&#125; 修改webpack.config.js 123456789module: &#123; rules: [ &#123;test: /\.css$/, loaders: &apos;style-loader!css-loader&apos;&#125; // &#123;test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;]&#125; ] &#125;,``` 修改app.js import ‘./app.css’console.log(‘hello from app.js again’) 12## sass-loader npm install –save-dev sass-loader node-sass 12修改webpack.config.js module: { rules: [ {test: /.css$/, use: [‘style-loader’, ‘css-loader’]}, {test: /.scss$/, use: [‘style-loader’, ‘css-loader’, ‘sass-loader’]} ] },12修改app.js import ‘./main.scss’console.log(‘hello from app.js again’) 12在src目录新建main.scss body{background:#ff0;}12这样的打包方式最终加载页面head里面，但是如果吓你文件的方式引入进去 npm install –save-dev extract-text-webpack-plugin 12修改webpack.config.js var HtmlWebpackPlugin = require(‘html-webpack-plugin’);const ExtractTextPlugin = require(“extract-text-webpack-plugin”);var path = require(‘path’)module.exports = { entry: ‘./src/app.js’, output: { path: path.resolve(__dirname, ‘dist’), filename: ‘app.bundle.js’ }, module: { rules: [ {test: /.css$/, use: ExtractTextPlugin.extract({ fallback: ‘style-loader’, use: [‘css-loader’] })}, {test: /.scss$/, use: ExtractTextPlugin.extract({ fallback: ‘style-loader’, use: [‘css-loader’, ‘sass-loader’] })} ] }, plugins: [ new ExtractTextPlugin({ filename: (getPath) =&gt; { return getPath(‘css/[name].css’).replace(‘css/js’, ‘css’); }, allChunks: true }), new HtmlWebpackPlugin({ title: ‘myApp’, minify: { collapseWhitespace: true //生成被压缩的html文件 }, hash: true, template: ‘./src/index.html’, // Load a custom template (ejs by default see the FAQ for details) }) ]}1# webpack-dev-server npm i webpack-dev-server -D 1修改package.json “scripts”: { “test”: “echo \”Error: no test specified\” &amp;&amp; exit 1”, “dev”: “webpack-dev-server”, // 这里是刚修改的 “prod”: “webpack -p”} 1然后 npm run dev 12修改webpack.config.js，添加如下 devServer: { contentBase: path.join(__dirname, ‘dist’), compress: true, port: 8080, stats: ‘errors-only’, open: true // 启动后自动打开浏览器窗口},12# 清理dist npm i -D rimraf 12package.json修改 “scripts”: { “test”: “echo \”Error: no test specified\” &amp;&amp; exit 1”, “dev”: “webpack-dev-server”, “prod”: “npm run clean &amp;&amp; webpack -p”, “clean”: “rimraf ./dist/*”}123456这样的话会在每次打包的时候将dist目录清空，然后重新生成，以确保dist目录没有多余的无用文件# 多模块的使用一般情况一个项目肯定不止一个页面吧，解析来创建contact模块，修改webpack.config.js,在plugins中添加： new HtmlWebpackPlugin({ title: ‘contact’, hash: true, filename: ‘contact.html’, template: ‘./src/contact.html’})123456789101112131415在src根目录创建一个新的html模板contact.html```html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is contact!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 新建contact.js 12console.log('contact page') 由于有多个入口文件，修改webpack.config.js的entry和output 123456789101112131415161718192021222324252627entry: &#123; app: &apos;./src/app.js&apos;, contact: &apos;./src/contact.js&apos;&#125;,output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos;&#125;,``` 这时候再次启动服务器，我们发现contact.js被调用，这不是我们需要的，指向在contact.js在contact页面中被调用```jsnew HtmlWebpackPlugin(&#123; title: &apos;myApp&apos;, hash: true, filename: &apos;./index.html&apos;, excludeChunks: [&apos;contact&apos;], //新增 template: &apos;./src/index.html&apos;,&#125;),new HtmlWebpackPlugin(&#123; title: &apos;contact&apos;, hash: true, filename: &apos;contact.html&apos;, chunks: [&apos;contact&apos;], //新增 template: &apos;./src/contact.html&apos;&#125;) 这样两个模块就不会互相干扰 css js的局部刷新伴随项目越来越大，每次保存都会从新刷新打包，现在我们需要局部刷新 修改webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);var path = require(&apos;path&apos;)var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &#123; app: &apos;./src/app.js&apos;, contact: &apos;./src/contact.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos; &#125;, module: &#123; rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;]&#125;, &#123;test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;]&#125;, &#123;test: /\.pug$/, use: [&apos;html-loader&apos;, &apos;pug-html-loader&apos;]&#125; ] &#125;, devServer: &#123; contentBase: path.join(__dirname, &apos;dist&apos;), compress: true, port: 8080, stats: &apos;errors-only&apos;, hot: true, open: true // 启动后自动打开浏览器窗口 &#125;, plugins: [ new ExtractTextPlugin(&#123; filename: (getPath) =&gt; &#123; return getPath(&apos;css/[name].css&apos;).replace(&apos;css/js&apos;, &apos;css&apos;); &#125;, disable: true, allChunks: true &#125;), new HtmlWebpackPlugin(&#123; title: &apos;myApp&apos;, // minify: &#123; // collapseWhitespace: true //生成被压缩的html文件 // &#125;, hash: true, filename: &apos;./index.html&apos;, excludeChunks: [&apos;contact&apos;], template: &apos;./src/index.pug&apos;, // Load a custom template (ejs by default see the FAQ for details) &#125;), new HtmlWebpackPlugin(&#123; title: &apos;contact&apos;, hash: true, filename: &apos;contact.html&apos;, chunks: [&apos;contact&apos;], template: &apos;./src/contact.html&apos; &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin() ]&#125;``` # 打包图片 npm i -D file-loader12 // add{test: /.jpg$/, use: ‘file-loader’} 12在html中增加使用 12 npm i -D image-webpack-loader 12 { test: /.(png|jpe?g|svg|gif|webp)$/, use: [ ‘file-loader?name=images/[name].[ext]’, // ‘file-loader?name=[hash:6].[ext]&amp;publicPath=images/‘, ‘image-webpack-loader?{optimizationLevel: 7, interlaced: false, pngquant:{quality: “65-90”, speed: 4}, mozjpeg: {quality: 65}}’ ]}1234&gt; 具体参考：https://www.npmjs.com/package/image-webpack-loader# babel的使用 npm i -D babel babel-preset-es2015 babel-loader babel-core 12 //add{ test: /.js$/, use: ‘babel-loader’, exclude: /node_modules/},1在根目录新增.babelrc文件 { “presets”: [“es2015”]} ``` 具体参考 http://babeljs.io/docs/setup/#installation webpack 详解 http://www.viscode.cn/2017/03/30/webpack%E8%AF%A6%E8%A7%A3/#more]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angularjs问题总结]]></title>
      <url>%2F2017%2F04%2F01%2Fangularjs%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[之前在知乎上看过一个问题 如何衡量一个人的 AngularJS 水平？ https://www.zhihu.com/question/36040694 感觉自己也用了快一年了，但是很多会用答不上来，吓得我赶紧打开我的项目，发现我用angularjs啦，难道我遇见假的angularjs了。而且用完就忘了，开此贴特来记录一些问题和坑！ angular的数据采用什么机制？ 详述原理脏检测机制 angular在scope模型上设置了一个监听队列，用来监听数据变化并更新view。当绑定一个东西到view上时angular就会往$watch队列里插入一条$watch,用来检测它监听的model里面是否有变化的东西。当浏览器接收可以被angular content 处理的事件是，$digest循环就会触发，遍历所有$watch, 最后更新dom 举个例子 1&lt;button ng-click = 'val=val+1'&gt;&lt;/button&gt; click 时会产生一次更新的操作（至少触发两次$digest循环） 按下按钮 浏览器接收一个事件，进入到angular context $digest循环开始执行，查询每个$watch是否变化 由于监听$scope.val的$watch报告了变化，因此强制再执行一次$digest循环 新的$digest循环没有检测到变化 浏览器拿回控制器，更新$scope.val新值对应的dom $digest的循环上限是10次 两个平级界面a和b,如果a触发一个时间，有哪些方式能让b知道，详述原理其实就是两个评级界面模块进行通信。有两种方式 共用服务 基于事件 eventBus 事件发布和订阅的框架 共用服务在angular中，通过factory可以生成一个单例对象，在与需要通信的模块a和b中注入这个对象即可 基于事件 借助父controller.在子controller中向父controller触发$emit事件，然后在父controller中监听$on事件，再广播$broadcast给子controller,这样通过事件携带参数，实现了数据经过父controller,在同级controller之间传播 借助$rootScope。每个angular应该默认一个根作用域$rootScope,根作用域位于最顶层，从它往下挂着各种作用域。所以，如果子控制器直接使用$rootScope广播和接收事件，那么久可以实现同级之间的通信 EventBus 事件发布、订阅总线提供事件订阅，事件发布，事件解绑 将定义的事件和事件函数push到一个数组里面这个是事件订阅，当需要触发函数通过事件发布，完成后事件解绑 一个angular应用应当如何良好的分层 目录结构的划分 如果是小型的文件类型，可以按照文件类型组织 cssjs controller model services filters templates 但如果是规模较大的项目，最好按照业务模块划分 业务文件夹最好还有个公共的common文件来存放公共的东西，比如抽出的组件，图片，css 逻辑代码的划分 作为一个mvvm框架，angular应用本身应该按照模型，视图模型，视图来划分 这里的逻辑代码的拆分，尽量让controller这一层很薄。提取共用的逻辑到service中，比如后台数据的请求，数据的共享和缓存，基于事件的模块间通信，提取共同的界面操作到directive中，提取共用的格式化造作到filter中 在复杂的应用中，也可以为实体建立对应的构造函数 angular应用常用那些路由库，各自的区别angular1.x中常用ngRoute 和 ui.router,还有一种为angular2设计的new router ngRouter 是angular自带的angular模块，ui.router是第三方提供的模块 ui.router是基于state状态的，ngRouter是基于url的，ui.router模块具有强大的功能，主要体现在视图的嵌套方面 使用ui.router能够定义有明确父子关系的路由，并通过ui-view指令将子路由模板插入到父路由模板的中去，从而实现视图嵌套。而在ngRouter中不能这样定义，如果同时在父子视图中使用的会陷入死循环 如果angular的directive规划一套全组件化体系，会遇到哪些挑战？ 对外暴露的接口是否满足不断变化的需求 能否做到一套组件化的细节例如disabled 默认值 css等细节的统一 能否做到统一的版本控制，当升级组件版本时，基础逻辑不会影响，做到兼容 及时fix bug 分属不同团队进行开发的angular应用，如果要做整合，会遇到哪些问题，如何解决可能会遇到模块之间的冲突，一个在moduleA中，一个在moduleB中，导致两个module在会发生覆盖 最好在开发的时候就统一空间命名，避免冲突 angular缺点有哪些？ 约束性强学习成本高，对前端不友好 不利于seo, 一种解决的办法是对应正常用户的访问，响应angular,对于搜索引擎访问，响应针对seo的html页面 性能问题 作为MVVM框架，因为实现了数据的双向绑定，对应大数组，复杂对象会存在性能问题 优化angular应用性能的办法 减少监控项 对不会变化的使用单向绑定 1&#123;&#123;::yourModel&#125;&#125; 主动设置索引 指定track by， 无限滚动加载避免用ng-repeat 降低渲染数量 设置分页，每次渲染有限的数量 数据扁平化 (对于树状结构，使用扁平化解构，构建一个map和梳妆数据，对数操作) 如何看待 controller as 的语法在1.2以前，view任何的绑定都是直接绑定$scope。使用controllerAs,不需要再注入$scope, controller 变成一个简单的js对象，一个更纯粹的viewModel 从源码实现上来看，controllerAs语法只是把controller这个对象的实例用as别名在$scope上创建一个属性 避免遇到angular作用域相关的一个坑（比如ng-if，会产生以及作用域的坑，其实也是js原型链继承中值类型继承的坑）使用controllerAs的话view上所有的字符都绑定在一个引用的属性上，就可以避免这个坑 不过不引入$scope会导致$emit $broadcast $on $watch等方法无法使用，这些个跟事件相关的操作可以封装起来统一处理，或者在单个controller中引入 $scope 详述angular的依赖注入angular是通过构造函数的参数名字来推断依赖服务名称，通过toString来找到这个定义的function的字符串，然后用正则解析出其中的参数，再去依赖映射种渠道的对应的依赖，实例化之后传入 因为angular的inject是假设函数的参数名字就是依赖名字，如果去查找依赖项，代码压缩后，参数会重命名，就无法查找到依赖项 依赖注入写法数组注释法123myApp.controller('myCtrl', ['$scope', function ($scope) &#123;&#125;]) 显示$inject1myCtrl.$inject = ['$scope', '$http'] 对于依赖注入必须具备三个要素：依赖项的注册，依赖关系的声明和对象的获取，在angularjs中，module和$provide都可以提供依赖项的注入，内置的injector可以获取对象 ng-if和ng-show区别ng-if 为true 才创建dom节点，ng-show起始就创建了。用样式控制 ng-if 会隐式的产生新作用域，ng-switch，ng-include等会动态创建一块界面也是如此 ng-repeat 迭代数组，有相同值可以加$track by $index可以解决，也可以任何一个普通的值，只要能唯一标识数组中的每一项即可（建立dom和数据之间的关系） ng-click中写的表达式，能使用js原生对象上的方法，比如math.max之类的吗不可以。只要在页面中，就不能直接调用原生的js方法，因为这些并不属于在页面对应的controller的$scope,除非在$scope中添加这个函数 下面这种表达实例，实现后面的参数通过什么方法自定义12&#123;&#123;now | 'yyyy-mm-dd'&#125;&#125;` filter 有两种使用方法1&lt;p&gt;&#123;&#123;now | data: 'yyyy-mm-dd'&#125;&#125;&lt;/p&gt; 另一种在js里面用 1$filter('date')(now, 'yyyy-mm-dd') 自定义12345app.filter('过滤器名字', function() &#123; return function (需要过滤的对象,过滤参数,过滤参数) &#123; return 处理后的对象 &#125;&#125;) factory、service和provider是什么关系？factory把service的方法和数据放在一个对象里面，并返回一个对象 12345678app.factory('FooService', function()&#123; return &#123; target: 'factory', sayHello: function()&#123; return 'hello ' + this.target; &#125; &#125;&#125;); service通过构造函数方式创建service，返回一个实例化对象 1234567app.service('FooService', function()&#123; var self = this; this.target = 'service'; this.sayHello = function()&#123; return 'hello ' + self.target; &#125;&#125;); provider创建一个可通过config配置的service,$get中返回的，就是用factory创建的service 12345678910111213141516171819202122app.provider('FooService', function()&#123; this.configData = 'init data'; this.setConfigData = function(data)&#123; if(data)&#123; this.configData = data; &#125; &#125; this.$get = function()&#123; var self = this; return &#123; target: 'provider', sayHello: function()&#123; return self.configData + ' hello ' + this.target; &#125; &#125; &#125;&#125;);// 此处注入的是 FooService 的 providerapp.config(function(FooServiceProvider)&#123; FooServiceProvider.setConfigData('config data');&#125;); 从底层实现来看，service调用了factory,返回其实例，factory调用了provider,返回其$get中定义的内容， $factory和service功能类似，只不过factory是普通的函数，可以返回任何东西service是构造器，可以不返回provider是加强版的factory,返回一个可配置的factory $rootscope和$scope的区别$rootScope页面所有的$scope的父亲 angular 解析ng-app然后在内存中创建$rootScopeangular会继续解析找到双括号表达式表达式，并解析变量 接着会解析带有ng-controller的div然后指向某个controller函数，这个时候在这个controller函数变成一个$scope对象的实例 表达式是如何工作的每出现一个双括号表达式就会设置一个$watch而$interpolation会返回一个带有上下文参数的函数，最后改函数执行，算是表达式$parse作用域上 angular的digest周期angular总会对比scope module的值，一般digest周期都是自动触发的，也可以使用$apply进行手动触发 取消 $timeout,停止$watch取消1$timeout.cancel(customTime) 停止 12345678var deregisterWatchFn = $rootScope.$watch('someGloballyAvailableProperty', function (newVal) &#123; if (newVal) &#123; // we invoke that deregistration function, to disable the watch deregisterWatchFn(); &#125;&#125;); 要取消watch的话，一开始将$watch的返回值保存就好啦，要取消watch的时候，在调用。 angular directive中restrict中分别怎么设置A 属性匹配E 标签匹配C class匹配M 注释匹配 在scope中 @ 设置一个字符串= 双向绑定&amp; 用于执行父级scope上的一些表达式 $apply 和 $digest的区别$apply 可以接收一个参数作为function，这个参数会被包装在try..catch中，一旦异常就会被$exceptionHandler service 处理 $apply会使ng进入$digest cycle,并从$rootScope开始遍历检查数据变更 $digest仅会检查scope和它的子scope 写controller逻辑 需要注意简化代码 尽量减少dom节点操作，dom最好出现在指令中，angular提倡驱动开发，service或者controller中出现dom操作意味这，测试驱动无法通过，angular专注上相数据绑定，无需关系一对dom操作 angular是mvc还是mvvm首先说明一下mvc 和 mvvm理解 为什么需要mvc,随着代码规模化，必须切分职责，方便后期的维护，修改一块功能，不能影响其他功能，也方便复用，mvc只是一种手段，终极目标的模块化和复用 mvvm的优点 低耦合 可复用 独立开发 可测试 angularjs的mvvm 模式分为四个部分 view 专注界面的显示和渲染，在angular中则是包含一堆声明式的directive视图模板 viewModel 是view和model的粘合体，负责view和model的交互和协作，负责给view提供显示的数据，以及view中事件的操作 model 它是应用程序的业务逻辑相关的数据的封装载体，是业务领域的对象，model不会关心如何显示或操作，大部分model来自服务端返回数据或者全局配置angualr的service则是封装和处理相关业务逻辑的场所 controller 它负责初始化viewModel，将组合一个或者多个service来获取业务领域model放在viewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态 angularjs 核心 mvc 模块化 双向绑定 语义化标签 注入依赖 directive中compile和link的区别使用compile函数可以改变原始的dom,在ng创建原始dom实例以及创建scope之前 可以应用于当需要生成多个element实例，compile函数阶段改变原始的dom生成多个原始dom节点,然后每个又生成element实例.因为compile只会运行一次,所以当你需要生成多个element实例的时候是可以提高性能的. pre-link 可以运行一些业务代码在ng执行完compile函数之后，但是在它所有子指令的post-link函数将要执行之前 post-link 来执行业务逻辑，这个阶段，它已经知道所有的子指令已经编译完成并且pre-link以及post-link函数已经执行完成 当同时设置compile和link函数，compile所返回的函数当做link函数，而link选择本书则会被忽略，如果注释掉compile，link就起作用了 默认的angular路由中，#号怎么去掉这个原因是因为angular框架提供一种html5模式的路由可以设置$locationProvider1$locationProvider.html5Mode(true) 缺点是无法刷新，404需要配置服务器来修复]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angularjs组件化开发]]></title>
      <url>%2F2017%2F03%2F30%2Fangularjs%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[正在码字中。。。 特点： MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等 模块化来分隔组织打包软件，每个模块完成一个特定的子功能，所有的模块按某种特定的方法组装起来。成为一个整体，完成整个系统，完成整个系统所要求的功能 模块化的目的就是为了降低程序复杂度，使程序设计、调试和维护等操作简单化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[软件测试基础教程]]></title>
      <url>%2F2017%2F03%2F28%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[和测试沟通，了解测试的黑白测试，知己知彼，少出bug 第五章 动态分析-测试设计技术软件测试被看成是在计算机上执行测试对象的过程。这个过程被称为动态分析，这里的测试对象程序必须是可以执行的，程序执行之前需要提供输入数据。在低级别的测试阶段，测试对象往往无法单独运行，为了能运行测试对象，必须将测试对象继承到测试台。 测试对象通常需要通过事先定义的接口来调用程序的不同部分，当程序的某些部分还没有完成，也就是还不能够调用程序的不同部分。可以用桩来模拟。 桩模拟程序通常由测试对象调用的那部分的输入/输出行为。 测试台必须能够为测试对象提供输入数据，有时还需要模拟程序中调用测试对象的部分，这就是驱动器的工作。 驱动器和桩组合构成了测试台，测试台和测试对象一起形成了一个可执行的程序。 测试人员要创建测试台，扩展或修改标准的测试台，为了适合测试对象的接口调整测试台。这个过程可以使用测试台生成器完成。 在执行是，测试必须以尽可能少的成本尽量多地发现失效，验证尽量多的需求。采用系统化的测试方法，理想的当然是对测试对象工作的所有可能情况都进行测试。 测试执行的主要步骤 确定测试条件和前置条件，以及测试需要达到的目标 指定单个测试用例 确定如何执行 在设计测试用例是，必须确定如何将每个需求和测试用例之间想关联，从而可以确定测试对需求的覆盖率 执行单个测试用例没有意义，需要按照一定的方式进行组合，从而按照一定的顺序执行，这样的测试记录应该记录在测试规程规格说明，同时应该包含测试优先级，以及测试与回归测试用例之间的技术上和逻辑上的依赖关系 为了使测试用例按顺序执行，需要使用测试脚本，测试脚本包含是测试自动按顺序执行的指令 JUnit 对象测试有几种不同的方法黑盒测试和白盒测试 黑盒测试/功能测试/行为测试 测试对象呗看成一个黑色的盒子，测试用例从测试对象的规格说明中获取，测试用例的设计基于测试对象的规格说明或者需求文档，值观察程序的输入输出行为 白盒测试/结构测试 需要熟悉代码进行测试设计，实行测试用例的时候，需要分析测试对象内部的工作过程以及测试输出，白盒测试技术可以应用在低级别的测试中，如组件测试和集成测试 黑盒测试技术测试人员不用考虑内部结构和具体设计 等价类划分每个输入数据元素的各种可能的输入值的域被划分为等价类。等价类是测试人员认为测试对象将以相同的方式来处理的一组数据值，对等价类的一个代表性数据进行测试就够了，而对等价类中的任何其他输入值进行测试，对象都不会有不同的反应和行为。在测试过程中不仅要对有效输入的等价类进行测试，而且还要对无效输入值得等价类进行测试。 最好的测试值是验证等价类边界的那些值 由所有代表值组合而成的测试用例按使用频率进行排序，并按照这个序列设置优先级 优先级考虑包含边界值或者边界值组合的测试用例 将一个等价类的每个代表值和其他等价类的 保证满足最小原则，一个等价类的每个代表值至少在一个测试用例中出现 无效等价类的代表值不与其他无效等价类的代表值进行组合 独立测试无效值 边界值分析边界值分析是对等价类划分导出的测试用例的一个非常合理的补充。程序中错误经常出现在等价类的边界值上，出现这种现象的原因是没有明确定义边界值 在每个边界值上，需要测试一个边界值和两个最近值，测试的边界值一个在等价类内部，另一个在等价类外部 状态转换测试很多情况下，测试对象的输出和行为方式不仅受当前输入数据的影响，同时还与测试对象之前的执行情况，或之前的状况或者以前输入的数据有关。为了说明测试对象和历史数据之间的关系，引入了状态图。 因果图技术和决策表技术白盒测试技术基于代码的测试，基本思想是吧测试对象的每个部分代码至少执行一次，分析程序逻辑，然后执行用例 语句覆盖确定执行了那些语句，当达到实现定义的测试覆盖率后，就可以认为测试已经足够并且可以终止测试 分支覆盖更加有效的覆盖准则是控制流图的分支覆盖控制流图中的边是分支覆盖关注的交单，它不考虑每条语句的执行情况，而是考虑判定的执行情况，判定的解构决定接下来执行那条语句]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react 慕课网入门笔记]]></title>
      <url>%2F2017%2F03%2F15%2Freact%E5%85%A5%E9%97%A8%E6%85%95%E8%AF%BE%E7%BD%91%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[学习慕课网的react 入门教程 视频地址 http://www.imooc.com/learn/504 API http://reactjs.cn/react/docs/getting-started-zh-CN.html React 介绍 react 不是完整的mvc框架，mvvm框架 用组件的方式，通过组合来实现大的模块 应用场景 复杂场景的高性能 组件高度可重用 JSX = JS + XML 语法糖，计算机语言中没有添加的某种语法，对功能没有影响，增加可阅读性，减少出错。例如 JSX 最终都会编译成JS react 里面的 不能看成 dom ,而是react component的实例 React 的 style demo http://jsfiddle.net/reactjs/69z2wepo/ React-components-lifecycleMounted -&gt; Update -&gt; Unmounted Mounted React Components被render解析生成对应的dom节点并被插入浏览器的DOM解构的一个过程,当在浏览器从无到有的渲染的一个过程，就是Mounted结束，我们就说这个component组件已经被Mounted Update 一个mounted的react Components 被重新render的过程,而这个重新被渲染的过程并不是说dom解构会发生改变，react 会把这个component的当前state 和最近一次state进行对比，只有发现确实发生的改变并且影响的当前的DOM结构，react 才会改变对应的dom解构 Unmounted 一个Mounted的React Components 对应的DOM节点被从DOM解构中移除的一个过程 hook() 函数每一个状态react都封装了对应的hook函数，设计思想是will和did, 将要做什么了和已经做了什么。 Mounted getDefaultProps() -&gt; getInitialState() -&gt; componentWillMount() -&gt; render -&gt; componentDidMount() componentWillMount() 将要Mounted调用 componentDIdMount() 已经Mounted调用 getInitialState() 初始化react state的 props和state都可以设置css样式state值是可变的，props是通过组件调用方，通过组件决定，一旦定义不改变 this 指调用函数的对象 当前this compoentent 的实例 如果在setTimeout里面this指代globl对象 如果在构造函数中，this就指这个新生成的对象 通过调用apply call bind 调用后的this对象 demo http://codepen.io/mayufo/pen/EWQmKN state 值每次变化，会进入updating 状态，使其进入一个render的过程 updating componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate - componentWillReceiveProps() Mounted Component将要接收新的props时，这个函数会被调用，其函数参数就是新的props对象，可以通过参数和this.props进行比较，来执行一些例如修改state的操作 - shouldComponentUpdate 当接收到新的props和state之后，判断是否有必要去更新dom结构，有两个参数，一个是新的props对象，另一个是新的state对象，可以分别对比，来决定是否更新dom,返回true是更新dom节点，返回false是不更新dom节点。 Unmounting componentWillUnmount() 可以释放内存资源，图片资源 react component state的更新，会触发页面更新，而传统的页面更新时通过修改页面dom实现 传统的事件处理通过 event listener， demo http://codepen.io/mayufo/pen/GWQvxM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[犀牛书第三章]]></title>
      <url>%2F2017%2F03%2F15%2F%E7%8A%80%E7%89%9B%E4%B9%A6%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[重读犀牛书 第三章 ##chapter 3 类型、值和变量 能表示或操作的值的类型叫做操作类型 变量是一个值的符号名称，通过名称来获得对值得引用。 javascript的数据类型分数据类型为原始数据类型和对象数据类型。 原始数据类型包括数字、字符串、布尔值、null和undefined。对象数据类型除了上面的类型都是对象，对象是property的集合。以下属于对象数组是特殊的对象，带编号有序列的集合。函数是特殊的对象，具有与它相关联的可执行代码的对象，通过调用函数来运行可执行代码，并返回结果。构造函数使用 new运算符来初始化函数类每个构造函数定义了一类（class）对象—由初始化的对象组成的集合。类可以看做是对象类型的子类型。日期正则错误 javascript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收。按需创建，不用担心销毁和回收。 javascript面向对象的语言，不用全局定义函数去操作不同类型的值，数据类型本身可以定义方法来使用。 javacript 还可以分为可变类型和不可变类型。对象和数组可以修改为可变类型。数字、布尔值、字符串、null和undefined 不可变类型。 javascript 中变量是无类型的，不在任何函数内声明的变量叫做全局变量 数字（p35）javascript 不区分整数值和浮点值。均用浮点表示。（IEEE 754：一种二进制表示法，可以精确的表示分数）一个数字出现在javascript程序中，叫做数字直接量。任何数字直接量前添加负号，得到负值。负号是一元求反运算符，不是直接量语法。 整型直接量javascript支持十进制、十六进制。不直接支持八进制，但某些实现支持八进制，八进制的某些数字已0开始。严格模式下不支持。 浮点型直接量浮点型由整数、小数、小数部分组成。还可以使用指数计数法使用浮点型直接量。 javascript中的算术运算符 + - * / % Math对象的属性定义 函数 说明 Math.pow (2, 53) 2的53次幂 Math.round(.6) 四舍五入 Math.ceil(.6) 向上求整 Math.floor(.6) 向下求整 Math.abs(-5) 求绝对值 Math.max(x, y, z) 求最大值 Math.min(x, y, z) 求最小值 Math.random() 生成一个大于0 小于1.0的随机数 Math.PI 圆周率 打乱arr数组的顺序1234567891011121314151617181920212223var arr = [1, 2, 3, 4, 5];arr.sort(function (a, b) &#123; return 0.5 - Math.random();&#125;)``` javascript的算术运算符在溢出、下溢、被0整除不会报错。- 当数字溢出的时候，结果作为无穷大。- 当出现下溢的时候，结果返回0- 被0整除，返回无穷大或者负无穷大- 0除0， 无穷大除无穷大，无法转换的数字都用NAN表示Infinity(无穷大值)、NaN(非数字)。NaN和任何都不相等，包括本身。**isNaN()** 如果参数是NaN或者是一个非数字值，返回true**isFinite()** 参数不是NaN、Infinity、-Infinity，返回true## 二进制浮点数和四舍五入 javascript通过浮点数的形式只能表示其中有限的个数, 采用IEEE-754浮点数表示法，是一种二进制表示法，可以精确表示分数，不能正确表示十进制分数。因此带来误差，要使用大整数来解决。## 日期和时间 var then = new Date(2011,0,1) //Sat Jan 01 2011 00:00:00 GMT+0800 (中国标准时间)var later = new Date(2011,0,1,17,10,30) //Sat Jan 01 2011 17:10:30 GMT+0800 (中国标准时间)var now = new Date() //当前日期 //Tue Mar 22 2016 16:18:30 GMT+0800 (中国标准时间)var elapsed = now - then; //时间间隔是毫秒 164823510655later.getFullYear(); //年 2011later.getMonth(); //月 0later.getDate(); //天 1later.getDay() // 星期几 6later.getHours() // 时间 17later.getUTChours() // 时区时间 91234567891011121314# 文本**字符串**是一组有16位组成的不可变的有序数列，每个字符通常来自于Unicode字符集。 Javascript通过字符串类型便是文本。**空字符串**长度为0，Javacript中没有表示单个字符的‘字符型’一个长度为2的字符串可能表示一个Unicode字符。## 字符串直接量字符串必须写在一行中，可以拆分数行每行以(\)结束。如果希望另起一行可以用\n。单引号和撇号同用时 ，撇号可以用 \&apos; 可以作为区分。## 转义字符```js&apos;You\&apos; re right, it can\&apos;t be a quote &apos; \n换行符\&#39;撇号（单引号） 字符串的使用+运用于数字，表示两数相加。用于字符串，可以链接字符串。 注意: 字符串调用的方法不会改变字符串本身，都是返回一个新的。 模式匹配正则表达式 和 Date 都是一种具有实用API的特殊对象 布尔值任意的js值可以转为布尔值。undefined null 0 -0 NaN &quot;&quot; 都是false其他都是true 布尔值包含toString()方法 null和defined 值 typeof 说明 null object 表示数字、字符串、对象无值 undefined undefined 未定义的空值，元素不存在 ==认为两者相等===不等null 和 undefined 不包含任何属性和方法赋值给变量首选null 全局对象全局对象是全局定义的符号，js可以直接使用 比如 Math JSON 在代码的最顶级——不在任何js代码内可以使用this来引用全局对象 window对象充当全局对象如果代码声明一个全局变量，则这个全局变量就是全局对象的一个属性 包装对象对象是一种复合值，通过.符号引用属性值，当属性值是一个函数的时候，称其为方法。 12var s = 'hello';var world = s.substring(s.indexOf('')+1, s.length); 只要引用了字符串s的属性，js将字符串通过 new String(s)方式转换成对象，这个对象继承了字符串的方法。一旦属性引用结束，这个新建对象就会销毁。 123var s = &quot;test&quot;;s.len = 4; //对象包装var t = s.len //undefine 字符串、数字和布尔值读取属性值的时候，如果试图给其赋值，则会忽略操作，而临时创建的对象叫做包装对象原始值和包装对象的typeof是不同的 12var s = &quot;test&quot;; //stringvar S = new String(s); //Object 他们类型不一样 不可变的原始值和可变的引用对象（p47） 原始值不可更改，比较的是值。比如字符串必须长度字符都相等才是相等。对象是可变的，它们的值可以修改。两个对象包含同样的属性及相同的值，它们也不等。各个索引值相等也不相等，对象称为引用类型。对象的比较均是引用比较，当且仅当他们引用同一个基对象，才相等。 12345var a = [];var b = a;b[0] = 1;console.log(a[0]); // 1a === b // true 复制一个数组对象12345var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var b = [];for(var i = 0; i &lt; a.length; i++)&#123; b[i] = a[i]&#125; 比较两个数组对象 123456789function equal (a,b)&#123; if( a.length != b.length) return false; for( var i = 0; i &lt; a.length; i++)&#123; if(a[i]!=b[i])&#123; return false &#125; &#125; return true;&#125; 类型转换 值 转换为字符串 数字 布尔 对象 undefined “undefined” NaN false throws TypeError null “null” NaN 0 false throws TypeError true “true” 1 new Boolean(true) false “false” 0 false new Boolean(false) “” (空字符串) 0 false new String(“”) “1.2”（非空，数字） 1.2 true new String(“1.2”) “one”（非空，非数字） NaN true new String(“one”) 0 “0” false new Number(0) -0 “0” false new Number(0) NaN “NaN” false new Number(NaN) Infinity “Infinity” true new Number(Infinity) Infinity “-Infinity” true new Number(-Infinity) 1(无穷大，非0) “1” true new Number(1) {} (任意对象) “1” true “” 0 true ‘[ ‘ 9 ‘]’ ( 1个数字元素 ) “9” 9 true ‘[‘ a ‘]’( 其他数组 ) 使用join()方法 NaN true functtion (){} (任意函数) NaN true 转换和相等性 undefined 可以转换为布尔值，但是不表明 undefined == false显示类型转换 Boolean()、Number()、String() toString() Object()隐式转换 + !123x + &quot; &quot; //等价与String()+x //等价Number.!!x //等价于Boolean(x) toString()可以接受转换基数12var n =17;n.toString(2); //转化为10001 Number 定义了三种数字转换字符串的场景 n.toFixed(m); 根据m的值确定小数点后数字个数。12var n = 123456.789n.toFixed(2) // 123456.78 n.toExponential (m);用指数计数法，其中小数点前只有一位，小数点后有m-1位。12var n = 123456.789n.toExponential (2) //1.2e+5 n.toPrecision(m) 有效的数字位数将数字转换为字符串。1n.toPrecision(7) //123456.8 Number()转换传入一个字符串，会试图转换为一个整数或者浮点，这个方法只能基于十进制书。 parseInt() 只能解析整数，parseFloat() 可以解析整数和浮点数。如果字符串前是0x或者0X，则parseInt()将解释为十六进制数。如果是非法字符，返回NaN。parseFloat() 可以跳过前空格并可以解析’.1’，而parseInt不可以解析’.1’。第二个可选参数是转换的基数。12parseInt(&apos;11&apos;,2); // 3parseInt(&apos; ff &apos;, 16); //255 对象转换为原始值(p52) #####toString() 1234[1,2,3].toString(); //1,2,3(function(x)&#123; f(x)&#125;).toString() //function (x)&#123; f(x)&#125;/\d+/g.toString() ///\d+/gnew Date(2010,0,1).toString() //Fri Jan 01 2010 00:00:00 GMT+0800 (中国标准时间) #####valueOf()返回对象本身，而不是返回一个原始值。 1234[1,2,3].valueOf(); //[ 1, 2, 3 ](function(x)&#123; f(x)&#125;).valueOf() //[Function]/\d+/g.valueOf() ///\d+/gnew Date(2010,0,1).valueOf() //1262275200000 方法 对象 toString原始值结果 valueOf原始值结果 toString() 数组 字符串 数组 toString() 函数 函数的实现定义的表示方法 [Function] toString() 日期 可读的日期和时间字符串 以毫秒来表示 toString() 正则 表示正则的表达式直接量 表示正则的表达式直接量 对象到字符串转换先用toString返回字符串，如果不成功再用valueOf()返回字符串,否则抛出异常。对象到数字转换先用到valueOf返回数字，如果不成功再用toString()返回数字,否则抛出异常。 数组继承了valueOf方法，这也就是为什么空数组和单个的数组转换原始值会一个0或者数字。“+”、“==”都是将对象转换为原始值。对象到原始值的转换基本都是对象到数字的转换。而日期对象通过valueOf或toString()可以直接用。 12345var now = new Date()typeof (now +1 ) //stringtypeof (now -1) //numbernow == now.toString() //隐式和显式的字符串转换now &gt; (now -1) // &gt; 将日期转为数字 声明变量var 声明 初始undefine 变量作用域函数体内局部变量的优先级高于全局变量，声明局部变量时候一定写var 否则赋值就是给全局变量js使用函数作用域，变量在声明函数体以及这个函数体的任意嵌套都是有定义的。 1234567891011121314function test(o)&#123; var i = 0; if(typeof o == &quot;object&quot;)&#123; var j = 0; for(var k = 0; k &lt; 10 ; k++)&#123; console.log(k); &#125; console.log(k); &#125; console.log(&apos;j =&apos; + j) // undefine&#125; test(5); JS 可以声明提前。在函数体内局部变量遮盖了同名全局变量。123456var name=&quot;global&quot;; if(true)&#123; var name=&quot;local&quot;; console.log(name) //local&#125; console.log(name); // local 当声明了一个js全局变量时，实际是定义了全局对象的一个属性。如果没有通过var 声明变量，那么他们都可以通过delete删除。12345678910function t(flag)&#123; if(flag)&#123; s=&quot;ifscope&quot;; for(var i=0;i&lt;2;i++) ; &#125; console.log(i); &#125; t(true); console.log(s); // ifsope s是全局变量 js关键子来引用全局对象，却没有办法引用局部变量。 js最顶层代码中，作用域由一个全局对象组成。 不嵌套的函数体，有两个对象，一是函数参数和局部变量的对象，二是全局对象。 嵌套函数至少在三个以上。 当调用一个函数的时候，创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的的那个作用域链上，同时创建一个新的更长的表示函数调用作用的“链”。 参考文件https://segmentfault.com/a/1190000002692982https://segmentfault.com/a/1190000003935661http://www.2cto.com/kf/201405/298344.htmlhttp://web.jobbole.com/84041/http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dom详解]]></title>
      <url>%2F2017%2F03%2F13%2Fdom%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[用mvc框架多了，已经忘了dom 看dom详解，做的一些笔记。方便以后巩固加强，方便自己查询。 初始DOMjs由三部分组成ECMAscript 是js的核心标准，也是一个解析器DOM 是document提供的一些方法或熟悉用来操作页面BOM是window提供的一些方法或者属性用来操作浏览器 （拉倒底部数据加载） DOM (document object model) 文本对象模型 就是document提供一些api赋予开发者操作页面的能力 DOM结构是树形，顶端为DOM -&gt; 根元素 -&gt; …一般分为三大关系 父级关系 只有一层上下级关系（从当前往上走） 子级关系 只有一层以下一层的关系 兄弟关系 同一个父级 （同一级） 按照层级划分 父子节点： 上下两层节点之间的关系 祖先节点： 当前节点上面的所有节点 子孙节点： 当前节点下面的所有节点的统称 节点类型按照节点的类型划分 查看某个节点类型 nodeType 返回一个数字 表示节点的类型 整个页面都是节点都可以看做节点 节点分类 元素节点 nodeType: 1 element 就是一个标签 document nodeType: 9 元素中的文字(包括空格回车换行) nodeType: 3 注释节点 nodeType: 8 attributes 代表元素的属性 是一个集合 nodeType代表数字2 找到属性查看值nodeValue, nodeName查看节点的属性名 如果是&lt;p&gt; 输出P 如果是&lt;div&gt; 输出DIV 如果是文字输出 #text 子节点childNodes 某个节点下的所有子节点，是一个类数组下标为0 的时候可以打出标签的内容 1&lt;div id='div'&gt;12345&lt;/div&gt; 1234var odiv = document.getElementById('div');console.log(odiv.childNodes) // [text] 类数组console.log(odiv.childNodes[0]) // 12345console.log(odiv.childNodes[0].nodeType) demo https://jsfiddle.net/mayufo/6p26L8wd/ 12&lt;div id='div'&gt;&lt;!--注释--&gt;2222&lt;/div&gt; 两个子节点之所以没有空格 因为空格回车代表节点3类型 12345var odiv = document.getElementById('div');console.log(odiv.childNodes[0].nodeType); // 8console.log(odiv.childNodes[1].nodeType); // 3console.log(odiv.childNodes.length); // 2 demo https://jsfiddle.net/mayufo/qk3znLft/ 注释节点如果查看注释的值? div.childNode[0].nodeValue demo 当点击页面的时候 li 改变宽度 123456li &#123; transition: 1s; width: 20px; height: 20px; background: red;&#125; 12345678&lt;ul id="ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; childNodes查找到除元素外还能查找到空格回车元素123456789var ul = document.getElementById('ul');var lis = ul.childNodes; // 11 个 包括空格和换行 &lt;li&gt;标签前后的document.onclick = function () &#123; for (var i = 0; i &lt; lis.length; i++ )&#123; if(lis[i].nodeType === 1 ) &#123; lis[i].style.width = '150px'; &#125; &#125;&#125; children: 不是标准的属性，但是所有浏览器都支持，找到摸个元素下所有元素子节点1234567var ul = document.getElementById('ul');var lis = ul.children; // 5 document.onclick = function () &#123; for (var i = 0; i &lt; lis.length; i++ )&#123; lis[i].style.width = '150px'; &#125;&#125; demo https://jsfiddle.net/mayufo/0h1yfdox/ 父节点parentNode查找某个元素的父节点 12345678&lt;ul id="ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 12345678 var ul = document.getElementById('ul'); var alis = ul.children; console.log(alis[0].innerHTML); // 1console.log(alis[0].parentNode); // &lt;ul id="ul"&gt;..&lt;/ul&gt;console.log(alis[0].parentNode. parentNode); // &lt;body&gt;console.log(alis[0].parentNode. parentNode. parentNode); // 页面中最大的父元素是document 再大就是null demo https://jsfiddle.net/mayufo/27q1dacp/ parentNode 例子 12345&lt;ul&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;22&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;22&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 123456var a = document.getElementsByTagName('a');for (var i = 0; i &lt; a.length; i++) &#123; a[i].onclick = function () &#123; this.parentNode.style.display = 'none'; &#125;&#125; demo https://jsfiddle.net/mayufo/5r41hv2e/ 兄弟节点nextElementSibling 找到某个元素的下个兄弟节点 nextElementSibling举例 12345&lt;ul id='ul'&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;22&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;33&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 12345var ul = document.getElementById('ul');var alis = ul.children;console.log(alis[0].nextElementSibling); // &lt;li&gt;22&lt;/li&gt;console.log(alis[0].nextElementSibling. nextElementSibling); // &lt;li&gt;33&lt;/li&gt; 超出为null previousElementSibling 找到某个元素的上个兄弟节点 previousElementSibling 举例同 nextElementSibling firstElementChild找到第一个子节点 lastElementChild 找到最后一个子节点 1234var ul = document.getElementById('ul');ul.firstElementChild; // &lt;li&gt;111&lt;/li&gt;ul.lastElementChild; // &lt;li&gt;333&lt;/li&gt; offsetLeft、offsetParentoffsetParent 最近的有定位属性的祖先节点, 如果父节点都没有定位，默认定位是body，否则是定位该元素父级上设置position: relative的元素。 12345&lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12var div3 = document.getElementById('div3'); console.log(div3.offsetParent); 123456789101112131415div &#123; padding: 100px;&#125;#div1 &#123; background: red; position: relative;&#125;#div2 &#123; background: blue;&#125;#div3 &#123; background: green;&#125; demo https://jsfiddle.net/mayufo/pnkcogjy/ offsetLeft、offsetTopoffsetLeft 外边框到有定位父级的内边框的距离, 如果没有父级position: relative的定位，子级也没有position: absolute,定位默认到body。和offsetParent有关, 得到的数字没有单位。 offsetTop 上边框到有定位父级的上呗边框的距离 这里注意没有offsetRight和offsetBottom 使用场景：方便获取元素的位置 getComputedStyle(div3).left 也可以得到，有单位。 例子 当点击按钮，将div3移动到左顶边 12345678&lt;input type="button" id="btn" value="btn"&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132*&#123; margin: 0; padding: 0;&#125;#div1&#123; background: red; width:100px; height:100px; margin-left: 50px; position: relative; border: 10px solid #000;&#125;#div2&#123; background: blue; position: relative; width:60px; height:60px; top:20px; left:30px; border: 10px solid #000;&#125;#div3&#123; width:30px; height:30px; background: yellow; position: absolute; top:20px; border: 1px solid #000; left:0; transition:1s left;&#125; 1234567891011121314151617var div3 = document.getElementById('div3');var btn = document.getElementById('btn');var div3Border = parseInt(getComputedStyle(div3).borderLeftWidth); // 减去自身的边框btn.onclick = function () &#123; var left = 0; var elem = div3; while(elem) &#123; left += elem.offsetLeft + parseInt(getComputedStyle(elem).borderLeftWidth); elem = elem.offsetParent; &#125; left -= div3Border; div3.style.left = - left + 'px';&#125; demo https://jsfiddle.net/mayufo/q7d1bozj/ 计算绝对位置getBoundingClientRect()getBoundingClientRect()获取某个元素的信息，left、top、bottom、right、width、height,返回值是一个对象。 注意： 获取的值会根据滚动条变化 123&lt;input type="button" id="btn" value="btn"&gt;&lt;div id="div1"&gt;&lt;/div&gt; 123456var div = document.getElementById('div1');var btn = document.getElementById('btn');btn.onclick = function () &#123; console.log(div.getBoundingClientRect()) // bottom:130,height:100,left:58, right:158, top:30, width:10&#125; demo https://jsfiddle.net/mayufo/cL50o17d/ 元素属性操作getAttribute获取元素属性,操作某个元素的行间属性.不是行间无法获取到。 1&lt;div id="div1" index="2"&gt;&lt;/div&gt; 12345678910111213141516171819var div = document.getElementById('div1');// 想获取id的值console.log(div['id']); // div1console.log(div.getAttribute('id'));// 如果是div.index = 2 直接设置，getAttribute无法获取到index的值div.index = 2;console.log(div['index']); // 主要取对象属性的值，有时候不能取到行间属性的值console.log(div.getAttribute('index')); // 主要取对象属性的值，无法取到对象属性设置的值div.setAttribute('index', '4'); // 删除元素行间属性div.removeAttribute('index'); demo https://jsfiddle.net/mayufo/ng629u96/ setAttribute设置元素的行间属性 removeAttribute 删除元素的行间属性 上面三种方法可以获取href或src的相对路径 如果图片中存在中文的路径，打出图片地址的时候，有的浏览器中文的路径会显示乱码。所有通常情况不能直接拿此console.log(img.src)作为判断 可以通过getAttribute来得到写的路径 元素宽高的获取clientWidth 可视内容的宽度，没有单位，不计算边框border, 不会计算padding， 不计算margin clientHeight 可视内容的高度，没有单位，不计算边框border, 不会计算padding, 不计算margin 注意：如果div内容超出，只算div显示的宽高 1234#div1 &#123; height: 200px; width: 200px;&#125; 1&lt;div id="div1"&gt;&lt;/div&gt; 123var odiv = document.getElementById('div1');console.log(odiv.clientWidth);console.log(odiv.offsetWidth); offsetWidth 获取某个元素的宽度，会计算border的, 计算padding, 不计算margin offsetHeight 获取某个元素的宽度，会计算border的, 计算padding, 不计算margin document.documentElement.clentWidth 可视区的宽度 document.documentElement.clentHeight 可视区的高度 让一个不确定宽高的元素居中显示 元素的left = （可视区 - 元素的宽）/ 2 元素的top = (可视区 - 元素的高) / 2 1&lt;div id='div1'&gt;2222&lt;/div&gt; 123456#div1 &#123; height: 100px; width: 100px; background: red; position: absolute;&#125; 123456789101112var odiv = document.getElementById('div1'); // 记得div1 position: absolutevar clientW = document.documentElement.clientWidth;var clientH = document.documentElement.clientHeight;console.log(odiv);var iW = odiv.offsetWidth;var iH = odiv.offsetHeight;odiv.style.left = (clientW - iW) / 2 + 'px';odiv.style.top = (clientH - iH) / 2 + 'px'; demo https://jsfiddle.net/mayufo/eLLuspjp/ 创建元素 点击添加元素 可以通过字符串的拼接 通过createElement(‘标签的名字’), 如果创建没有的标签，也会出现自定义的标签 插入元素 parentNode.appendChild(childNode) 向父级的尾部添加一个元素 插入元素 插入元素 parentNode.inserBefore (新添加的元素， 添加的元素位置，会添加到这个元素之前) 向父级中的某个元素前插入元素 特性 如果第二个参数为假的，则将这个元素添加到父元素的第一个 删除元素 父级.removeChild（自定的子级点) 如果指定的子节点没有会报错 1234&lt;input type="button" id="btn" value="button"&gt;&lt;ul id="ul"&gt; &lt;li&gt;0&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526272829303132333435363738var btn = document.getElementById('btn');var oul = document.getElementById('ul');var html = '';var num = 0;btn.onclick = function() &#123; num++; html += '&lt;li&gt;' + num + '&lt;/li&gt;'; oul.innerHTML = html;&#125;;// appendChildbtn.onclick = function() &#123; num++; var li = document.createElement('li'); //创建li标签 li.innerHTML = num; ul.appendChild(li); console.log(li.nodeType); // 1 元素节点&#125;;// insertBefore btn.onclick = function() &#123; num++; var li = document.createElement('li'); //创建li标签 li.innerHTML = num; ul.insertBefore(li, ul.children[0]);// 将ul的第一个子节点插入元素 console.log(li.nodeType); // 1 元素节点 &#125;; // removeChild btn.onclick = function() &#123; if(ul.lastElementChild) &#123; ul.removeChild(ul.lastElementChild); &#125; &#125; demo https://jsfiddle.net/mayufo/vyzxgmnf/1/ 元素替换 当点击按钮的时候，将红色替换成蓝色 123456&lt;input type="button" id="btn" value="button"&gt;&lt;div id="box"&gt; &lt;div id="red"&gt;&lt;/div&gt; &lt;hr id="hr"&gt; &lt;div id="blue"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910var red = document.getElementById('red');var hr = document.getElementById('hr');var blue = document.getElementById('blue');var btn = document.getElementById('btn');var box = document.getElementById('box');btn.onclick = function () &#123; box.replaceChild(red, blue);&#125; demo https://jsfiddle.net/mayufo/ofp5Lv19/ 父级.replaceChild(node(要替换成什么), childNode（谁被替换）) 都是剪切的操作 克隆 将蓝色方块克隆，放到红色方块下 要复制的元素.cloneNode(false); 克隆某个元素，克隆只克隆元素本身，克隆不会克隆下面的子节点, 如果参数改为true 就可以默认赋值子节点,默认值为false.事件不会被克隆的克隆才是真正的赋值 12345678var red = document.getElementById('red');var hr = document.getElementById('hr');var blue = document.getElementById('blue');var btn = document.getElementById('btn');var box = document.getElementById('box');var elem = blue.cloneNode();box.insertBefore(elem,hr); demo https://jsfiddle.net/mayufo/cymoh67c/ 表格12345678910111213141516171819202122232425262728293031323334 &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;head1&lt;/th&gt; &lt;th&gt;head2&lt;/th&gt; &lt;th&gt;head3&lt;/th&gt; &lt;th&gt;head4&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;content1&lt;/td&gt; &lt;td&gt;content2&lt;/td&gt; &lt;td&gt;content3&lt;/td&gt; &lt;td&gt;content4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;content1&lt;/td&gt; &lt;td&gt;content2&lt;/td&gt; &lt;td&gt;content3&lt;/td&gt; &lt;td&gt;content4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;foot1&lt;/td&gt; &lt;td&gt;foot2&lt;/td&gt; &lt;td&gt;foot3&lt;/td&gt; &lt;td&gt;foot4&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; 123456789101112var table = document.getElementById('box');table.tHead.style.borderColor = 'red';table.rows[1].style.background= 'blue';console.log(table.tBodies);table.tBodies[0].style.background = 'red';table.rows[1].cells[2].style.background = 'pink'; table.tHead 选取表格的表头 table.rows 获取tr 获取表格中所有的tr, 得到一个数组，指定某个需要下标 表头和表尾也会算入tr的list中, 比tbody优先级高 table.tBodies 获取表格中所有的tbody, 得到一个数组，指定某个需要下标 table.row[n].cells[i] 获取表格中其中一个td,需要指定下标。前面也可以结合tBodies demo https://jsfiddle.net/mayufo/aum5cz9n/ 渲染一个表格 demo https://jsfiddle.net/mayufo/uLLmm7t6/ #练习 - 留言板 https://jsfiddle.net/mayufo/4u5v6tno/2/ - 上移下移 https://jsfiddle.net/mayufo/sLj50rwx/ - 排序 https://jsfiddle.net/mayufo/LvenLyy3/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[犀牛书第二章 词法结构]]></title>
      <url>%2F2017%2F03%2F13%2F%E7%8A%80%E7%89%9B%E4%B9%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[重读犀牛书 第二章 2.1 字符集 javascript 程序是Unicode字符集编写的。 javascript 区分大小写。 HTML 不区分大小写。 Unicode允许多种方法进行编码，显示结果一样，但是处理方式不一样。 2.2 注释 可以使用 // 或者 /**/注释，但是不能嵌套。(P27) 2.3 直接量 可以直接使用的数据值 2.4 标识符和保留字标识符就是用来对变量和函数进行命名，或者循环语句中位置标记JavaScript必须以字母，下划线或$开始。后接的可以字母，数字，下划线，美元符。（数字不能出现在首字母）也可以用非英文语言或数字作为标识符，比如π也不能使用保留字作为标识符。 2.5 可选分号语句用分号分开。（P30）如果独占一行可以省略分号。无法解析的两个例外 return break和continue随后的表达式之间不能换行，系统会自动添加分号。 ++ --作为表达式的后缀，应该和表达式在同一行。 否则，行尾将填补分号。 1234567var aa=3//解析为 // var a // a = 3 如果以 （ [ / + - 开始极有可能和之前语句合在一起解析。1234var y = x+ f(a+b).toString()//解析//var y = x+ f(a+b).toString(); 涉及return、break、continue。则不能换行 12345returntrue //解析 //teturn; //true 涉及到 ++ 或 – 123456x++y//解析//x;//++y;]]></content>
    </entry>

    
  
  
</search>
