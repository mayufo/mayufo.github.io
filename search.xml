<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[学习笔记lesson2]]></title>
      <url>%2F2017%2F08%2F13%2Fstud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[lesson2 上一次作业 每次作业需要做边界检测，对象和数值有没有超出范围 链表的操作 coverage 使用karma-coverage karma.config.js 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;karma start&quot;, &quot;report&quot;: &quot;find coverage -name lcov.info -print0 | xargs -0 cat | ./node_modules/coveralls/bin/coveralls.js &amp;&amp; rm -rf ./coverage&quot; &#125;, report的大概意思是查找coverage文件下lcov.info文件并输出print0不会给输出的内容增加回车而是增加nullxargs -0 将查找的文件,以null为记录的分隔符cat 展示文件写入后面的coveralls.js中rm -rf ./coverage 删除coverage singleRun: !!process.env.TRAVIS 在travis的环境下有这个变量为true,只跑一遍测试 别人作业的coverage #11 自己的作业 homework1 自己刚开始的一种coverage方案 coverage 自己的另一个方案coverage homework1-another-coverage exercise4test112345678910111213describe(&apos;this&apos;, function () &#123; it(&apos;setTimeout&apos;, function (done) &#123; var obj = &#123; say: function () &#123; setTimeout(() =&gt; &#123; // this 是什么？想想为什么？ this.should.equal(obj) done() &#125;, 0) &#125; &#125; obj.say() &#125;) setTimeout在一般函数中this指向window,而这里用到了箭头函数(lambda表达式) 因此setTimeout函数外的this和setTimeout函数内的this是一样的，指向相同。setTimeout函数外的this指向obj,因此setTimeout函数内的this也是指向obj test21234567it(&apos;global&apos;, function () &#123; function test() &#123; // this 是什么？想想为什么？ this.should.equal(global) &#125; test() &#125;) 没有指定this,指向window,因为是在node环境下，这里指向global test312345678910111213describe(&apos;bind&apos;, function () &#123; it(&apos;bind undefined&apos;, function () &#123; var obj = &#123; say: function () &#123; function _say() &#123; // this 是什么？想想为什么？ this.should.equal(global) &#125; return _say.bind(obj) &#125;() &#125; obj.say() &#125;) bind、call和apply都是改变函数this 此处的obj因为变量提升，开始为obj = undefined,因此在这个函数中bind(obj)，实际bind(undefined) 在没有指明this的情况下，this指向global test41234567891011it('bind normal', function () &#123; var obj = &#123;&#125; obj.say = function () &#123; function _say() &#123; // this 是什么？想想为什么？ this.should.equal(obj) &#125; return _say.bind(obj) &#125;() obj.say() &#125;) 开始定义了对象,为引用类型再运行，这里obj指向的就是obj,因此this也指向obj 测试框架和断言库对比 egg 测试框架Mocha功能丰富适合大量测试框架存在，可扩展，适用于大型项目高并发 AVA适合简单的程序，跑的快，如果运用在大量测试中，由于是高并发，容易堵塞 断言库assert、express和should assert可以让你的结果报表清晰 should是链式的模式，不需要函数调用 断言测试脚本的一句话类似 1expect(add(1, 1)).to.be.equal(2); 断言库在编写前端测试代码的过程中，测试框架都提供了根据功能，模块来切分测试用例的设计，由于测试代码简单，直接反应API的特点，编写测试代码很大程度取决于断言库 koa开源的node服务框架egg阿里的做的类似上面 （洋葱圈模型） xhr123456789101112131415161718192021222324252627282930313233const xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; switch (xhr.readyState) &#123; case 0: // UNSENT (未打开) debugger break case 1: // OPENED (未发送) debugger break case 2: // HEADERS_RECEIVED (已获取响应头) debugger break case 3: // LOADING (正在下载响应体) debugger break case 4: // DONE (请求完成) if (xhr.status === 200) &#123; console.log(xhr.responseType) console.log(xhr.responseText) console.log(xhr.response) &#125; break &#125;&#125;xhr.open('GET', 'http://y.stuq.com:7001/json', true)xhr.send(null) 跨域问题post 会send一些值get 会带参数 http://y.stuq.com:7001/json?name=mayufoxhr.open(‘请求方法’， ‘请求url’, ‘true表示异步’) jsonphttp://y.stuq.com:7001/json?callback=ss 相当于在window上挂一个ss的方法，专门处理返回的内容 1234567window.xxx = function (value) &#123; console.log(value)&#125;var script = document.createElement('script')script.src = 'http://x.stuq.com:7001/json?callback=xxx'document.body.appendChild(script) 利用没有跨域限制的script标签加载预设的callback将内容传递个给js 为什么要防止跨域？ 浏览器同源政策及其规避方法跨域资源共享 CORS 详解 同源是指协议、域名、端口相同 主要限制 cookies、 LocalStorage和IndexDB无法读取 (如果没有同源策略,cookie可以共享，网站之间读取登录状态，非常不安全) DOM无法获得 （如果DOM可以获取，你可以做个网站用iframe嵌套淘宝，我可以通过获取DOM来监听你的密码输入） AJAX请求不能发送 (公司内网和外网隔离，外网无法内网数据，如果可以请求AJAX请求，内网有个机密的pdf，黑客在外网加一个服务器，内网用户访问这个服务器，通过ajax把pdf下载下来,再上传到他外网的服务器，因为浏览器可以跨域访问) CROSXML2.0 以后出现的新方法 如果你没有设置值，它不会把请求的cookies，带给发送请求的网站 可以设置，这样就会带上请求的cookies 1xhr.withCredentials = true caniuse.com 可以查xmlhttp兼容性的网站 对IE8\IE9,需要使用XDomainRequest CROS 里面需要设置 Access-Control-Allow-Origin 如果我们要 http://*.qq.com 都支持跨域怎么办？ 没有办法返回，或者是或者是特定的域要根据Reference来返回Access-Control-Allow-Origin,它只能设置或者一个特殊的域名，无法实现*.qq.com 123456789101112module.exports = app =&gt; &#123; class CrosController extends app.Controller &#123; * index(req) &#123; // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS this.ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;) // * 表示所有的域名 // this.ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;http://xx.stuq.com&apos;) // 如果我们要 http://*.qq.com 都支持跨域怎么办？ 没有办法返回，或者是*或者是特定的域 this.ctx.body = &#123; msg: &apos;hello world&apos; &#125; &#125; &#125; return CrosController&#125; iframeonhashchange当hash变化 被iframe嵌套的代码 12345678910var xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var res = JSON.parse(xhr.responseText) parent.location.href = `http://y.stuq.com:7001/public/3.html#msg=$&#123;res.msg&#125;` &#125;&#125;xhr.open('GET', 'http://x.stuq.com:7001/json', true)xhr.send(null) 在视图中的 12345678var iframe = document.createElement('iframe')iframe.src = 'http://x.stuq.com:7001/public/hash.html'document.body.appendChild(iframe)window.onhashchange = function () &#123; // 小练习，做个工具方法，取出query的值 console.log(location.hash)&#125; 用正则的方法去location.hash 123456function getParmFromHash(url, parm) &#123; var re = new RegExp("#.*[?&amp;]" + parm + "=([^&amp;]+)(&amp;|$)"); var match = url.match(re); return(match ? match[1] : "");&#125; window.name被iframe嵌套的 12345678910var xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) // 响应的数据 window.name = xhr.responseText location.href = 'http://y.stuq.com:7001/public/index.html' // 将嵌套的网页设置为相同的域名，此处就变为了同源策略 &#125;&#125;xhr.open('GET', 'http://x.stuq.com:7001/json', true)xhr.send(null) 在视图中的 1234567891011var iframe = document.createElement('iframe')iframe.src = 'http://x.stuq.com:7001/public/name.html'document.body.appendChild(iframe)// 第一次打开跨域的// 回到同域的var times = 0iframe.onload = function () &#123; if (++times === 2) &#123; console.log(JSON.parse(iframe.contentWindow.name)) &#125;&#125; postMessage通过postMessage传递,数据可以相互传递被iframe嵌套的 12345678var xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; parent.postMessage(xhr.responseText, '*') // * 代表能够接受任何域或者是特定域 &#125;&#125;xhr.open('GET', 'http://x.stuq.com:7001/json', true)xhr.send(null) 在视图中的 1234567var iframe = document.createElement('iframe')iframe.src = 'http://x.stuq.com:7001/public/post.html'document.body.appendChild(iframe)window.addEventListener('message', function(e) &#123; console.log(JSON.parse(e.data))&#125;, false); requirecallback换成define,是和AMD一样的东西 123// require(['http://x.stuq.com:7001/json?callback=define'], function (value) &#123;// console.log(value)// &#125;) 跨域五种需要注意的 jsonp 只能get请求，不能post请求 cros可以post请求还可以带cookies 第三方法和第四方法用iframe，数据通信不一样 其他的跨域解决反向代理（需要后端的协助）、flash 一般常用jsonp速度比较快，但是后端不想改可以用iframe 安全性考虑 可以考虑cros postMessage 如果考虑到IE低版本，就无法使用cros Referer 就是发起请求，谁来引用的， 后台可以根据这个地址来变成对应的域 继承es5 原型继承 Animal需要继承的 123function Cat() &#123;&#125;Cat.prototype = new AnimalCat.prototype.name = 'cat' 构造函数 Animal需要继承的 1234function Cat(name) &#123; Amimal.call(this) this.name = name || 'cat'&#125; 组合继承 可以继承原型的方法，且构造函数的方法也被继承 1234567891011function Cat(name) &#123; Animal.call(this) this.name = name || 'cat'&#125;Cat.prototype = new Aniaml()// 添加方法Cat.prototype.say = function() &#123; &#125; 在调用new Aniaml的时候和Animal.call会被创建两次，费内存 优化内存 123456789101112131415function Cat () &#123; Animal.call(this) this.name = 'cat'&#125;(function() &#123; var Super = function() &#123;&#125; Super.prototype = Animal.prototype Cat.prototype = new Super() // 只继承来自Animal.prototype的方法 // 添加方法 Cat.prototype.say = function() &#123; &#125; &#125;)() 12XXX.ss() // 静态方法(new XXX()).ss() // 实例方法 new Date 与 new Date()相似，但是后者可以传值 为什么代码不分号 现在习惯是2space,无分号，因为这样在es6盛行的今天更好些 Promise以前如何解决回调地狱callhell文章提供的方法 给匿名函数提供名字，将他们分离保持一种浅代码的风格 模块化后期新的技术可以使用 promise generators Async function run-parallel or run-series 有promise的情况123456async_task1() .then(async_task2()) .then(async_task3()) .then(function () &#123; done() &#125;) 没有promise的情况1234567async_task1(function () &#123; async_task2(function () &#123; async_task3(function () &#123; &#125;) &#125;)&#125;) 熟悉promise1234567// resolve(&apos;成功&apos;)// reject(&apos;失败&apos;)(new Promise(function (resolve, reject) &#123; setTimeout(()=&gt; &#123; resolve(&apos;hello world&apos;) &#125;, 1000)&#125;)).then(successCb, errorCb) 1234567（new Promise(function (resolve, reject) &#123; setTimeout(()=&gt; &#123; resolve(&apos;hello world&apos;) &#125;, 1000)&#125;).then(function (data) &#123; console.log(data) // hello world&#125;) 123456789(new Promise(function (resolve, reject) &#123; setTimeout(()=&gt; &#123; reject(&apos;hello world&apos;) &#125;, 1000)&#125;)).then(function (data) &#123; console.log(data) // hello world&#125;, function (msg) &#123; console.log(msg) // hello world&#125;) 1234567891011121314151617181920212223function async1 () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout( function () &#123; console.log(&apos;run task 1&apos;) resolve() &#125;, 1000 ) &#125;) &#125;function async2 () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout( function () &#123; console.log(&apos;run task 2&apos;) resolve() &#125;, 1000 ) &#125;)&#125;async1() // run task 1 .then(async2) // run task 2 .then(function () &#123; console.log(&apos;done&apos;) // done &#125;) Promise的一些方法Promise.all(iterable)返回新的Promise对象，该Promise对象在iterable参数对象里所有的Promise对象都成功的时候才出发成功，一旦任何一个失败，都会立即出发该Promise对象失败，并发 Promise.race(iterable) 当参数iterable里仁轶一个子Promise被成功或者失败后，父Promise马上调用子Promise的成功或者失败 Promise.reject(reason)返回一个状态为失败的Promise对象，给定的失败信息传递给对应的处理方法 Promise.resolve(value)返回一个状态给定value决定Promise对象 Promise.prototype.catch(Rejected) 能catch错误的Promise 123456new Promise((resovle) =&gt; &#123; sdsdsdsdsd&#125;).then( () =&gt; &#123;&#125;) .catch( function (e) &#123; console.log(e) &#125;) 不会打断整个流程，而是通过catch抛出错误对于异步的操作，如果没有catch，错误只能通过window.onerror来得到 这次作业webpack的核心tapable 插件机制，以一种类似管道的方式调用插件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端学习自测]]></title>
      <url>%2F2017%2F08%2F06%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[每周学习记录 如何实现一个三栏布局，要求两边固定宽度，中间自适应123&lt;div style="float: left; width: 200px; height: 400px; background: red;" &gt;&lt;/div&gt;&lt;div style="float: left; background: pink; width: calc(100% - 200px - 200px); height: 400px" &gt;&lt;/div&gt;&lt;div style="float: right; width: 200px; height: 400px; background: green;"&gt;&lt;/div&gt; 两列布局（浮动、定位、flex）和三列布局（圣杯、双飞翼、flex） http://www.cnblogs.com/mayufo/p/7299255.html 圣杯布局 双飞翼布局 flex布局 说一下对 Javascript 变量提升的理解当遇到定义变量的时候，先读取变量，初始化undefined,再读取代码 https://zhuanlan.zhihu.com/p/28140450 下面代码会打印 什么?为什么?12345 function A() &#123; this.name = 'Daniel' &#125; A.prototype.test = function () &#123; setTimeout(function () &#123; console.log(this.name) &#125;, 1000) &#125; var a = new A(); a.test(); 这里打印的是window.name的值这里的window.name是有默认值的，如果之前设置过，就会打印之前设置的值，只要窗口不被关闭，就不会改变，可以解决iframe跨域问题 this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象，谁调用，指向谁 123456var name = '1';function getName () &#123; var name = '2'; return this.name;&#125;console.log(getName()); // 1 getName()在window中调用，因此this指向window,this.name也就是1 没有明确的当前对象this指向window,比如setTimeout,可以理解setTimeout里面的this指向window setTimeout 和 setInterval 有什么差别?setTimeout 是运行指定的毫秒数后，函数被添加到事件队列中setInterval 以指定的毫秒数为周期，将函数添加到事件队列中 如何实现类似 jQuery 的链式调 ?返回this 1234567891011class Core &#123; constructor() &#123;&#125; say(word) &#123; console.log(word) return this &#125;&#125;const core = new Corecore.say('hello').say('wore') Yslow 和 PageSpeed 你知道怎么用吗?你记得其中多少规则?性能优化，可以建议 HTTP请求头中，状态码分别是:200、301、302、304 分别代表 么意思?200 代表请求成功204 正常，返回为空3开头的 都是重定向301 永久302 暂时跳转304 有缓存，不需要从网上取4网络请求问题5服务器请求问题 PNG 和 JPG 有什么差别?透明度图片格式 | 透明度 | 动画 | 压缩方式 | 浏览器支持 | 相对原图大小 | 适应场景—-|——|—-|—-|——|—-|—-baseline-jpeg | 不支持 | 不支持 | 有损 | 所有 | 画质决定 | 所有场景progress-jpeg | 不支持 | 不支持 | 有损 | 所有 | 画质决定 | 实用所有，渐进加载gif | 支持 | 支持 | 无损 | 所有 | 由帧数和每帧图片大小决定 | 简单颜色、动画png | 支持 | 不支持 | 无损 | 所有 | 由png色值位数决定 | 需要透明时 前端图片优化机制 http://imweb.io/topic/568b20194c44bcc56092e415 事件冒泡和事件捕获有什么区别?事件冒泡是一种事件行为当触发事件后，事件会像涟漪一样，从小范围到大范围，元素被逐层触发事件捕获是当触发这个事件后，从包围这个的根元素到具体触发的元素，从远到进，元素逐层被触发 你遇到过兼容性问题吗?最令你影响深刻的兼容问题是什么?bootstrap不支持ie8以下的浏览器，无法使用rgba 小米手机 安卓安卓手机 华为手机 工程类(6懂得2) 你使用过构建工具来编译前端代码吗?你使用过 Grunt、Gulp、webpack、FIS 其中之一吗?使用过webpack CDN是什么?为什么能资源加速?; 你使用过React、Vue、Angular其中之一吗?使用过angular 1.x 目前再学vue 2 你知道前端怎么样能拿到DNS的查询时间吗?可以拿到握手时间，加载时间等等 performance.timing ; 你能拿 localStorage 来做些什么?localStorage可以用来在浏览器存储数据，记录状态各种缓存localStorage不可信，不能存重要数据，可能会损坏丢失，需要做好容错 设计一个广告系统，类似广告联盟，如何对没有登录态的用户做跟踪?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue学习]]></title>
      <url>%2F2017%2F07%2F22%2Fvue%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[vue介绍学习记录 渐进式框架Vue api https://cn.vuejs.org/v2/guide/ 构建用户界面的渐进式框架 声明式渲染-组件系统-客户端路由-大规模状态管理-构建工具 按需加载功能，不用全部加载 只关注view层 两个核心点 响应的数据绑定 数据发生改变 -&gt; 自动更新视图 利用Object.definedProperty中的setter/getter代理数据，监控对数据的操作，可以在控制台中方便打出app.__vue__.message，不兼容IE8 可组合的视图组件 ui 页面映射为组件树划分组件可维护、可重用、可测试 虚拟DOMjs运行速度很快，dom操作速度很慢 将html模板或者字符串模板编译，调用Render函数，将模板里面的函数抽离出来，形成虚拟dom树，其实就是对象嵌套对象映射到dom,生成真正的dom树 一个地方改变，只渲染改变的地方，而不用渲染全部 MVVM模式M: model 数据模型V：view 视图模型VM: view-model 视图模型 数据的绑定和事件的监听 Vue实例vue实例1new Vue(选项对象) el挂载元素选择器data 代理数据methods放置事件处理函数 vue代理data数据每个Vue实例都会代理器data对象里所有的属性，这些被代理的属性是响应的，新添加的属性不具备响应功能，改变后不会更新视图 vue实例自身属性和方法app是template的id值1app.__vue__ 声明式渲染采用简洁的模板语法来声明式的将数据渲染进DOM 1234var arr = [1,2,3,4,5];var newArr = arr.map(function(item) &#123; return item * 2;&#125;) 命令式代码每一步都要实现,考虑到 12345var arr = [1,2,3,4,5];var newArr = [];for(var i = 0,len = arr.length; i &lt; len; i++) &#123; newArr.push(arr[i]*2);&#125; 指令v-bind 动态的绑定数据，简写：v-on 绑定事件监听器，简写@v-text 更新数据，会覆盖已有的结构v-html 可以解析数据中的html结构v-show 根据值得真假，切换元素的displayv-if 根据值得真假，切换元素会被销毁重建v-else-if 多条件判断，为真则渲染v-else 条件都不符合渲染v-for 基于源数据多次渲染元素或者模板v-model 在表单控件元素上创建双向数据绑定v-pre 跳过元素和子元素的编译过程v-once 只渲染一次，随后数据更新不重新渲染v-cloak 保持在元素上直到关联实例结束编译，css中设置[v-cloak]{display: none}123&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; html模板基于DOM的模板，模板都是可解析的有效HTML 插值 文本 使用Mustache语法(双大括号) ,当改变为自动更新 html 双大括号输出是文本，不会解析html,可以用v-htmlspan里面不能包含div 1&lt;div v-html="message"&gt;&lt;/div&gt; 属性使用v-bind来绑定 1&lt;div :attr="message"&gt;&lt;/div&gt; 使用js表达式,不能写语句 1&lt;div&gt;&#123;&#123;1 + 2&#125;&#125;&lt;/div&gt; 字符串模板template选项对象的属性模板会替换挂载的元素，挂载元素的内容将被胡烈template模板根节点只能有一个,多个根节点会警告用字符串拼接的时候，可以用``实现把html片段放在script里面，用代码片段,无法做到复用 1234567new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js!' &#125;, template:'&lt;div&gt;33333333333333333&lt;/div&gt;'&#125;) http://runjs.cn/code/7tahwicq 使用template片段 12345678&lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt;&lt;script type="x-template" id="temp"&gt; &lt;div&gt;111&lt;/div&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js!' &#125;, template:'#temp'&#125;) http://runjs.cn/code/ybceq6re 模板render函数123456789101112131415new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js!' &#125;, render(createElement) &#123; return createElement( "ul", [ createElement('li', 1), createElement('li', 2), createElement('li', 3) ] )&#125;&#125;) http://runjs.cn/code/b8yxestz 最接近编译器，但是想给ul上加一些属性,一般用在组件上 createElement(标签名，[数据对象]，子元素) 数据对象属性 12345678910111213141516new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js!' &#125;, render(createElement) &#123; return createElement( "ul",&#123; class: &#123; bg: true&#125;, style:&#123;fontSize: "18px"&#125;, attrs: &#123;abc: "miaov"&#125;,domProps: &#123;innerHTML: "&lt;li&gt;may&lt;/li&gt;"&#125;&#125;, // 显示innerHTML [ createElement('li', 1), createElement('li', 2), createElement('li', 3) ] )&#125;&#125;) class： {} 绑定classstyle: {} 绑定样式attrs: {} 添加行间属性domProps:{}DOM元素属性on: {} 绑定事件 nativeOn: {} 监听原生事件directives: {} 自定义指令scopedSlots: {} slot作用域slot: {} 定义slot名称key: &quot;key&quot; 给元素添加唯一表示ref: &quot;ref&quot; 引用信息 路由不同的url对应不同的应用程序，通过管理url,实现对组件的切换 单页应用（SPA） 优点：一次性加载，适合手机端 安装模块 1npm install vue-router --save 引入模块 import VueRouter from ‘vue-router’ 作为Vue的插件 Vue.use(VueRouter) 创建路由实例对象 123new VueRouter(&#123; ...配置参数&#125;) 注入Vue选项参数 new Vue({ router}) 告诉路由渲染的位置1&lt;router-view&gt;&lt;/router-view&gt; 路由的两种模式 hash 模式# ,需要给每个页面对应的路径前加#,默认的模式 1&lt;li&gt;&lt;a href="#/home"&gt;home&lt;/a&gt;&lt;/li&gt; 希望在路由中#号消失，用history模式,在路由中配置 1234567891011121314151617let router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '/', component: Home &#125;, &#123; path: '/about', component: About &#125;, &#123; path: '/document', component: Document &#125; ]&#125;) 其他应用的路由前面不用加#号， 但是在a标签中跳转链接，会影响单页面应用1&lt;router-link to="/home"&gt;home&lt;/router-link&gt; 使用router-link组件，不用手动配置 ，推荐使用history模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack简易教程]]></title>
      <url>%2F2017%2F06%2F26%2Fwebpack%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[项目在mac上如果报错 运行 brew install libpng 参考了 https://github.com/tcoopman/image-webpack-loader/issues/51 项目地址 https://github.com/mayufo/webpack-practicewebpack https://webpack.github.io/npm http://www.npmjs.com/之前写的webpack文章 https://mayufo.github.io/2017/04/02/webpack/ chapter 1webpack hello.js hello.bundle.js npm install css-loader style-loader –save-dev css-loader 处理生成css文件style-loader 是加载 如果不想在require写 可以在命令行敲 webpack hello.js hello.bundle.js –module-bind ‘css=style-loader!css-loader’ webpack hello.js hello.bundle.js –module-bind ‘css=style-loader!css-loader’ –watch 随时监听 webpack hello.js hello.bundle.js –module-bind ‘css=style-loader!css-loader’ –progress 看到打包过程 webpack hello.js hello.bundle.js –module-bind ‘css=style-loader!css-loader’ –progress –display-modules 展示打包的模块 webpack hello.js hello.bundle.js –module-bind ‘css=style-loader!css-loader’ –progress –display-modules –display-reasons 可以看到打包这个模块的原因 chapter 2 http://webpack.github.io/docs/configuration.html 改名字 为 webpack.dev.config.js webpack –config webpack.dev.config.js entry平行的不互相依赖 1entyl: [&apos;./entry1&apos;, &apos;entry2&apos;] output多页面应用 12345678910&#123; entry: &#123; app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, path: __dirname + &apos;/build&apos; &#125;&#125; [name] 打包的名字 [hash] 打包的版本号 [chunkhash] 每个文件的版本，相当于md5值 打包的情况 12345output: &#123; path: './dist', filename: 'js/[name]-[chunkhash].js', publicPath: 'http://cdn.com' //上线地址 &#125; chapter 3 生成indexnpm install html-webpack-plugin –save-dev http://webpack.github.io/docs/using-plugins.html 可以遍历出里面的参数 12345678&lt;%= htmlWebpackPlugin.options.date %&gt;&lt;% for (var key in htmlWebpackPlugin.files) &#123;%&gt;&lt;%= key %&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.files[key])%&gt;&lt;% &#125; %&gt;&lt;% for (var key in htmlWebpackPlugin.options) &#123;%&gt;&lt;%= key %&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.options[key])%&gt;&lt;% &#125; %&gt; 参考插件的api https://www.npmjs.com/package/html-webpack-plugin 打出的内容1234567891011121314151617181920212223242526272829303132333435363738394041Thu Jun 22 2017 11:52:57 GMT+0800 (中国标准时间)publicPath : &quot;&quot;chunks : &#123;&quot;main&quot;:&#123;&quot;size&quot;:24,&quot;entry&quot;:&quot;js/main-6409dbec7a578634313c.js&quot;,&quot;hash&quot;:&quot;6409dbec7a578634313c&quot;,&quot;css&quot;:[]&#125;,&quot;a&quot;:&#123;&quot;size&quot;:46,&quot;entry&quot;:&quot;js/a-ac3cfa9c31ab31c7ee2e.js&quot;,&quot;hash&quot;:&quot;ac3cfa9c31ab31c7ee2e&quot;,&quot;css&quot;:[]&#125;&#125;js : [&quot;js/main-6409dbec7a578634313c.js&quot;,&quot;js/a-ac3cfa9c31ab31c7ee2e.js&quot;]css : []manifest : template : &quot;D:\\study\\webpack-practice\\node_modules\\html-webpack-plugin\\lib\\loader.js!D:\\study\\webpack-practice\\index.html&quot;filename : &quot;index.html&quot;hash : falseinject : &quot;head&quot;compile : truefavicon : falseminify : falsecache : trueshowErrors : truechunks : &quot;all&quot;excludeChunks : []title : &quot;webpack is good&quot;xhtml : falsedate : &quot;2017-06-22T03:52:57.284Z&quot; 一部分js放在头部，一部分放在body 通过设置 1&lt;script src="&lt;%= htmlWebpackPlugin.files.chunks.a.entry %&gt;"&gt;&lt;/script&gt; 压缩html https://www.npmjs.com/package/html-webpack-plugin minify 里面设置 可以看html-minifier 来设置 多页面的应用可以用chunks：[] 以数组的方式来表现 注意在多页面应用的时候如果template的index.html不能有多余的备注 如果一个page中需要多个js,可以用excludeChunks 提高请求，将js inline在page中1npm install --save-dev html-webpack-inline-source-plugin 123456plugins: [ new HtmlWebpackPlugin(&#123; inlineSource: '.(js|css)$' // embed all javascript and css inline &#125;), new HtmlWebpackInlineSourcePlugin()] 这时候inject: false 具体可以参考 https://github.com/DustinJackson/html-webpack-inline-source-plugin 也可以用 12&lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source() %&gt; 将main inline在html里面 ， 将对应的js 分别加入 12345678910111213141516171819202122232425&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source() %&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;% for (var k in htmlWebpackPlugin.files.chunks) &#123; %&gt; &lt;% if(k!== 'main') &#123; %&gt; &lt;script type="text/javascript" src="&lt;%= htmlWebpackPlugin.files.chunks[k].entry%&gt;"&gt;&lt;/script&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt;&lt;!--我是注释--&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var htmlWebpackPlugin = require('html-webpack-plugin');// var HtmlWebpackInlineSourcePlugin = require('html-webpack-inline-source-plugin');module.exports = &#123; // context: '', // 运行环境的上下文 // entry: ['./src/script/main.js', './src/script/a.js'], entry: &#123; main: './src/script/main.js', a: './src/script/a.js', b: './src/script/b.js', c: './src/script/c.js' &#125;, output: &#123; path: './dist', filename: 'js/[name]-[chunkhash].js', publicPath: 'http://cdn.com' //上线地址 &#125;, plugins: [ new htmlWebpackPlugin(&#123; template: 'index.html', // filename: 'index-[hash].html', filename: 'main.html', inject: false, // 也可以放在body标签里面 title: 'webpack is good', date: new Date(), minify: &#123; removeComments: true, // 删除注释 collapseWhitespace: true // 删除多余的空格 &#125;, // chunks: ['main', 'a'], inlineSource: '.(js|css)$' &#125;), new htmlWebpackPlugin(&#123; template: 'index.html', // filename: 'index-[hash].html', filename: 'a.html', inject: false, // 也可以放在body标签里面 title: 'a', // chunks: ['a'] // excludeChunks: ['b','c'], inlineSource: '.(js|css)$' &#125;), new htmlWebpackPlugin(&#123; template: 'index.html', // filename: 'index-[hash].html', filename: 'b.html', inject: false, // 也可以放在body标签里面 title: 'b', // chunks: ['b'] // excludeChunks: ['a','c'], inlineSource: '.(js|css)$' &#125;), new htmlWebpackPlugin(&#123; template: 'index.html', // filename: 'index-[hash].html', filename: 'c.html', inject: false, // 也可以放在body标签里面 title: 'c', // chunks: ['c'], // excludeChunks: ['a','b'], inlineSource: '.(js|css)$' &#125;), // new HtmlWebpackInlineSourcePlugin() ]&#125; chapter 4 如何使用loader http://webpack.github.io/docs/list-of-loaders.html#packaging 使用 http://webpack.github.io/docs/using-loaders.html 在require声明中使用 1require("url-loader?mimetype=image/png!./file.png"); 配置config文件 12345&#123; test: /\.png$/, loader: "url-loader", query: &#123; mimetype: "image/png" &#125;&#125; CLI中 1webpack --module-bind &quot;png=url-loader?mimetype=image/png&quot; 如何用ES6 using Babel http://babeljs.io/docs/setup/#installation 1npm install --save-dev babel-loader babel-core 因为es6不断变化，所以用的配置文件不一样，通过制定presets http://babeljs.io/docs/plugins/#transform-plugins 选择 latest 1npm install --save-dev babel-preset-latest 在config中配置 也可以另外建立个.babelrc文件 123&#123; "presets": ["latest"]&#125; 也可以在package.json里面定义 123456789101112&#123; &quot;name&quot;: &quot;webpack-practice&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;bable&quot;: &#123; &quot;presets&quot;: [&quot;latest&quot;] // 增加的 &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack --config webpack.config.js --progress --display-modules --colors --display-reasons&quot; &#125;, 打包的速度 babel 非常耗时 test: A condition that must be metexclude: A condition that must not be met 排除的include: An array of paths or files where the imported files will be transformed by the loader 包含的loader: A string of “!” separated loadersloaders: An array of loaders as string 绝对路径到相对路径引入path path.resolve 是解析路径 1234567loaders: [ &#123; test: /\.js$/, loaders: ['babel'], exclude: path.resolve(__dirname, 'node_modules'), &#125; ] css-loader1npm install css-loader style-loader --save-dev 1234&#123; test: /\.css$/, loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125; 给css加前缀12npm i postcss-loader --save-dev // 给css做预处理npm install autoprefixer --save-dev // 给css加前缀 autoprefixerApi https://github.com/postcss/autoprefixerpostcss plugins https://github.com/postcss/postcss 另外添加postcss.config.js12345678module.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;)(&#123; broswers: [&apos;last 5 versions&apos;] &#125;) ]&#125;; css中存在import的语法引入进来的也需要postcss-loader 1loaders: [&apos;style-loader&apos;, &apos;css-loader?importLoaders=1&apos;, &apos;postcss-loader&apos;], 执行顺序从右向左 在css-loader之后用1个loaders来处理import进来的资源 less-loader1npm install --save-dev less-loader less 12345&#123; test: /\.less$/, loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos;, &apos;less-loader&apos;]&#125; 当less中有import的时候，如果css中已经有import的配置，less就不需要配置了 sass-loader1npm install sass-loader node-sass webpack --save-dev 12345&#123; test: /\.less$/, loaders: ['style-loader', 'css-loader', 'postcss-loader', 'less-loader'] &#125; 处理模板文件 webpack 参考文档 http://webpack.github.io/docs/list-of-loaders.html#templatinggit项目的文档 https://github.com/webpack-contrib/html-loader 1npm i html-loader --save-dev 1npm i ejs-load --save-dev 12345678910111213141516171819202122232425262728293031loaders: [ &#123; test: /\.js$/, loaders: [&apos;babel&apos;], exclude: path.resolve(__dirname, &apos;node_modules&apos;), // include: path.resolve(__dirname, &apos;src&apos;) &#125;, &#123; test: /\.css$/, loaders: [&apos;style-loader&apos;, &apos;css-loader?importLoaders=1&apos;, &apos;postcss-loader&apos;], &#125;, &#123; test: /\.less$/, loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\.scss/, loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos;, &apos;sass-loader&apos;] &#125;, &#123; test: /\.html$/, loaders: [&apos;html-loader&apos;] &#125;, &#123; test: /\.ejs$/, loaders: [&apos;ejs-loader&apos;] &#125; ] 处理图片文件1npm install file-loader --save-dev https://github.com/webpack-contrib/file-loader 1234&#123; test: /\.(png|jpg|gif|svg)$/i, loaders: ['file-loader']&#125; 如果是在项目上引用相对路径的图片,写在模板index.html 如果在组件中插入图片，路径用的相对地址，打包的时候地址没有替换 地址可以写成 1&lt;img src=&quot;$&#123;require(&apos;../../assets/img.jpg&apos;)&#125;&quot; alt=&quot;&quot;&gt; 如果希望修改图片生成的地址 1234&#123; test: /\.(png|jpg|gif|svg)$/i, loaders: [&apos;file-loader?name=asset/[name]-[hash:5].[ext]&apos;]&#125; 1234567&#123; test: /\.(png|jpg|gif|svg)$/i, loader: &apos;file-loader&apos;, query: &#123; name: &apos;asset/[name]-[hash:5].[ext]&apos; &#125;&#125; url-loader处理文件图片大小大于制定的limit 扔给file-loader, 当小于这个lime,它可以转成一个64位编码1npm install url-loader --save-dev 12345678&#123; test: /\.(png|jpg|gif|svg)$/i, loader: &apos;url-loader&apos;, query: &#123; limit: 20000, name: &apos;asset/[name]-[hash:5].[ext]&apos; &#125;&#125; http 在如果来的图片会有缓存，如果图片重复性很高用加载 base64 没有缓存，容易导致代码的冗余和增加代码的体积 image-loader 压缩图片1npm install image-webpack-loader --save-dev image-loader Api https://github.com/tcoopman/image-webpack-loader 对每个格式的图片都有优化器，可以通过参数设置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[精通css高级web解决方案读书笔记]]></title>
      <url>%2F2017%2F06%2F21%2F%E7%B2%BE%E9%80%9Acss%E9%AB%98%E7%BA%A7web%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[虽然书比较老，但是讲的很好，以前没有注意到的问题都得到了解答 基础知识 在分配ID和类名时，一定要尽可能保持名称与表现方式无关 应该根据它们是什么来为元素命名，而不是应该根据它们外观如何来命名。这种方式会让代码更有意义 差的名称 好的名称 red error leftColumn secondaryContent topNav mainNav firstPara intro 尽可能使用class,但也不能用的太多给每个element都加class也是不正确，考虑吧这些元素分解成它们的组成部分，让代码更组件化 只在没有体现元素能够实现区域分割的情况下使用div bad 12345678&lt;div class="nav"&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt;a &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; good 1234&lt;ul class="nav"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 完全删除div,直接在列表上应用类 过度使用div是代码结构不合理而且过分复杂，div可以对会计元素进行分组，而span可以用来对行内元素进行分组或标识 DTD 文档类型定义 是一组机器可读的规则，在解析网页时浏览器使用这些规则检查页面 DOCTYPE 声明是指HTML文档开头处的一行或者梁行代码，描述使用哪个DTD,但不总是包含DTD文档的URL,例如H5目前有两个风格严格和过渡，过渡是从老板到新版本 校验代码 validator.w3.org chrome 插件 Web Developers Extension 浏览器模式 标准模式 混杂模式 页面以一种向后兼容的方式显示，通常用来模拟老式浏览器 DOCTYPE 切换 浏览器根据DOCTYPE是否存在以及使用的哪种DTD来选择要使用的呈现方式 如果有完整的DOCTYPE,那么一般以标准模式横线 如果包含过渡的，或者是错误DTD，会选择混杂模式呈现 为样式找到应用目标常用的选择器类选择器 p {} h1 {} 后代选择器 div p {} ID选择器和类选择器 伪类 通用选择器* {} 高级选择器 子选择器和相邻同胞选择器 #nav &gt; li{} h2 + p {} 属性选择器 p[title] {} 层叠和特殊性 选择器的特殊性氛围4个成分等级：a b c d 选择器 特殊性 以10为技术的特殊性 style=”” 1,0,0,0 1000 #wrapper #content {} 0,2,0,0 200 div#content {} 0,1,1,0 110 #content {} 0,1,0,0 100 p.content.dateposted {} 0,0,2,1 21 p.content 0,0,1,1 11 div p {} 0,0,0,2 2 p {} 0,0,0,1 1 如果在特殊页面上需要覆盖class的样式，可以在主题标签上添加id来标识页面 继承 规划、组织和维护样式表对文档应用样式123&lt;link href="css.css" rel="stylesheet" type="text/css"&gt; // 链接样式@import url('css.css'); // 导入样式 导入样式比链接样式慢，但是可以分割css便于维护 可以在css文件中进行注释 /* @group typography */ 加一个@ 方便搜索 设计代码的结构， 可以将代码划分为几大块，把最一般的规则放在最前，特殊的和辅助的放在后面 自我提示 使用 @todo表示某些东西需要进行修改、复查 用@bugfix表示代码或者特定浏览器遇到的问题 @workaround表示不完善的权宜之计 1/* @bugfix: rule breaks in IE */ 启用服务器端压缩 可视化格式模型盒模型outline属性与border属性不同，轮廓绘制在元素框之上，不影响元素的大小或者定位 外边界10px,5px的内边距，如果希望这个框达到100px像素宽，需要内容的宽度设为70px 12345.box &#123; margin： 10px; padding: 5px; width: 70px;&#125; 在IE的早期版本，混杂模式中使用自己的非标准盒模型，它会将内容、内边距、边框加为宽度的总和 css3 的box-sizing属性可以定义使用哪种盒模型 外边距叠加 相邻的情况 12&lt;div class="box" style="margin-bottom: 30px"&gt;&lt;/div&gt;&lt;div class="box" style="margin-top: 20px"&gt;&lt;/div&gt; 叠加后会变成 margin-bottom的30px,可以理解成谁大听谁的，如果一样大，就取他们的等值 嵌套的情况 123&lt;div style="margin-top: 30px; background: red; height: 50px;"&gt; &lt;div style="margin-top: 20px; height: 30px;"&gt;&lt;/div&gt;&lt;/div&gt; 这种情况下外边距的top和里面元素的top值重叠在一起，发生叠加，最后在外边距形成一个30 的top值，谁大听谁的 如果没有外边距的叠加，后续所有的段落之间的空间都僵尸顶外边距和底外边距的和，段落之间的间接是两倍，如果有叠加，意味着各处的距离就一致了 定位概述css中有3总基本定位机制：普通流、浮动和绝对定位。一般都是普通流中定位 相对定位流 position:relative 让这个元素相对于之前的文档流移动绝对定位 使元素的位置与文档流无关，不占据空间。位置是相对于距离它最近的那个已定位的祖先元素确定的，因为脱离文档流可以通过z-index设置框的叠放次序固定定位 绝对定位的一种，能够创建总是出现在窗口相同位置的浮动元素浮动 不在文档流中 清除浮动，让周围的元素为浮动元素留出空间 overflow 属性定义的包含在内容对于制定的尺寸太大情况下元素应该怎么样，而值为hidden或auto的副作用会自动清理包含任何浮动元素 设置特定的类 1234567.clear:after &#123;content: '.';height: 0;visibility: hidden;display: block;clear: both;&#125; 背景图片效果背景图像基础不要将像素或者百分数等单位与关键字混合使用 圆角框在设置圆角框背景的时候可以X设置固定的bg,y轴设置repeat-y的bg,这样背景框可以随着文字的改变而随文字变化 如果需要更加灵活的圆角背景框 需要设置top-left、top-right、bottom-left、bottom-right 四张图 border-image 三个参数（图片，剪裁，重复性）, 123456.border-image &#123;width: 400px;height: 300px;border: 1em double orange;border-image: url(...png) 27;&#125; 其中 27表示以27像素剪裁图片宽高 27 round 表示 平铺的效果 27 repeat 表示重复的效果 也可以通过border-width样式和border-image 分别设置四边的图像 1234.border-image &#123; border-image: url(...png) 2 5 6 2; border-width: 2px 5px 6px 2px;&#125; 这种样式可以理解成将url 这张图片分别 取 上右下左的距离 映射到背景边框上 投影可以给需要投影的div 增加一个容器，给这个容器设置背景，并设置一定的偏移量 123.img-wrapper img &#123; margin: -5px 5px 5px -5px;&#125; box-shadow：共6个参数 阴影类型 X-offset Y-offset 阴影模糊半径 阴影扩展半径 阴影颜色 不透明度 opacity 123.alert &#123; opacity: 0.8;&#125; rgba png 可以支持alpha透明，但是ie6不直接支持 视觉差 对多个背景图片做位置设定，当调整这些位置的时候，就会造成视觉差 对链接应用样式L-V-H-A 的顺序定义样式，否则后面的样式覆盖前前面的样式 如果想自定义a标签的下划线样式，可以通过背景的方法设置 如果同页面锚点的跳转，想突显跳转后元素的样式，可以采用target这个伪类 对跳转到外部的链接设置提示icon 123a[href^="http:"] &#123; background: url(...)&#125; 也可以突显其他例如email、下载等等 使用line-height 来控制按钮的高度，而不是用height,但是如果按钮中是两行文本就会将高度变为原来的两倍，这个只能调整按钮和文本尺寸 tooltip 1234567&lt;p&gt; &lt;a href="www.baidu.com" class="tooltip"&gt; Andy Buddy &lt;span&gt;(This website rocks)&lt;/span&gt; &lt;/a&gt; is a web developwe based in Brighton England&lt;/p&gt; 123456789101112131415161718a.tooltip &#123; position: relative; &#125; a.tooltip span &#123; display: none; &#125; a.tooltip:hover span, a.tooltip:focus span &#123; display: block; position: absolute; top: 1em; left: 2em; padding: 0.2em 0.6em; border: 1px solid #996633; background-color: #ffff66; color: #000; &#125; 对列表应用样式和创建导航条对表单和数据表格应用样式表格表格的特有元素第一个元素是caption表格的标题，summary属性应用于表格标签，用来描述表格的内容，类似图像的alt文本 12345678910111213&lt;table border="6"&gt;&lt;caption summary="标题"&gt;我的标题&lt;/caption&gt;&lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;td&gt;300&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;400&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;600&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表格样式样式 border-collapse 属性设置为collapse 属性设置为separate border-spacing 可以控制表格之间的距离 表单 fieldset 对相关信心块进行分组 label 元素可以帮助添加结构增加表单的可用性和可访问性 input 控件 将标签和控件关联起来 隐形方式1&lt;label&gt;email&lt;input name="email" type="text"&gt;&lt;/label&gt; 显示方式 12&lt;label for="email"&gt;email&lt;/label&gt;&lt;input name="email" id="email" type="text"&gt; 在表单输入控件和标签之间创建关联需要id属性，二表单数据发送回服务器需要name属性。id,name尽可能一致 必填项 可以用em 或 strong元素来强调 简单的表单布局可以考虑垂直型的而复杂的表单布局可以考虑水平的布局，而想使用水平布局可以将标签左浮动，并设置宽度 123456label &#123; float: left; width: 10em; cursor: pointer;&#125; 即使有些地方需要隐藏标签，写需要在源代码中体现，这个可以帮助屏幕阅读器使用，者仍然很重要。 可以将需要隐藏的标签的高度设为0，display: none; text-indent:-1000em; 提交按钮 1&lt;button type="submit"&gt;&lt;/button&gt; 通常建议使用button， 各个系统中input样式定义不同，为了一致性可以考虑button 表单返回 123456&lt;div&gt;&lt;label for=email"&gt;&lt;em class="feedback"&gt;please try again.&lt;/em&gt;&lt;/label&gt;&lt;input name="email" id="email" type="text" &gt;&lt;/div&gt; 布局 首先检查设计，寻找重复的模式，不应该关注表现方式，应该注重结构和意义 将页面划分为大的机构性区域，然后将注意力转移到内容区域本身 在各个内容区域中寻找不同的布局结构 流性布局使用百分数而不是像素设置，在必要的时候加min-width,防止布局太窄 弹性布局弹性布局相对于字号来设置元素的宽度，以em为单位设置宽度，确保字号增加布局随之扩大 图片的布局123&lt;div class="branding"&gt; &lt;img src="" alt="" width="" height=""&gt;&lt;/div&gt; 1234#branding &#123; width: 100%; overflow: hidden;&#125; faux 列 针对固定宽度的两列布局，只需要在容器元素上应用一个垂直重复的背景图片，宽度与导航区域相同 123#wrapper &#123; background: #fff url(...) repeat-y left top;&#125; 高度相等的列 overflow padding margin 给每个框设置打的底边距，然后数值相似的负外边界消除这个高度,父级使用overflow: hidden 123456789101112131415161718.box &#123; width: 250px; float: left; margin-left: 20px; display: inline; padding: 20px; background: #ccc; padding-bottom: 500px; margin-bottom: -500px; display: inline;&#125;.bottom &#123; position: absolute; bottom: 0; height: 20px; width: 290px;&#125; 1234567891011121314&lt;div class="wrapper"&gt; &lt;div class="box"&gt; &lt;h1&gt;andy buddy&lt;/h1&gt; &lt;p&gt;健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台…开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台&lt;/p&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;h1&gt;andy buddy&lt;/h1&gt; &lt;p&gt;健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台…开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台&lt;/p&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;h1&gt;andy buddy&lt;/h1&gt; &lt;p&gt;健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台…开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的台&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; table 方法 123456789101112131415.table &#123; width: 80%; margin: 2em auto; display: table; border-collapse: separate; border-spacing: 30px 0;&#125;.row &#123; display: table-row;&#125;.col &#123; display: table-cell; background-color: #ccc; padding: 30px;&#125; 12345678910111213141516&lt;main class="table"&gt; &lt;div class="row"&gt; &lt;div class="col"&gt; &lt;h1&gt;andy buddy&lt;/h1&gt; &lt;p&gt;健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台…开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台&lt;/p&gt; &lt;/div&gt; &lt;div class="col"&gt; &lt;h1&gt;andy buddy&lt;/h1&gt; &lt;p&gt;健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台…开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台&lt;/p&gt; &lt;/div&gt; &lt;div class="col"&gt; &lt;h1&gt;andy buddy&lt;/h1&gt; &lt;p&gt;健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台…开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台。都可以在手机上与全国三甲医生协作，开展科普、科研、分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的三甲医院有上万名医务工作者加入这个协作平台开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。北京、上海地区的台&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/main&gt; 伪类实现 123456789&lt;div class="main clearfix"&gt; &lt;div class="box"&gt; 健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲医生协作，开展科普、科研分诊、转诊、随诊、预约就诊及会诊等服务。 &lt;/div&gt; &lt;div class="box"&gt; 健康微能量2015年初推出医帮医——移动健康云协作平台，任何一名医生，都可以在手机上与全国三甲 &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.main &#123; width: 80%; margin: 3em auto; position: relative; overflow: hidden;&#125;.box &#123; float: left; margin: 3px; width: 230px; color: #FFFFFF; background-color: #FF4A59; box-shadow: 2px 3px 4px #846363;&#125;.box:after &#123; display: block; position: absolute; height: 100%; content: ""; background-color: #FF4A59; box-shadow: 2px 2px 4px #846363; width: 230px;&#125; 通过column-count、column-width和column-gap属性实现 123&lt;div class="col"&gt; &lt;p&gt;after ......&lt;/p&gt;&lt;/div&gt; 123456.col &#123;column-count: 3;column-width: 140px;column-gap: 2px; // 列之间的间距column-rule: 1px solid #ccc; // 列之间有一条线&#125; css 框架缺点 要求在设计中必须使用特定的网格结构，框架定义的宽高适应你的设计。而css框架不应该决定站点的设计 bug与bug修复特殊性和分类次序的问题 只在需要细粒度的控制时添加更特殊的选择器 1234567.content p &#123; background: red;&#125;.intro &#123; background: orange; // 想让p中intro的背景变为橘色&#125; 这里无法变，因为选择器的优先级不够 改为 .content .intro 外边距叠加的问题 通过添加一个垂直边框或内边框，外边距就不会叠加 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 1234567div &#123;margin: 10px;&#125;p &#123;margin: 20px;&#125; 这样margin重叠得到是20px的垂直外边距 可以变为 1234div&#123;margin: 10px;padding: 1px;&#125; 修改低版本中的代码123&lt;!-- [if IE 6] &lt;link rel="stylesheet" type="text/css" href=""&gt;--&gt; ie 低版本float浮动造成两倍外边距 实例研究 Roma Italia 轻量化各种标记，能简化的要简化 使用reset样式表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap教程]]></title>
      <url>%2F2017%2F05%2F31%2Fbootstrap%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[最近项目在用，认真学一遍 第一课 生产环境 less sass 使用bootstrap 必须引入jquery 第二课 栅格系统 将整个页面分为12列，通过网格的分配，来统一元素的分布 容器 container-fluid 流体容器 根据屏幕大小自动撑开 自适应整个屏幕 左右分别有 15px的 padding container 固定容器 根据不同的分辨率，宽度会有不同的变化 左右分别有 15px的 padding 1170 大于1200 970 大于992 750 大于768 auto 小于768 因为padding的关系，尽量不要出现嵌套关系 第三课 栅格系统 row 行 col 列 col-lg-1 占1个列网格，12个占满，如果超过12个会被挤到下一行 用的都是float:left col-lg-* 指超大屏幕的展示，如果低于1200的分辨率，会竖列排列 col-md-* 中等屏幕显示的范围 大于992 col-sm-* ipad的范围 大于 768 col-xs-* 手机范围 小于768 组合模式 大屏一行排3个 中屏一行排2个 12345&lt;div class="row"&gt; &lt;div class="col-lg-4 col-md-6"&gt;&lt;/div&gt; &lt;div class="col-lg-4 col-md-6"&gt;&lt;/div&gt; &lt;div class="col-lg-4 col-md-6"&gt;&lt;/div&gt; &lt;/div&gt; 第四课 列偏移 col-lg-offset-4 向右偏移4个距离 最多偏移12个，超过不起作用 12345&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-lg-4 col-lg-offset-4"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 当减少分辨率的时候，会竖向排列，不受偏移量的影响 12345&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-lg-4 col-lg-offset-4 col-md-offset-4"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 没有设置md的大小，当适应了md的分辨率，md向右偏移4个距离，那么元素栈8个距离 列排序 push 往后 pull 往前 123456&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-lg-2 col-lg-push-10"&gt;col-lg-2&lt;/div&gt; &lt;div class="col-lg-10 col-lg-pull-2"&gt;col-lg-10&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 本应该在前面的 col-lg-2 因为加了col-lg-push-10 跑到了后面，而col-lg-10 加了pull跑到了前面 offset 只能往右偏移，push 和 pull 可以 右左偏移 offset 当有多个元素存在，一行偏移不够，会折行再去偏移,这种偏移出去的情况可以用push row嵌套按父级 清楚浮动 clearfix 第五课 响应式工具 概念 针对不同设备展示或者蕴藏页面的内容 可见类 visible-lg-block 只有当这个元素是lg分辨率下，以block的形式显示出来 还有 inline、inline-display 不可见类 hidden hidden-sm 在sm的分辨率下隐藏 打印显示类 visible-print-block 打印模式下显示 打印不显示 hidden-print pull-left 左浮动 pull-right 右浮动 row 会自动处理padding affix 固定定位 第六课 字体图标很多的小图标可以采用字体图标 减少请求 容易控制样式 使用设置font路径，如果修改需要打开bootstrap.css 搜索到font-face 修改路径 不要在图标元素中写内容 第七课 预定义样式风格 按钮 btn-primary 首选项 btn btn-primary btn-success 成功 btn-info 信息 btn-warning 警告 btn-danger 危险 背景相关 bg-primary bg-success 成功 bg-info 信息 bg-warning 警告 bg-danger 危险 文字 text-primary text-success 成功 text-info 信息 text-warning 警告 text-danger 危险 警告框 alert alert-warning alert alert-danger 面板 panel panel-primary panel panel-success 123456&lt;div class="panel panel-success"&gt;&lt;h4&gt;title&lt;/h4&gt;&lt;div class="panel-body"&gt; content&lt;/div&gt;&lt;/div&gt; 第八课 按钮 基类 btn btn-default 带边框的按钮 btn-link 像连接的按钮 大小 默认值md btn-lg btn-sm btn-xs 输入框 input 状态 active 选中的状态 disabled 禁用状态，鼠标移入禁止 按钮还可以加给a、input、button 按钮块级的方式 btn-block 第九课 按钮组 btn-group 给按钮加父级 12345&lt;div class="btn-group"&gt; &lt;input type="button" class="btn btn-primary" value="ok"&gt; &lt;input type="button" class="btn btn-primary" value="ok"&gt; &lt;input type="button" class="btn btn-primary" value="ok"&gt;&lt;/div&gt; btn-group-justified 以父容器的内容作为适应，做到端点， 但只能用在a标签，如果input和button也想用，必须每一个按钮元素分别嵌套btn-group 12345&lt;div class="btn-group btn-group-justified"&gt; &lt;a href="#" class="btn btn-primary"&gt;ok1&lt;/a&gt; &lt;a href="#" class="btn btn-primary"&gt;ok1&lt;/a&gt; &lt;a href="#" class="btn btn-primary"&gt;ok1&lt;/a&gt;&lt;/div&gt; 12345678&lt;div class="btn-group btn-group-justified"&gt; &lt;div class="btn-group"&gt; &lt;input type="button" class="btn btn-primary" value="ok"&gt; &lt;/div&gt; &lt;div class="btn-group"&gt; &lt;input type="button" class="btn btn-primary" value="ok"&gt; &lt;/div&gt;&lt;/div&gt; btn-group-vertical 不用加 btn-group 1234567891011121314&lt;div class="btn-group-vertical"&gt; &lt;a href="#" class="btn btn-primary"&gt;ok&lt;/a&gt; &lt;a href="#" class="btn btn-primary"&gt;ok&lt;/a&gt; &lt;a href="#" class="btn btn-primary"&gt;ok&lt;/a&gt;&lt;/div&gt;``` - 大小 btn-group-lg btn-group-sm btn-group-xs - 按钮加向下箭头 caret```html&lt;a href="#" class="btn btn-primary"&gt;button&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; 1&lt;button class="btn btn-success"&gt;button&lt;span class="caret"&gt;&lt;/span&gt;&lt;/button&gt; 不适用于input，如果有图标的情况应考虑 a、input 在按钮组的情况下可以让下拉单独成一个button 如何改为向上的箭头？ 需要给父级加dropup的类 1234&lt;div class="btn-group dropup"&gt; &lt;button class="btn btn-primary"&gt;button&lt;/button&gt; &lt;button class="btn btn-primary"&gt;&lt;span class="caret"&gt;&lt;/span&gt;&lt;/button&gt;&lt;/div&gt; 第十课 下拉菜单12345678910111213&lt;div class="dropdown"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true"&gt; Dropdown &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu" aria-labelledby="dropdownMenu1"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; data-* js交互触发器的写法 toggle切换aria-* haspopup 是否有弹出菜单 expanded 现在菜单展开的状态 labelledby 能读到 Dropdownrole 描述状态而 aria是状态行为的描述 如果用div模拟复选框，需要加role 1&lt;div role="checkbox" aria-label="checked"&gt;&lt;/div&gt; 如果想展示下拉菜单给class中加open ul上加dropdown-menu-left 菜单靠左，dropdown-menu-right如果想让下拉的菜单用btn-block显示，如果想靠左靠右直接在父级div上加 pull-right会影响显示，可以用上面的给ul加 dropdown-menu-left dropdown-menu-right 第十一课下拉菜单不占高度 ul 下拉中ul的展示可以用btn-block 也可以设置宽度 下拉项li中可以设置不选项，可以用类 dropdown-header 下拉项li中可以设置分隔线 divider active 为选中项 disabled 为禁用项 菜单默认都是下拉，如何上拉？ 将父级的dropdown 改为 dropup 12345678910111213&lt;div class="dropup"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true"&gt; Dropdown &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu" aria-labelledby="dropdownMenu1"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如何将下拉的文字居中 给每个li 加 text-center 下拉菜单不仅可以给button 还可以给a 第十二课鼠标移入出现下拉菜单，但是bootstrap是移动优先，并没有设计鼠标移入 但是如果给下拉加mouseover的逻辑，在移动端的时候点击下拉，会出现pc端移入的效果，我们可以使用进行设备判断 123456789101112131415161718// 这个是pc 端的判断var timer = null; // 之所以加延迟，是因为btn到下拉if(window.navigator.userAgent.toLocaleLowerCase().indexOf('mobile') == -1) &#123; $('.dropdown').hover(function () &#123; $('.dropdown').add('open'); &#125;, function () &#123; timer = setTimeout(function() &#123; $('.dropdown').remove('open'); &#125;, 100) &#125;); $('.dropdown-menu').hover(function () &#123; clearTimeout(timer) &#125;, function () &#123; timer = setTimeout(function() &#123; $('.dropdown').remove('open'); &#125;, 100) &#125;);&#125; 123$('.dropdown-toggle').dropdown();// 这句话类似在html中写data-toggle="dropdown，但是点击屏幕中其他位置无法隐藏// 用这个写法的好处就是下拉相互独立， 没有这句 如果存在多个下拉的时候，点开其中一个下拉，另外的下拉会关闭 1234567891011121314$('.dropdown-toggle').dropdown('toggle'); //如果菜单隐藏，用这个方法菜单就会显示$('.dropdown').on('show.bs.dropdown', function() &#123; // 菜单显示前触发&#125;)$('.dropdown').on('shown.bs.dropdown', function() &#123; // 菜单显示后触发&#125;)$('.dropdown').on('hide.bs.dropdown', function() &#123; // 菜单隐藏前触发&#125;)$('.dropdown').on('hiden.bs.dropdown', function() &#123; // 菜单隐藏后触发&#125;) 如果想实现几个下拉同时下拉操作，可以使用data-target=’.dropdown’, 指定了元素后，可以通过一个控制多个 而其他之前没有用data-toggle=”dropdown”的下拉，点其他地方不收的下拉，也变得可控制，点其他地方也可以收下拉 第十三课 标签页整体宽和父级容器的宽度一样 nav-tabs 1234567&lt;div class="container"&gt; &lt;ul class="nav nav-tabs"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;three&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 默认情况自适应 nav-justified 自适应父级的宽度 端点对齐 当分辨率小于768，会变成树型 1234567&lt;div class="container"&gt; &lt;ul class="nav nav-tabs nav-justified"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;three&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; nav-tabs-justified 线的宽度按内容显示 按照最小的显示 nav-pills nav-stacked 常与 nav-pills结合 1234567&lt;div class="container"&gt; &lt;ul class="nav nav-tabs nav-pills nav-stacked"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;three&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 下拉菜单和tab 结合显示12345678910111213141516&lt;div class="container"&gt; &lt;ul class="nav nav-tabs"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt; three &lt;span class="caret"&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;child1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;child1&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 第十四课 标签页内容页123456789101112&lt;div class="container"&gt; &lt;ul class="nav nav-tabs"&gt; &lt;li class="active"&gt;&lt;a href="#aaa" data-toggle="tab"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#bbb" data-toggle="tab"&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#ccc" data-toggle="tab"&gt;three&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="tab-content"&gt; &lt;li id="aaa" class="tab-pane active"&gt;1111111&lt;/li&gt; &lt;li id="bbb" class="tab-pane"&gt;222222&lt;/li&gt; &lt;li id="ccc" class="tab-pane"&gt;333333 &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如果要控制宽度，需要给父级加整体的宽度 修改 .tab-content 可对content 设置不同的样式 淡入淡出 fade 淡入淡出 默认隐藏 需要加in 123456789101112&lt;div class="container"&gt; &lt;ul class="nav nav-tabs"&gt; &lt;li class="active"&gt;&lt;a href="#aaa" data-toggle="tab"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#bbb" data-toggle="tab"&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#ccc" data-toggle="tab"&gt;three&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="tab-content"&gt; &lt;li id="aaa" class="tab-pane fade in active"&gt;1111111&lt;/li&gt; &lt;li id="bbb" class="tab-pane fade"&gt;222222&lt;/li&gt; &lt;li id="ccc" class="tab-pane fade"&gt;333333 &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 鼠标移入的方式 123456789101112&lt;div class="container"&gt; &lt;ul id="myTabs" class="nav nav-tabs"&gt; &lt;li class="active"&gt;&lt;a href="#aaa" data-toggle="tab"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#bbb" data-toggle="tab"&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#ccc" data-toggle="tab"&gt;three&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="tab-content"&gt; &lt;li id="aaa" class="tab-pane fade in active"&gt;1111111&lt;/li&gt; &lt;li id="bbb" class="tab-pane fade"&gt;222222&lt;/li&gt; &lt;li id="ccc" class="tab-pane fade"&gt;333333 &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123$('#myTabs a').mouseover(function() &#123; $(this).tab('show'); // 显示&#125;) 带下拉的标签页 12345678910111213141516171819202122&lt;div class="container"&gt; &lt;ul class="nav nav-tabs"&gt; &lt;li class="active"&gt;&lt;a href="#" data-toggle="tab"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#b" data-toggle="tab"&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt; three &lt;span class="caret"&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#c" data-toggle="tab"&gt;child1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#d" data-toggle="tab"&gt;child1&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class="tab-content"&gt; &lt;li id="a" class="tab-pane fade in active"&gt;1111111&lt;/li&gt; &lt;li id="b" class="tab-pane fade"&gt;222222&lt;/li&gt; &lt;li id="c" class="tab-pane fade"&gt;333333&lt;/li&gt; &lt;li id="d" class="tab-pane fade"&gt;444444&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 第十五课 导航条123456789&lt;div class="container"&gt; &lt;nav class="navbar navbar-default"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href=""&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;one&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/div&gt; 常见的写法是把容器写到navbar里面 123456789&lt;nav class="nav navbar-default"&gt;&lt;div class="container"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/nav&gt; 如果container 换为 container-fluid 会变成自适应 navbar-inverse 加在相反的色调 加在nav的class上 123456789&lt;nav class="navbar navbar-inverse"&gt; &lt;div class="container"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; navbar-static-top 两边的脚变为直角 123456789&lt;nav class="navbar navbar-inverse navbar-static-top"&gt; &lt;div class="container"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 固定的滚动条 navbar-fixed-top 固定定位到顶 navbar-fixed-botton 固定定位到底部 如果固定了导航条，写底下的内容的时候会遮挡底下的内容 可以给body 一个margin-top的值 第十六课 导航条导航条logo 增加logo 12345678910&lt;nav class="navbar navbar-inverse navbar-static-top"&gt; &lt;div class="container"&gt; &lt;a href="#" class="navbar-brand"&gt;logo&lt;/a&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 在移动的时候，logo会消失 123456789101112&lt;nav class="navbar navbar-inverse navbar-static-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;a href="#" class="navbar-brand"&gt;logo&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 默认靠左，可以在ul上用 navbar-right 让它靠右 在导航中加按钮 navbar-btn 就可以居中 如果加链接 navbar-link 加文字 navbar-text 导航中输入框 12345678910111213141516171819&lt;nav class="navbar navbar-inverse navbar-static-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;a href="#" class="navbar-brand"&gt;logo&lt;/a&gt; &lt;/div&gt; &lt;p class="navbar-text"&gt;文字&lt;/p&gt; &lt;form class="navbar-form navbar-left"&gt; &lt;input type="text" class="form-control" placeholder="提示信息"&gt; &lt;input type="submit" class="btn" value="search"&gt; &lt;/form&gt; &lt;a href="#" class="navbar-link"&gt;链接&lt;/a&gt; &lt;button class="btn navbar-btn"&gt;登录&lt;/button&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 知乎举例 123456789101112131415161718192021222324&lt;nav class="navbar navbar-default navbar-fixed-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;a href="#" class="navbar-brand"&gt;&lt;img src="https://static.zhihu.com/static/revved/img/sticky_header/new_logo.ede2316d.png" alt=""&gt;&lt;/a&gt; &lt;/div&gt; &lt;form class="navbar-form navbar-left"&gt; &lt;div class="input-group"&gt; &lt;input type="text" class="form-control" placeholder="搜索问题" style="width: 320px"&gt; &lt;span class="input-group-addon"&gt;&lt;a href="#"&gt;&lt;span class="glyphicon glyphicon-search"&gt;&lt;/span&gt;&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-left" &gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;话题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;发现&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right" &gt; &lt;li&gt;&lt;a href="#"&gt;&lt;i class="glyphicon glyphicon-user"&gt;&lt;/i&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;button class="btn btn-primary navbar-btn navbar-right"&gt;提问&lt;/button&gt; &lt;/div&gt;&lt;/nav&gt; 第十七课 导航条的使用 带菜单的导航条 123456789101112131415161718&lt;nav class="navbar navbar-default navbar-static-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;a href="#" class="navbar-brand"&gt;logo&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li &gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li &gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;one &lt;i class="caret"&gt;&lt;/i&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;111&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;111&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 自适应的导航条（移动下汉堡导航条） 加 给菜单加父类 ul 加collapse navbar-collapse 12345678910111213141516171819&lt;nav class="navbar navbar-default navbar-fixed-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button class="navbar-toggle" data-toggle="collapse" data-target="#myCollapse"&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a href="#" class="navbar-brand"&gt;logo&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="myCollapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;one&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 滚动监听 整页面中跳转 1234567891011121314151617181920212223242526272829303132333435&lt;nav id="navbar-example" class="navbar navbar-default navbar-static" role="navigation"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;a class="navbar-brand" href="#"&gt;教程名称&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse "&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="#ios"&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#svn"&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div data-spy="scroll" data-target="#navbar-example" data-offset="0" style="height:200px;overflow:auto; position: relative;"&gt; &lt;h4 id="ios"&gt;iOS&lt;/h4&gt; &lt;p&gt;iOS 是一个由苹果公司开发和发布的手机操作系统。最初是于 2007 年首次发布 iPhone、iPod Touch 和 Apple TV。iOS 派生自 OS X，它们共享 Darwin 基础。OS X 操作系统是用在苹果电脑上，iOS 是苹果的移动版本。 &lt;/p&gt; &lt;h4 id="svn"&gt;SVN&lt;/h4&gt; &lt;p&gt;Apache Subversion，通常缩写为 SVN，是一款开源的版本控制系统软件。Subversion 由 CollabNet 公司在 2000 年创建。但是现在它已经发展为 Apache Software Foundation 的一个项目，因此拥有丰富的开发人员和用户社区。 &lt;/p&gt; &lt;h4 id="jmeter"&gt;jMeter&lt;/h4&gt; &lt;p&gt;jMeter 是一款开源的测试软件。它是 100% 纯 Java 应用程序，用于负载和性能测试。 &lt;/p&gt; &lt;h4 id="ejb"&gt;EJB&lt;/h4&gt; &lt;p&gt;Enterprise Java Beans（EJB）是一个创建高度可扩展性和强大企业级应用程序的开发架构，部署在兼容应用程序服务器（比如 JBOSS、Web Logic 等）的 J2EE 上。 &lt;/p&gt; &lt;h4 id="spring"&gt;Spring&lt;/h4&gt; &lt;p&gt;Spring 框架是一个开源的 Java 平台，为快速开发功能强大的 Java 应用程序提供了完备的基础设施支持。 &lt;/p&gt; &lt;p&gt;Spring 框架最初是由 Rod Johnson 编写的，在 2003 年 6 月首次发布于 Apache 2.0 许可证下。 &lt;/p&gt;&lt;/div&gt; 监听的需要相对定位 data-spy 监听滚动条 data-offset 当计算滚动位置时，距离顶部的偏移像素。多少就可以给需要显示的标记active,不需要滚动的时候元素到顶部才active 也可以用padding-top 增加偏移来防止菜单的遮挡content 第十八课 自学段落 lead 需要强调，突出的段落 列表 list-unstyle 去掉ul中提别样式是padding list-inline 让列表水平显示 123456&lt;ul class="list-inline"&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;南京&lt;/li&gt; &lt;li&gt;厦门&lt;/li&gt;&lt;/ul&gt; dl-horizontal 给定义的列表实现水平显示 123456&lt;dl class="dl-horizontal"&gt; &lt;dt&gt;标题一&lt;/dt&gt; &lt;dd&gt;描述内容&lt;/dd&gt; &lt;dt&gt;标题二&lt;/dt&gt; &lt;dd&gt;描述内容&lt;/dd&gt;&lt;/dl&gt; 大屏显示效果 pre-scrollable 当列表太长的时候出现y轴滑动，高度默认340px 代码 kbd 标注键盘输入的代码 1&lt;p&gt;请使用&lt;kbd&gt;ctrl+x&lt;/kbd&gt;复制代码，然后使用&lt;kbd&gt;ctrl+shift+v&lt;/kbd&gt;将复制的代码粘贴到需要的地方。&lt;/p&gt; 表格 table 基础表格 table-striped 斑马线表格 table-bordered 带边框的表格 table-hover 鼠标悬停高亮 table-condensed 紧凑型表格 table-responsive 响应的表格 表格行的颜色 表单 form-group 默认垂直显示表单 12345678910111213141516&lt;form role="form"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;邮箱：&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="请输入您的邮箱地址"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;密码&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="请输入您的邮箱密码"&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;进入邮箱&lt;/button&gt;&lt;/form&gt; form-horizontal 水平表单风格， 小屏下会变为垂直显示 12345678910111213141516171819202122232425262728&lt;form class="form-horizontal" role="form"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;邮箱&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="请输入您的邮箱地址"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;密码&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" class="form-control" id="inputPassword3" placeholder="请输入您的邮箱密码"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;button type="submit" class="btn btn-default"&gt;进入邮箱&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; sr-only 不显示label里面的东西 12345678910111213141516&lt;form class="form-inline" role="form"&gt; &lt;div class="form-group"&gt; &lt;label class="sr-only" for="exampleInputEmail2"&gt;邮箱&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail2" placeholder="请输入你的邮箱地址"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="sr-only" for="exampleInputPassword2"&gt;密码&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword2" placeholder="请输入你的邮箱密码"&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;进入邮箱&lt;/button&gt;&lt;/form&gt; form-control 单行输入框， 可以修改.form-control:focus来改变焦点样式 下拉选择和多行选择 1234567891011121314151617181920&lt;form role="form"&gt; &lt;div class="form-group"&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;select multiple class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/form&gt; checkbox radio都使用label包起来 123456789101112131415161718&lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" value=""&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;div class="radio"&gt; &lt;label&gt; &lt;input type="radio" name="optionsRadios" id="optionsRadios1" value="love" checked&gt; 喜欢 &lt;/label&gt; &lt;/div&gt; &lt;div class="radio"&gt; &lt;label&gt; &lt;input type="radio" name="optionsRadios" id="optionsRadios2" value="hate"&gt; 不喜欢 &lt;/label&gt; &lt;/div&gt; 一组水平checkbox或者水平radio 需要在label上加checkbox-inline 或 radio-inline 如果radio需要一组 它们name要一样 input-lg比一般控件大 input-sm 比一般控件小 disabled 禁用状态可以给input fieldset加 表单校验 has-warning 警告状态 has-error 错误状态 has-success 成功状态 1234567891011121314151617&lt;form role="form"&gt; &lt;div class="form-group has-success has-feedback"&gt; &lt;label class="control-label" for="inputSuccess1"&gt;成功状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputSuccess1" placeholder="成功状态" &gt; &lt;span class="glyphicon glyphicon-ok form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-group has-warning has-feedback"&gt; &lt;label class="control-label" for="inputWarning1"&gt;警告状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputWarning1" placeholder="警告状态"&gt; &lt;span class="glyphicon glyphicon-warning-sign form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-group has-error has-feedback"&gt; &lt;label class="control-label" for="inputError1"&gt;错误状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputError1" placeholder="错误状态"&gt; &lt;span class="glyphicon glyphicon-remove form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/form&gt; 表单提示信息 help-block help-inline 提示信息块状显示 1234567891011121314151617181920&lt;form role="form"&gt; &lt;div class="form-group has-success has-feedback"&gt; &lt;label class="control-label" for="inputSuccess1"&gt;成功状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputSuccess1" placeholder="成功状态" &gt; &lt;span class="help-block"&gt;你输入的信息是正确的&lt;/span&gt; &lt;span class="glyphicon glyphicon-ok form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-group has-warning has-feedback"&gt; &lt;label class="control-label" for="inputWarning1"&gt;警告状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputWarning1" placeholder="警告状态"&gt; &lt;span class="help-block"&gt;请输入正确信息&lt;/span&gt; &lt;span class="glyphicon glyphicon-warning-sign form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-group has-error has-feedback"&gt; &lt;label class="control-label" for="inputError1"&gt;错误状态&lt;/label&gt; &lt;input type="text" class="form-control" id="inputError1" placeholder="错误状态"&gt; &lt;span class="help-block"&gt;请输入正确信息&lt;/span&gt; &lt;span class="glyphicon glyphicon-remove form-control-feedback"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/form&gt; 按钮 btn-lg btn-sm btn-xs 按钮的大小 btn-block 显示为块 按钮disabled 可以加类 也可以加属性 disabled=”disabled” btn-group 按钮组 btn-toolbar 比按钮组更得的容器 可用于富文本编辑器 btn-group-vertical 垂直按钮分组 btn-group-justified 等分按钮组 图片 img-responsive 响应图片 img-rounded 圆角图片 img-circle 圆形图片 img-thumbnail 缩略图片 面包导航12345&lt;ol class="breadcrumb"&gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;我的书&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;《图解CSS3》&lt;/li&gt;&lt;/ol&gt; 分页123456789&lt;ul class="pagination pagination"&gt; &lt;li&gt;&lt;a href="#"&gt;&amp;laquo;第一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;12&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;13&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;14&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;15&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="#"&gt;最后一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 可以将pagination 改为pagination-lg pagination-sm 改变分页大小 翻页 1234567891011121314&lt;ul class="pager"&gt; &lt;li&gt;&lt;a href="#"&gt;&amp;laquo;上一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;下一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;!--左右对齐--&gt;&lt;ul class="pager"&gt; &lt;li class="previous"&gt;&lt;a href="#"&gt;&amp;laquo;上一页&lt;/a&gt;&lt;/li&gt; &lt;li class="next"&gt;&lt;a href="#"&gt;下一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;!--禁止状态--&gt;&lt;ul class="pager"&gt; &lt;li class="disabled"&gt;&lt;span&gt;&amp;laquo;上一页&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;下一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 标签 label-default label-primary label-success label-info label-warning label-danger 徽章 badge 123&lt;button class="btn btn-primary" type="button"&gt; Messages &lt;span class="badge"&gt;4&lt;/span&gt;&lt;/button&gt; 缩略图 只有缩略图 1234567891011121314151617181920212223&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;" &gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;"&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 带描述的缩略图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;Bootstrap框架系列教程&lt;/h3&gt; &lt;p&gt;Bootstrap框架是一个优秀的前端框，就算您是一位后端程序员或者你是一位不懂设计的前端人员，你也能依赖于Bootstrap制作做优美的网站...&lt;/p&gt; &lt;p&gt; &lt;a href="##" class="btn btn-primary"&gt;开始学习&lt;/a&gt; &lt;a href="##" class="btn btn-info"&gt;正在学习&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;"&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;Bootstrap框架系列教程&lt;/h3&gt; &lt;p&gt; Bootstrap框架是一个优秀的前端框，就算您是一位后端程序员或者你是一位不懂设计的前端人员，你也能依赖于Bootstrap制作做优美的网站...&lt;/p&gt; &lt;p&gt; &lt;a href="##" class="btn btn-primary"&gt;开始学习&lt;/a&gt; &lt;a href="##" class="btn btn-info"&gt;正在学习&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;"&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;Bootstrap框架系列教程&lt;/h3&gt; &lt;p&gt;Bootstrap框架是一个优秀的前端框，就算您是一位后端程序员或者你是一位不懂设计的前端人员，你也能依赖于Bootstrap制作做优美的网站...&lt;/p&gt; &lt;p&gt; &lt;a href="##" class="btn btn-primary"&gt;开始学习&lt;/a&gt; &lt;a href="##" class="btn btn-info"&gt;正在学习&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img alt="100%x180" src="http://img.mukewang.com/5434eba100014fe906000338.png" style="height: 180px; width: 100%; display: block;"&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;Bootstrap框架系列教程&lt;/h3&gt; &lt;p&gt;Bootstrap框架是一个优秀的前端框，就算您是一位后端程序员或者你是一位不懂设计的前端人员，你也能依赖于Bootstrap制作做优美的网站...&lt;/p&gt; &lt;p&gt; &lt;a href="##" class="btn btn-primary"&gt;开始学习&lt;/a&gt; &lt;a href="##" class="btn btn-info"&gt;正在学习&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 警示框 alter-success 成功 alert-info 信息 alert-warning 警告 alert-danger 微信 1&lt;div class="alert alert-success" role="alert"&gt;恭喜您操作成功！&lt;/div&gt; 带关闭的 alert-dismissable 1234&lt;div class="alert alert-info alert-dismissable" role="alert"&gt; &lt;button class="close" type="button" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; 请输入正确的密码&lt;/div&gt; alert-link 警告框中信息有外链123456&lt;div class="alert alert-info" role="alert"&gt; &lt;strong&gt;Heads up!&lt;/strong&gt; This &lt;a href="#" class="alert-link"&gt;alert needs your attention&lt;/a&gt; , but it's not super important.&lt;/div&gt; 进度条 基本款 1234&lt;div class="progress"&gt; &lt;div class="progress-bar" style="width:40%"&gt; &lt;/div&gt;&lt;/div&gt; 彩色 progress-bar-success progress-bar-info progress-bar-warning progress-bar-danger 带条纹的进度条 progress-striped 123&lt;div class="progress progress-striped"&gt; &lt;div class="progress-bar progress-bar-success" style="width:40%"&gt;&lt;/div&gt;&lt;/div&gt; 动态的进度条 123&lt;div class="progress progress-striped active"&gt; &lt;div class="progress-bar progress-bar-success" style="width:40%"&gt;&lt;/div&gt;&lt;/div&gt; 层叠进度条 123456&lt;div class="progress"&gt; &lt;div class="progress-bar progress-bar-success" style="width:20%"&gt;&lt;/div&gt; &lt;div class="progress-bar progress-bar-info" style="width:20%"&gt;&lt;/div&gt; &lt;div class="progress-bar progress-bar-warning" style="width:30%"&gt;&lt;/div&gt; &lt;div class="progress-bar progress-bar-danger" style="width:15%"&gt;&lt;/div&gt;&lt;/div&gt; 带label 的进度条 123&lt;div class="progress"&gt; &lt;div class="progress-bar progress-bar-success" role="progressbar" aria-valuenow="20" aria-valuemin="0" aria-valuemax="100" style="width:20%"&gt;20%&lt;/div&gt; &lt;/div&gt; 列表组 基础 1234567&lt;ul class="list-group"&gt; &lt;li class="list-group-item"&gt;揭开CSS3的面纱&lt;/li&gt; &lt;li class="list-group-item"&gt;CSS3选择器&lt;/li&gt; &lt;li class="list-group-item"&gt;CSS3边框&lt;/li&gt; &lt;li class="list-group-item"&gt;CSS3背景&lt;/li&gt; &lt;li class="list-group-item"&gt;CSS3文本&lt;/li&gt;&lt;/ul&gt; 自定义 1234567891011&lt;h3&gt;自定义列表组&lt;/h3&gt;&lt;div class="list-group"&gt; &lt;a href="##" class="list-group-item"&gt; &lt;h4 class="list-group-item-heading"&gt;图解CSS3&lt;/h4&gt; &lt;p class="list-group-item-text"&gt;详细讲解了选择器、边框、背景、文本、颜色、盒模型、伸缩布局盒模型、多列布局、渐变、过渡、动画、媒体、响应Web设计、Web字体等主题下涵盖的所有CSS3新特性...&lt;/p&gt; &lt;/a&gt; &lt;a href="##" class="list-group-item"&gt; &lt;h4 class="list-group-item-heading"&gt;Sass中国&lt;/h4&gt; &lt;p class="list-group-item-text"&gt;致力于为中国开发者提供最全面，最具影响力，最前沿的Sass相关技术与教程...&lt;/p&gt; &lt;/a&gt;&lt;/div&gt; 凸显 可以active 在list-group-item后加 也可以带徽章 1234567891011121314151617&lt;ul class="list-group"&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;13&lt;/span&gt;揭开CSS3的面 &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;456&lt;/span&gt;CSS3选择器 &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;892&lt;/span&gt;CSS3边框 &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;90&lt;/span&gt;CSS3背景 &lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;span class="badge"&gt;1290&lt;/span&gt;CSS3文本 &lt;/li&gt;&lt;/ul&gt; 也可以设置多种颜色的列表 list-group-item-success list-group-item-info list-group-item-warning list-group-item-danger 面板 基础面板 可以去掉panel-heading panel-footer 只留panel-body 12345&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;图解css&lt;/div&gt; &lt;div class="panel-body"&gt;详细讲解了选择器、边框、背景、文本、颜色、盒模型、伸缩布局盒模型、多列布局、渐变、过渡、动画、媒体、响应Web设计、Web字体等主题下涵盖的所有CSS3新特性&lt;/div&gt; &lt;div class="panel-footer"&gt;作者：may&lt;/div&gt;&lt;/div&gt; 多种颜色面板 加载最外层div上 panel-primary panel-success panel-info panel-warning panel-danger 面板中可以嵌套表格也可以嵌套列表组 弹出窗modal 要引入bootstrap-modal.js 1234567891011121314151617&lt;div class="modal" id="mymodal"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;span class="sr-only"&gt;Close&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title"&gt;模态弹出窗标题&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;p&gt;模态弹出窗主体内容&lt;/p&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="button" class="btn btn-primary"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;&lt;/div&gt; 12345$(function () &#123; $(".btn").click (function () &#123; $("#mymodal").modal("toggle"); &#125;)&#125;) - modal-dialog 水平居中 - modal-header 包括头部和关闭按钮 - modal-body 弹出的内容页 - modal-footer 操作的按钮 - show 在最外层div增加默认显示 通过data-target 实现触发 12345678910111213141516171819&lt;button class="btn btn-primary" data-toggle="modal" data-target="#mymodal-data" type="button"&gt;通过data-target触发&lt;/button&gt;&lt;!-- 模态弹出窗内容 --&gt;&lt;div class="modal" id="mymodal-data" tabindex="-1" role="dialog" aria-labelledby="mySmallModalLabel" aria-hidden="true"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;span class="sr-only"&gt;Close&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title"&gt;模态弹出窗标题&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;p&gt;模态弹出窗主体内容&lt;/p&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="button" class="btn btn-primary"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 通过a触发 123456789&lt;a data-toggle="modal" href="#mymodal" class=" btn btn-primary" &gt;点击我会弹出模态弹出窗&lt;/a&gt;&lt;!-- 模态弹出窗 --&gt;&lt;div class="modal fade" id="mymodal" &gt; &lt;div class="modal-dialog" &gt; &lt;div class="modal-content" &gt; &lt;!-- 模态弹出窗内容 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 通过js触发 12345$(function()&#123; $(".btn").click(function()&#123; $("#mymodal").modal(); &#125;);&#125;); js触发参数定义 1234567$(function()&#123; $(".btn").click(function()&#123; $("#mymodal").modal(&#123; keyboard:false &#125;); &#125;);&#125;); 12345$(function()&#123; $(".btn").click(function()&#123; $("#mymodal").modal("toggle"); &#125;); &#125;); 事件模拟 123$('#myModal').on('hidden.bs.modal', function (e) &#123; // 处理代码...&#125;) modal可以调节尺寸 和modal-dialog一个层 modal-dialog modal-sm modal-lg 还可以调节modal背景遮罩的大小样式.modal-backdrop 动画过渡要引入bootstrap-transition.js 增加fade 增加渐变的的动画 1234567891011121314151617&lt;div class="modal fade" id="mymodal"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;span class="sr-only"&gt;Close&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title"&gt;模态弹出窗标题&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;p&gt;模态弹出窗主体内容&lt;/p&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="button" class="btn btn-primary"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你不知道的JavaScript]]></title>
      <url>%2F2017%2F05%2F30%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%2F</url>
      <content type="text"><![CDATA[终于看完，看的很是慢！！！真的很好助眠 ！！！ 第一章 作用域是什么编译原理传统的编译语言的流程中，程序经历三个步骤 分词/词法分析 这个过程将字符组成的字符串分解成有意义的代码块，这些代码块成为词法单元 分词和词法分析之间的差异主要在于词法单元的识别是通过有状态还是无状态的方式进行的，有状态就是词法分析 解析/语法分析 将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树 代码生成 将AST转换为可执行代码的过程 javascript引擎不会有大量的时间进行优化，与其他语言不通，编译的过程不放生在构建之前，它的引擎用尽办法保证性能 而js的引擎要不比传统的编译复杂，例如还要在语法和代码生成阶段进行优化，包括冗余代码的优化等等,它会在代码执行前对代码进行编译，做好执行的准备 理解作用域 引擎 从头到尾负责 js程序的编译以及执行过程 编译器 引擎的朋友之一，负责词法分析和代码生成等 作用域 负责收集并维护有所有声明的标识符组成的一系列查询，确认当前的代码对标识符的访问权限 当看到 var a = 2 引擎认为是两个完全不同的声明，一个由编译器在编译时处理，另一个有引擎在运行时处理 编译器会做如下处理 1 遇到 var a,编译器会询问作用域是否已经有同样名称的变量存在同一个作用域的集合中，如果存在则忽略，否则要求作用域在当前作用域的集合中声明一个新的变量，命名为 a 2 编译器会为引擎生成所需的代码，这些来代码被用来处理 a = 2的赋值操作。引擎运行时会首先询问作用域，当前的作用域集合是否在一个叫做a的变量，如果是，引擎就会使用这个变量，如果否，引擎会继续查找该变量 如果最终找到即赋值，否则跑出异常 简单来说 首先编译器会在当前作用域声明一个变量，然后运行时引擎会在该作用域查找变量，如果找到进行赋值操作，没有找到抛出异常 LHS查询 当左侧出现变量的赋值操作，试图找到变量的容器本身，从而可以对其赋值 RHS查询当右侧出现赋值操作，简单的查找某个变量的值 12345function foo (a) &#123; console.log(a)&#125;foo(a); 最后一行的foo函数调用需要对foo进行RHS代码中隐式的 a = 2 是LHS查询而console.log(a) 中的 a进行的是RHS操作 作用域嵌套当一个块或者函数嵌套在另一个块或函数中，就发生了作用域的嵌套，当前作用域无法找到这个变量时，引擎就会在外层嵌套的作用域中继续查找，知道找到该变量或者抵达最外层的作用域为止 异常之所以区分LHS和RHSRHS查找无法找到变量的时候，引擎会抛出ReferenceError异常当引擎执行LHS查找，在非严格模式下，如果没有找到，全局作用域中就会创建一个具有该名称的变量，并将其返回给引擎 词法作用域作用域有两种主要的工作模型 普遍的 动态作用域 词法阶段词法化对源代码进行检查，如果是有状态的解析过程，还会赋予单词语义 词法作用域定义在此法阶段的作用域 没有任何函数可以部分地同事出现在两个父级函数中 在查找的过程中，作用域会在找到第一个匹配的标识符时停止，全局变量会自动成为全局对象，可以不直接通过全局对象的词法名称，而是间接的通过对全局对象的属性进行访问window.a但非全局的变量，如果屏蔽了，就无论如何都无法访问到 欺骗词法欺骗词法作用域会导致性能的下降 eval 插入的代码会修改当前词法作用域的环境，会被当做本来就在那里的一样来处理，eval都可以在运行期修改书写期的词法作用域 但是在严格模式下，运行eval()它无法修改词法作用域 1234567function foo(str, a) &#123; eval(str); console.log(a, b)&#125;var b = 2;foo("var b = 3;", 1); // 1, 3 with with通常当做重复引用同一个对象中的多个属性的快捷方式，不需要重复引用对象本身 123456789var obj = &#123; a:1, b:2, c:3&#125;;obj.a = 2;obj.b = 3;obj.c = 4; 12345with(obj) &#123; a = 2; b = 3; c = 4;&#125; 1234567891011121314151617181920function foo(obj) &#123; with(obj) &#123; a = 2; &#125;&#125;;var o1 = &#123; a: 3&#125;var o2 = &#123; b:3&#125;;foo( o1 );console.log(o1.a); //2foo(o2);console.log(o2.a) // undefinedconsole.log(a); // 2 a倍泄露到全局作用域上了 尽管with可以将一个没有或者有多个属性的对象处理为一个完全隔离的词法作用域，但是块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到width函数所在的作用域中 小结 eval函数如果接受了含有一个或者多个代码，就会修改其所在的词法作用域with声明实际是根据你传递给他的对象凭空创建了一个全系你的词法作用域 性能 在编译的时候 如果引擎发现了eval或with因为无法判断词法分析阶段会受到什么代码，因此之前的性能修改完全没有任何意义 函数作用域和块作用域函数中的作用域属于这个函数的全部变量都可以在整个函数的范围内使用及复用 隐藏内部实现 私有化从缩写代码中挑选出任意的片段，然后对函数声明对它进行包装，实际上就把这些代码隐藏起来了这样将某些方法和属性私有化 避免同名之间的冲突 在全局作用域中声明一个足够独特的变量，这个变量通常是个对象，暴露给外界的功能将成为这个属性的对象 模块管理 通过依赖管理器的机制将库的标识符显式的导入到另外一个特定的作用域中 函数的作用域在声明一个函数foo()意味着foo这个名称本身污染了所在作用域，而且必须显式的通过函数名来调用函数才能运行 包装函数，函数会被当做函数表达式而不是一个标准的函数声明来处理 123(function () &#123; console.log(1);&#125;)(); 区别函数声明和表达式最简单的方法是看function关键字出现在声明中的位置，如果是function是声明的第一个词就是函数声明，否则是表达式 匿名和具名 123setTimeout(function () &#123; console.log('i waited 1 second')&#125;, 1000); 函数表达式中，函数名字可以匿名，但是函数声明中，名字不可忽略 匿名函数的缺点 不会显示出有意义的函数名，使得调试很困难 当需要引用函数本身时，只能引用 arguemnts.callee 省略了对代码的可读性 行内函数表达式匿名和具名区别不大，不会有任何影响 立即执行函数表达式1234567(function (a) &#123; console.log(a);&#125;)(1)(function (a) &#123; console.log(a)&#125;(1)) 由于函数被包含在一对括号内，因此成为一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，第一个括号将函数变成表达式，第二个括号执行这个函数 以上两种写法都可以 块作用域 with从对象中创建出的作用域仅在with声明中而非外部作用域中有效 try/catch 声明变量仅在catch内部有效 let 可以将变量绑定到任意所在作用域，使用let不会在块作用域中进行提升 可以清楚的告诉引擎那些变量可以垃圾回收 let循环，确保使用上一个循环迭代结束时的值进行重新赋值 let声明附属一个新的作用域而不是当前的函数作用域 const 创建块作用域不安了，其值是固定常量，之后的任何修改都会引起错误 函数是js中最常见的作用域单元，但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块 提升代码执行顺序123 a = 2 var a;console.log(a); //2 等于 123 var a;a = 2;console.log(a); 12console.log(a); // undefinedvar a = 2; 等于 1234 var a;console.log(a);a = 2; 先有声明，后赋值,也就是说声明本身会被提升，而赋值或者其他逻辑会留在原地 函数声明会被提升，但函数表达式不会被提升 12foo(); // 不是ReferenceError，而是TypeErrorvar foo = function bar () &#123;&#125; 即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用 123456foo(); //TypeErrorbar(); //ReferenceErrorvar foo = function bar () &#123; &#125; 等于 123456 var foo;foo();bar();foo = function() &#123; &#125; 函数优先 函数声明和变量声明都会被提升，函数会首先被提升，然后才是变量 12345678foo(); //1var foo;function foo() &#123; console.log(1);&#125;foo = function () &#123; console.log(2)&#125; 尽管 var foo 在 function foo() ..声明之前，但是是重复声明，函数声明会被提升到普通变量之前 多个函数声明，后者会覆盖前者 123456789foo(); //3function foo() &#123; console.log(1)&#125;function foo() &#123; console.log(3);&#125; 小结 var a = 2 当做两个单独的声明，一个是编译极端，一个是执行阶段 声明本身会被提升，而包括函数表达式的赋值内的赋值操作不会提升 作用域闭包启示闭包是基于词法作用域书写代码时所产生的自然结果 实质问题1234567891011function foo () &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var bar = foo();bar(); //2 foo()执行以后，通常期待 整个内部作用域被销毁因为引擎有垃圾回收器来释放不再使用的内存空间。而闭包可以阻止垃圾回收， bar()所声明的位置涵盖 foo()内部作用域的闭包，使作用域一直存货，以供 bar()在任何时间进行引用 bar()对该作用域的引用，这个引用就叫闭包 闭包可以使函数可以继续访问定义时的词法作用域 12345678910111213function foo () &#123; var a = 2; function baz() &#123; console.log(a); //2 &#125; bar (baz)&#125;function bar (fn) &#123; fn(); // 闭包&#125;foo(); //2 12345678910111213141516var fn;function foo() &#123; var a = 2; function baz() &#123; console.log(a); &#125; fn = baz; // 将baz分配给全局变量&#125;function bar() &#123; fn(); // 闭包&#125;foo();bar(); //2 无论通过何种手段将内部函数传递到所在的词法作用域外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包 我懂了12345678function wait(message) &#123; setTimeout( function timer() &#123; console.log(message); &#125;, 1000);&#125;wait('Hello, closure!') wait()执行1000毫秒后，他的内部作用域并不会消失，函数依然保有wait作用域的闭包 12345678function setupBot(name, selector) &#123; $(selector).click(function activator() &#123; console.log("activating:" + name); &#125;)&#125;setupBot("Closure Bot 1", "#bot_1");setupBot("Closure Bot 2", "#bot_2"); 循环和闭包12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000);&#125; 我们希望分别输出1-5，每秒一次但是实际上代码会以每秒一次的频率输出五次6 为什么？延迟函数的回调会在循环结束时才执行，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出6出来这段代码的缺陷是我们试图假设循环中每词捕获一个i的副本，但是作用域的工作原理，尽管循环五次在各个迭代中分别定义的，但是他们被密封在一个共享的全局作用域中，实际上只有一个i 使用立即执行函数，每次创建新的作用域 1234567for (var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, i*1000) &#125;)(i)&#125; 块作用域，每次创建一个块作用域 12345for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function timer() &#123; console.log(i) &#125;, i * 1000)&#125; 模块1234567891011121314151617181920function CoolModule() &#123; var something = 'cool'; var another = [1,2,3]; function doSomething () &#123; console.log(something) &#125; function doAnother() &#123; console.log( another.join('!')); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1!2!3 CoolModule是一个函数，必须通过调用来创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建 CoolModule返回一个对象字面量语法来表示对象。这个返回的对象中含有对内部函数而不是内部数据的变量引用。保证私有的状态 模块需要具备的两个必要条件 必须有外部的封闭函数，函数至少被调用一次 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且访问或者修改私有的状态 只有数据属性而没有闭包函数的对象并不是真正的模块 模块函数转为立即执行函数,模块作为普通函数，接受参数 123456789101112131415function CoolModule(id) &#123; function identify() &#123; console.log(id) &#125; return &#123; identify: identify &#125;&#125;var foo1 = CoolModule("foo 1");var foo2 = CoolModule("foo 2");foo1.identify(); // "foo 1"foo2.identify(); // "foo 2" 1234567891011121314151617181920212223var foo = (function CoolModule(id) &#123; function change() &#123; publicAPI.identify = identify2; &#125; function identify1() &#123; console.log(id); &#125; function identify2() &#123; console.log(id.toUpperCase()); &#125; var publicAPI = &#123; change: change, identify: identify1 &#125;&#125;)("foo module");foo.identify(); // foo modulefoo.change();foo.identify()// FOO MODULE 现代的模块机制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var myModule = (function Manger() &#123; var modules = &#123;&#125;; function define(name, deps, impl) &#123; for (var i = 0; i &lt; deps.length; i++ ) &#123; deps[i] = modules[deps[i]]; &#125; modules[name] = impl.apply(impl, deps); // 为模块定义引入了包装函数，将返回值存在一个模块列表中 &#125; function get(name) &#123; return modules[name]; &#125; return &#123; define: define, get: get &#125;&#125;)();myModule.define('bar',[], function() &#123; function hello(who) &#123; return 'let me introduce:' + who; &#125; return &#123; hello: hello &#125;&#125;)myModule.define('foo', ['bar'], function(bar) &#123; var hungry = 'hippo'; function awesome() &#123; console.log(bar.hello(hungry).toUpperCase()); &#125; return &#123; awesome: awesome &#125; &#125;)var bar = myModule.get('bar');var foo = myModule.get('foo');console.log( bar.hello('hippo')) // let me introduce: hippofoo.awesome(); // LET ME INTRODUCE: HIPPO 未来的模块机制而是ES6bar.js12345function hello (who) &#123; return "let me introduce:" + who;&#125;export hello; foo.js12345678import hello from "bar";var hungry = 'hippo';function awesome() &#123; console.log( hello(hungry).toUpperCase());&#125;export awesome; baz.js12345678import foo from "foo";import bar from "bar";console.log( bar.hello("huimin")) // Let me introduce: huiminfoo.awesome(); //LET ME INTRODUCE: HUIMIN 小结 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这就产生了闭包 模块的两个主要特征 为创建内部作用域而调用一个包装函数 包装函数的返回值必须至少包含一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包 附录——动态作用域词法作用域是关于引擎如何寻找变量以及何处找到变量的规则 作用域链是基于调用栈，而不是代码中的作用域嵌套 123456789101112function foo() &#123; console.log(a);&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); //2 词法作用域实在些代码或者说定义时确定的，而动态作用域实在运行时确定的 附录 this词法箭头函数可以取代当前的词法作用域覆盖了this本来的值 123456789101112var obj = &#123; id: 'cool', cool: function coolFn() &#123; console.log(this.id); &#125;&#125;;var id = 'not cool';obj.cool(); // coolsetTimeout(obj.cool, 100); // not cool cool函数丢失了同this之间的绑定 如何解决？ 箭头函数 bind 关于this误解 指向自身 1234567891011121314151617181920function foo (num) &#123; console.log("foo:" + num); this.count++;&#125;foo.count = 0;for (var i = 0; i &lt; 10; i++) &#123; if(i &gt; 5) &#123; foo(i) &#125;&#125;// foo:6// foo:7// foo:8// foo:9console.log(foo.count)// 0 由此证明它并不指向自身 解决可以使用foo来代替this 1234567891011121314151617181920function foo (num) &#123; console.log("foo:" + num); foo.count++;&#125;foo.count = 0;for (var i = 0; i &lt; 10; i++) &#123; if(i &gt; 5) &#123; foo(i) &#125;&#125;// foo:6// foo:7// foo:8// foo:9console.log(foo.count)// 0 强制this指向foo函数 1234567891011121314function foo(num) &#123; console.log("foo:" + num); this.count++;&#125;foo.count = 0;for(var i = 0; i &lt; 10; i++) &#123; if(i &gt; 5) &#123; foo.call(foo, i); // 确保this指向函数对象foo本身 &#125;&#125; this指向函数的作用域 this在任何情况下都不指向函数的词法作用域 12345678910function foo() &#123; var a = 2; this.bar();&#125;function bar () &#123; console.log(this.a)&#125;foo() // a is not defined 不能使用this来引用一个词法作用域内部的东西 this是什么this是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件 小结 this机不指向函数自身也不指向函数的词法作用域this实际上是在函数被调用时发生的绑定，指向什么完全取决于函数在哪里被调用 this全面解析调用位置分析调用栈 12345678910111213141516171819function baz () &#123; // 当前调用栈是： baz 调用位置是全局作用域 console.log("baz"); bar()&#125;function bar() &#123; // 当前调用栈是baz -&gt; bar console.log("bar"); foo();&#125;function foo() &#123; // 当前调用栈是baz -&gt; bar -&gt; foo console.log("foo")&#125;baz(); 绑定规则默认绑定1234567function foo() &#123; console.log(this.a);&#125;var a = 2; foo(); //2 函数调用时默认绑定全局对象，但是如果使用严格模式，全局对象将无法使用默认绑定，报错undefined 隐式绑定调用位置的上下文，或者看是否被某个对象拥有或者包含 1234567891011function foo () &#123; console.log(this.a);&#125;var obj = &#123; a : 2, foo: foo&#125;;obj.foo(); //2 调用位置使用obj的上下文引用函数，是一种包含关系。也是隐式绑定，会把函数调用中的this绑定到obj这个对象上 如果是多层包含关系,引用的是最后一层的 123456789101112131415function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo: foo&#125;var obj1 = &#123; a: 2, obj2: obj2&#125;obj1.obj2.foo() //42 隐式丢失 函数调用 1234567891011function foo () &#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;var bar = obj.foo; // 函数别名var a = "oops,global"; //a是全局对象bar(); // "oops,global" bar()是一个函数调用，因此应用默认绑定 参数传递 123456789101112131415function foo () &#123; console.log(this.a);&#125;function doFoo(fn) &#123; fn(); &#125;var obj = &#123; a: 2, foo: foo&#125;var a = 'oops,global'; //doFoo(obj.foo) // "oops,global" 参数传递就是一种隐式赋值，和上面例子一样 传入语言内置的函数 123456789101112function foo() &#123; console.log(this.a);&#125;var obj = &#123; a:2, foo: foo&#125;;var a = "oops, global"; // a是全局对象的属性setTimeout(obj.foo, 100); // "oops,global" 显示绑定 apply call123456789function foo() &#123; console.log(this.a);&#125;var obj = &#123; a:2&#125;;foo.call(obj); //2 显示绑定也无法解决绑定丢失的问题 硬绑定 123456789101112131415function foo () &#123; console.log(this.a);&#125;var obj = &#123; a:2&#125;;var bar = function () &#123; foo.call(obj);&#125;;bar(); //2setTimeout(bar, 100); //2bar.call(window); //2 硬是绑定不可以在修改其他this 应用场景 创建一个包装函数，传入所有的参数并返回接收到的所有制 123456789101112function foo(something) &#123; console.log( this.a, something ); return this.a + something;&#125;var obj = &#123; a:2&#125;;var bar = function() &#123; return foo.apply( obj, arguments );&#125;;var b = bar( 3 ); // 2 3console.log( b ); // 5 创建一个可重复使用的辅助函数 1234567891011121314151617181920function foo (something) &#123; console.log(this.a, something); return this.a + something;&#125;function bind(fn, obj) &#123; return function () &#123; return fn.apply(obj, arguments) &#125;&#125;var obj = &#123; a:2&#125;var bar = bind(foo, obj);var b = bar(3); //2 3console.log(b); //5 ES5中内置了bind方法 1234567891011121314function foo(something) &#123;console.log( this.a, something );return this.a + something;&#125;var obj = &#123; a:2&#125;;var bar = foo.bind(obj);var b = bar(3); //2 3console.log(b) // 5 foreach 1234567891011function foo (el) &#123; console.log(el, this.id)&#125;var obj = &#123; id: 'awesome'&#125;;[1,2,3].forEach(foo, obj);// 1 awesome 2 awesome 3 awesome new绑定构造函数只是一些使用new操作符时被调用的函数，不属于某个类，也不会实例化一个类 使用new来调用函数，会执行以下操作 创造一个全新的对象 新对象会执行 [[原型]] 连接 这个新对象会绑定到函数调用this 如果函数没有返回其他对象，那么new表达式中的函数会自动返回这个新对象 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); //2 使用new调用foo,会构造一个新对象将其绑定在foo的this上 优先级默认的绑定优先级最低 显示绑定 &gt; 隐式绑定 new绑定 &gt; 隐式绑定 判断this 1 函数是否在new中调用? 如果是 this的绑定是新创建的对象2 函数是否通过 call apply调用? 如果是this绑定制定对象3 函数是否在某个上下文对象中调用?如果是就是this绑定的上下文对象4 如果都不是某人绑定，严格模式undefined 绑定例外被忽略的this如果把null或undefined作为this的绑定对象闯入call、apply、bind.调用会被忽略 null 常用来展开一个数组，并当做参数传入一个函数 12345678function foo(a, b) &#123; console.log( "a:" + a + ", b:" + b)&#125; foo.apply(null, [2, 3]); //a:2. b:3var bar = foo.bind(null, 2);bar(3); // a:2, b:3 也可以用一个特殊对象 123456789function foo(a,b) &#123;console.log( "a:" + a + ", b:" + b );&#125; // 我们的 DMZ 空对象var ø = Object.create( null );// 把数组展开成参数foo.apply( ø, [2, 3] ); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( ø, 2 );bar( 3 ); // a:2, b:3 间接引用无意间创建函数的间接引用，这种情况下，调用这个函数会应用默认绑定规则 12345678910function foo () &#123; console.log(this.a);&#125;var a = 2;var o = &#123;a: 3, foo: foo&#125;;var p = &#123;a: 4&#125;;o.foo(); //3(p.foo = o.foo)() // 2 p.foo = o.foo的返回值是目标函数的引用，调用这个函数会默认绑定规则 软绑定1234567891011if(!Function .prototype.softBind) &#123; Function.prototype.softBind = function (obj) &#123; var fn = this; var curried = [].slice.call(arguments,1); var bound = function () &#123; return fn.apply( (!this || this === (window || global)) ? obj : this, curried.concat.apply(curried, arguments)); &#125; bound.prototype = Object.create( fn.prototype); &#125;&#125; 123456789101112131415161718 function foo () &#123; console.log("name" + this.name); &#125; var obj = &#123;name: 'obj'&#125;, obj2 = &#123;name: 'obj2'&#125;, obj3 = &#123;name: 'obj3'&#125;;var fooOBJ = foo.softBind(obj);fooOBJ(); //name: objobj2.foo = foo.softBind(obj)obj2.foo(); //name: obj2fooOBJ.call(obj3); //name:obj3 setTimeout(obj2.foo, 10); //name: obj this 词法 箭头函数 1234567891011121314151617 function foo () &#123; return (a) =&gt; &#123; console.log(this.a); &#125; &#125; var obj1 = &#123; a: 2 &#125; var obj2 = &#123; a: 3&#125;var bar = foo.call(obj1);bar.call(obj2); //2 箭头函数的绑定无法被修改 常用于回调函数 1234567891011 function foo() &#123; setTimeout(() =&gt; &#123; console.log(this.a) &#125;, 100) &#125; var obj = &#123; a:2 &#125;;foo.call(obj); //2 小结 this绑定，需要找到函数的直接调用位置 1 new是否调用 绑定到新创建的对象 2 是否用call apply 绑定到指定对象 3 上下文调用 4 默认 箭头函数不会使用四条标准绑定规则，而是根据当前的词法作用域来决定this绑定 对象语法123var myObj = &#123; key: value&#125;; 12var myObj = new Object();myObj.key = value; 类型六中类型 string number boolean null undefined object 除object外都是简单基本类型js中并不是万物皆对象 js中还有一些对象是内置对象 string number boolean object function array Date RegExp Error typeof是一个一元运算，放在一个运算数之前，运算数可以是任何类型 instanceof 用于判断一个变量是否是某个对象的实例 123var str = "hello";typeof str; // "string"str instanceof String; // false 123var strObj = new String("I am a string");typeof strObject; // objectstrObj instanceof String; // true 内容123456var myObject = &#123; a: 2&#125;myObject.a; //2myObject["a"]; //2 a语法通常被称为 属性访问[‘a’] 语法通常被称为 键访问这两周语法的区别在于，操作符属性满足标识符的命名规则，而键访问可以使用不是有效的标识符属性名 在对象中，属性名永远都是字符串 可计算属性名12345678var prefix = 'foo';var myObject = &#123; [prefix + 'bar']: hello, [prefix + 'baz']: 'world'&#125;myObject['foobar']; // hellomyObject['foobaz']; // world 属性与方法函数永远不会属于一个对象，对象内部的函数成为方法是不妥的，函数和对象的关系是间接关系 从属性中引用的函数会this被隐式绑定到一个对象 数组给数组增加命名属性，数组的length值并未发生变化1234var myArr = ['foo', 42, 'bar'];myArr.baz = 'bar';myArr.length; //3myArr.baz; // bar 但如果用一个数字，那么是字符串数字做下标，它会修改数组 1234var myArr = ['foo', 42, 'bar'];myarr['3'] = 'baz';myArr.length; //4myArr[3]; //baz 复制对象首先我们应该考虑是浅复制还是深复制 浅复制可以考虑es6的assign 123456789var myObject = &#123;a: 2&#125;;var newObject = Object.assign(&#123;&#125;,myObject);myObject.a = 3;console.log(newObject.a); //2 属性描述符123456789101112var myObject = &#123; a:2&#125;;console.log(Object.getOwnPropertyDescriptor(myObject, 'a'));// &#123;// value: 2,// writable: true,// enumerable: true,// confgurable: true// &#125; writable(可写) enumerable(可枚举) configurable(可配置) 在创建普通属性时描述符会使用默认值，也可以使用object.defineProperty（）来增加或者修改一个已有属性 123456789var myObject = &#123;&#125;;Object.defineProperty(myObject, 'a', &#123; value: 2, writable: true, configurable: true, enumerable: true&#125;);myObject.a; //2 writable 决定是否可以修改属性的值 configurable 决定属性是否可配置，是否可以使用defineProperty()方法来修改属性描述符，如果第一改成false ，后面再改成true会报错 它是单向操作，无法撤销 即使configurable为false它的值还是可以修改的，但是writable的状态由true改为false，但是无法false改为true，还会禁止删除这个属性。 enumerable 可枚举，对象属性的枚举比如 如果设置成false ,属性就不会出现在枚举中，设置成true 就会让这个属性出现在枚举中。 不变性 对象常量 var myObject = {}; Object.defineProperty( myObject, ‘FAVORITE’, { value: 42, writable: false, configurable: false}) 禁止扩展 禁止添加新属性并且保留已有的属性 Object.prevent.Extensions(…); 12345678var myObject = &#123; a: 2&#125;Object.preventExtensions(myObject);myObject.b = 3;myObject.b; //undefined 密封 Object.seal(…) 会创建一个密封的对象，实际会在一个现有对象上调用Object.preventExtensions()并把所有现有属性标记为configurable：false 密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有的属性 冻结 Object.freeze（…） 会创建一个冻结对象，这个方法实际上会调用Object.seal(…)并把所有数据访问标记为writable:false,这样就无法修改他们的值 get一次属性的访问，实际上就是实现了get操作，如果找到就返回该值，如果没有找到就返回undefined put给对象的属性赋值会触发put来设置或者创建这个属性 put操作还会检查 是否访问描述符？ 如果是且存在就调用setter writable是否是false? 如果是，非严格模式失败，严格模式爆异常 如果都不是，将该值设置为属性的值 getter和setter对象默认的put和get操作可以控制属性的设置和获取 123456789var myObject = &#123; get a() &#123; return 2; &#125;&#125;myObject.a = 3;console.log(myObject.a) //2 既然有合法的setter,由于我们定义的getter只会返回2，所以set操作是没有意义的。 setter会覆盖单个属性的默认操作 123456789101112var myObject = &#123; get a() &#123; return this._a; &#125;, set a(val) &#123; this._a = val * 2; &#125;&#125;myObject.a = 2;console.log(myObject.a) //4 存在性如何区分属性中存的undefined和属性不存在的undefined？ 123456789var myObject = &#123; a:2&#125;;('a' in myObject) //true('b' in myObject) //falsemyObject.hasOwnProperty('a'); //truemyObject.hasOwnProperty('b'); //false in 操作符会检查属性是否在对象以及原型链中 hasOwnProperty只会检查属性是否在myObject对象中，不会检查原型链 1Object.prototype.hasOwnProperty.call(myObject, 'a'); 12345Object.propertyIsEnumerable('a'); //trueObject.propertyIsEnumerable('b'); //falseObject.keys(myObject); // ['a']Object.getOwnPropertyNames(myObject); // ['a', 'b'] propertyIsEnumerable() // 判断枚举性 仅满足enumerable: true object.keys 会返回一个数组，包含所有可枚举属性 object.getOwnPropertyNames() 返回一个数组，包含所有属性无论是否可枚举 遍历for…in 实际遍历的是下标来指向值,遍历可枚举的的对象 所以增加了 forEach every some forEach 会遍历数组中所有值饼忽略回调函数的返回值 every会一直遍历除非回调返回false some会运行到回调函数返回true for…of 遍历数组直接遍历值而不是数组下标，如果不是数组需要自定义@@iterator对象并调用next()方法来遍历数据值。 123456789varmyArray = [1,2,3];for ( var v of myArray) &#123; console.log(v);&#125;// 1// 2// 3 混合对象类类理论js只有一些近似类的语法，在软件设计中类是一种可选的模式 类的机制类的继承先定义一个类，然后定义一个继承前者的类后者成为子类，前者是父类 多态 子类重写了继承自父类的方法，但是重写的方法里面调用了父类的方法，这种技术叫做多态或者虚拟多态或者相对多态 123456789101112131415class Vehicle &#123; engines = 1 drive() &#123; ignition(); output('lalalala'); &#125;&#125;class Car inherites Vehicle &#123; wheels = 4; dirve() &#123; inherited:drive() output('lalallal222222') &#125;&#125; 子类对集成到的一个方法的重写不会影响父类中的方法子类的导师父类的一份副本，类的继承其实就是复制 多重继承 js 没有多重继承的功能，但是很多人为了实现多重继承，会用到混入 混入js开发者模拟类的复制行为，这个方法就是混入分显示和隐式 显示混入遍历sourceObj 如果targetObj没有这个属性就会进行复制 123456789101112131415161718192021222324252627function mixin (sourceObj, targetObj) &#123; for (var key in sourceObj) &#123; if(!(key in targetObj)) &#123; target[key] = sourceObj[key]; &#125; &#125; return targetObj;&#125;var Vechicle = &#123; engines: 1, igntion: function() &#123; console.log('Turning on my engine'); &#125;, drive: function () &#123; this.ignition(); console.log('Steering and moving forward!') &#125;&#125;var Car = mixin(Vechicle, &#123; wheels: 4, dirve: function () &#123; Vechicle.drive.call(this); // 显示多态 console.log('Rolling on all' + this.wheels + 'wheels!') &#125;&#125;) 多态的引入会极大的增加维护成本，此外，显示伪多态可以模拟多重继承，会进一步增加代码的复杂度和维护度 混合复制 如果mixin不判断targetObj有没有这个属性，都会复制到targetObj对象里面，会不小心覆盖目标对象原有属性 1234567891011121314151617function mixin(sourceObj, targetObj) &#123; for (var key in sourceObj) &#123; targetObj[key] = sourceObj[key]; &#125; return targetObj&#125;var Vehicle = &#123;&#125;;var Car = mixin(Vehicle, &#123;&#125;);mixin( &#123; wheels: 4, dirive; function () &#123;&#125;&#125;, car) 只有在能够提高代码可读性的前提下使用显示混入，避免使用增加代码理解难度 寄生继承 复制一份Vehicle父类的对象，然后混入子类对象的定义，然后使用这个符合对象的构建实例 123456789101112131415161718192021222324252627function Vehicle() &#123; this.engines = 1;&#125;Vehicle.prototype.ignition = function () &#123; console.log(111);&#125;Vehicle.prototype.drive = function () &#123; this.ignition(); console.log('2222');&#125;function Car () &#123; var car = new Vehicle(); // 复制 car.wheels = 4; var vehDrive = car.drive; car.drive = function () &#123; vehDrive.call(this); console.log('3333333333333'); &#125; return car;&#125;var myCar = new Car(); 隐式混合1234567891011121314151617181920var Something = &#123; cool:function () &#123; this.greeting = 'hello world'; this.count = this.count ? this.count + 1 : 1; &#125;&#125;;Something.cool();Something.greeting; // 'Hello World'Something.count; //1var Another = &#123; cool: function () &#123; Something.cool.call(this); // 隐式混入 &#125;&#125;Another.cool();Another.greeting; // 'Hello World'Another.count; //1 不是共享状态 小结 类意味复制 类被继承时，行为也会被复制到子类中 看起来是从子类引用到父类，但是本质上引用的其实是复制的结果 混入模式可以用来模拟复制行为，但会产生脆弱丑陋的语法 显示混入无法完全模拟类的复制行为 原型prototype所有的对象在创建时 prototype属性都会被赋予一个非空的值 如果无法在对象本身找到需要的属性，就会继续访问对象的 prototype链 for … in 遍历对象原理和查找prototype链类似，任何可以通过原型链访问到的属性都会被枚举 123456789var antherObject = &#123; a: 2&#125;var myObject = Object.create(antherObject);for ( var k in myObject) &#123; console.log('food:' + k);&#125;// found: a object.prototype所有的普通 prototype链注重都会指向内置的Object.prototype 属性设置和屏蔽1myOnject.foo = 'bar' 如果在 prototype链的上层存在名为foo的普通数据访问属性没有被标记制度，那么会在myObject中添加一个名为foo的心属性，他是屏蔽属性 如果 prototype链上层存在foo, 被标记为只读（writable: false）那么无法修改已有属性或者myObject 如果 prototype 链上层存在foo并且它是一个setter,那就一定会调用这个setter. foo不会被添加到myObject，也不会重新定义foo这个setter 当遇到二三情况的时候可以使用Object.defineProperty来向myObject添加foo 只读false属性会阻止链下层隐式创建同名属性，这样主要为了模拟类属性的继承 12345678910111213141516var anotherObject = &#123; a: 2&#125;;var myObject = Object.create( anotherObject );anotherObject.a; //2myObject.a; //2anotherObject.hasOwnProperty('a'); //true;myObject.hasOwnProperty('a'); //falsemyObject.a++; //隐式屏蔽anotherObject.a; //2myObject.a //3myObject.hasOwnProperty('a'); //true 类js中只有对象 ‘类’函数Object.getPrototype(object) //返回对象的原型 12345function Foo() &#123;&#125;var a = new Foo(); // a内部的prototype 关联到Foo.prototype指向的对象Object.getPrototypeOf(a) === Foo.prototype; //true new并没有直接创建关联，它只是关联到其他对象的新对象 继承意味着复制操作，js并不会复制对象属性，而是创建一个关联 构造函数12345678function Foo () &#123; &#125;Foo.prototype.constructor === Foo; //truevar a = new Foo();a.constructor === Foo //true constructor指向构造他的函数 new 后面第一个首字母大写 技术Foo.prototype的.constructor属性时Foo函数在声明时的默认属性，如果你创建一个新对象并替换了函数默认的prototype对象引用，那么新对象并不会自动获得constructor属性 123456function Foo() &#123;&#125;Foo.prototype = &#123;&#125;;var a1 = new Foo ();a1.constructor === Foo; //falsea1.constructor === Object; // true a1 没有 constructor 属性，所以会委托 prototype上的Foo.prototype 但是它也没有constructor属性，继续委托，委托给顶端的Object.prototype 而修复constructor需要很多手动操作 它是一个不可枚举的属性 （原型）继承如何把Bar.prototype 关联到Foo.prototype//需要抛弃Bar原有的prototypeBar.prototype = Object.create(Foo.prototype);//es6可以直接修改现有的Bar.prototypeObject.setPrototypeOf(Bar.prototype, Foo.prototype); 检查类的关系 1234567function Foo() &#123; &#125;Foo.prototype.blah = ...;var a = new Foo(); 对象a，如何找到a委托的对象 instanceof 1a instanceof Foo; //true 如果内置的.bind()函数来生成一个硬绑定函数，该函数没有prototype属性，函数使用instanceof,目标函数prototype会代替硬绑定的prototype 反射 1Foo.prototype.isPrototypeOf(a); // true a的整条prototype链中是否出现过Foo.prototype 也可以直接获取一个对象prototype链 Object.getPrototypeOf(a); Object.getPrototype(a) === Foo.prototype; //true a.proto === Foo.prototype; //true constructor和proto并不存在于珍重的使用对象中，而是内置在Object.prototype中 对象关联创建关联Object.create 会创建一个新对象并把它关联到我们指定的对象 Object.create(null) 会常见一个拥有空链接的对象，对象无法委托 关联关系是备用假如想调用myObject.cool但是myObject中不存在cool12345678910111213var anotherObject = &#123; cool: function () &#123; console.log('cool') &#125;&#125;var myObject = Object.create(anotherObject);myObject.doCool = function () &#123; this.cool(); //内部委托&#125;myObject.doCool(); // cool 小结 如果要访问对象中不存在的属性，就会查找对象内部 prototype关联的对象 js机制的核心不会复制，对象之间通过内部 prototype链关联 行为委托面向委托的设计类设计模式鼓励继承时使用方法重写和多态 委托理论1234567891011121314151617Task = &#123; setID: function (ID) &#123;this.id = ID;&#125;, outputID: function () &#123; console.log(this.id) &#125;; XYZ = Object.create(Task); XYZ.prepareTask = function (ID, Label) &#123; this.setId(ID); this.lebel = Label; &#125;; XYZ.outputTaskDetaild = function () &#123; this.outputId(); console.log(this.label); &#125;;&#125; 关联代码的不同之处 id和lablel数据成员都是直接存在XYZ上，而不是Task(委托目标) 在类的设计中故意让父类和子类都有outputTask这样可以利用重写的优势，而委托中应避免在不同级别中使用相同的命名 XYZ中的方法首先会寻找XYZ自身是否有setID,如果没哟，会通过委托关联到Task继续寻找 委托行为意味着XYZ找不到属性或者方法引用时会吧这个请求委托给另一个对象Task 委托最好在内部实现，不要直接暴露，调用XYZ.prepareTask() 相互委托禁止，会出错 调用 1234function Foo () &#123;&#125;var a1 = new Foo();a1; // Foo&#123;&#125; chrome Object&#123;&#125; firefox]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery回顾性学习]]></title>
      <url>%2F2017%2F04%2F19%2Fjquery%E5%9B%9E%E9%A1%BE%E6%80%A7%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[回顾性学习！ 选择元素123456&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 12345$('li:first').css('background', 'red'); // 选择第一个$('li:last').css('background', 'red'); // 选择最后一个$('li:eq(2)').css('background', 'red'); // 选择底三个$('li:event').css('background', 'red'); // 奇数行$('li:odd').css('background', 'red'); // 偶数行 筛选查 class = box 123456&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="box"&gt;&lt;/li&gt; &lt;li class="box"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 123$('li .box').css('background', 'red')$('li').filter('.box').css('background', 'red') 筛选出 title 123456&lt;ul&gt; &lt;li title="hello"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 1$('li').filter('[title=hello]').css('background', 'red'); 写法 方法函数化 链式操作 取值赋值合体 jq与js的关系 可以共用，但不能混用 常用方法has() 是否包含 attr() 对属性进行操作 filter() 对一组元素进行筛选， 满足条件留下来 not() 与filter正好相反 filter 和 not 针对的是当前自身的元素而针对的是包含关系的元素 next() 下一个元素的兄弟节点，同级关系prev() 下一个元素的兄弟节点 find() 1$('div').find('h2').css('background', 'red'); eq 下标的作用 1$('div').find('h2').eq(1).css('background', 'red'); index 索引 在所有兄弟节点之间的位置 123456&lt;h3&gt;&lt;/h3&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h3 id="h"&gt;&lt;/h3&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h3&gt;&lt;/h3&gt; 1alert($('#h').index()); // 2 编写选项卡原生 1234567891011121314151617window.onload = function () &#123; var odiv = document.getElementById('div1'); var aInput = odiv.getElementsByTagName('button'); var aCon = odiv.getElementsByTagName('div'); for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].index = i; aInput[i].onclick = function () &#123; for(var i = 0; i &lt; aCon.length; i++) &#123; aInput[i].className = ''; aCon[i].style.display = 'none'; &#125; this.className = 'active'; aCon[this.index].style.display = 'block'; &#125; &#125; &#125; 123456$('#div1').find('button').click(function () &#123; $('#div1').find('button').attr('class', ''); $('#div1').find('div').css('display', 'none'); $(this).attr('class', 'active'); $('#div1').find('div').eq($(this).index()).css('display', 'block'); &#125;) 常用方法 addClass() // 如果之前有，再添加重复的，它不会再添加 removeClass() // 删除class width() // 实际的宽 innerWidth() // 含实际宽+padding outerWidth() // 含实际宽+padding+border 没有margin outerWidth(true) // 含实际宽+padding+border+margin 插入位置的操作 insertBefore() // 将前面找到的元素放在后面元素的前面 对应before() 前 12&lt;div&gt;div&lt;/div&gt;&lt;span&gt;span&lt;/span&gt; 123$('span').insertBefore($('div'));// 相当于$('div').before($('span')); 后 12&lt;span&gt;span&lt;/span&gt;&lt;div&gt;div&lt;/div&gt; insertAfter() // 和inserBefore相反，前面的元素放在后面元素的后面 对应after() 前 12&lt;div&gt;div&lt;/div&gt;&lt;span&gt;span&lt;/span&gt; 123$('div').insertAfter($('span'));// 相当于$('span').after($('div')); 后 12&lt;span&gt;span&lt;/span&gt;&lt;div&gt;div&lt;/div&gt; appendTo() 等于 appendChild 对应append() 前12&lt;div&gt;div&lt;/div&gt;&lt;span&gt;span&lt;/span&gt; 123$('div').appendTo($('span'));// 相当于$('span').append($('div')); 后 1234&lt;span&gt; span &lt;div&gt;div&lt;/div&gt;&lt;/span&gt; prependTo() 对应prepend 前12&lt;div&gt;div&lt;/div&gt;&lt;span&gt;span&lt;/span&gt; 12345$('div').prependTo($('span'));// 相当于$('span').prependTo($('div')); 后 1234&lt;span&gt; &lt;div&gt;div&lt;/div&gt; span&lt;/span&gt; 区别 后续的操作变了 123$('span').insertBefore($('div')).css('background', 'red'); // span变红// 相当于$('div').before($('span')).css('background', 'red'); // div变红 remove() 删除节点 on() 事件的另外一种写法 可以针对自定义事件来触发 也可以针对多个事件 1234567$('div').click(function() &#123; console.log(1)&#125;);$('div').on('click mouseover', function() &#123; console.log(1)&#125;); // 可以针对自定义事件来触发 也可以针对多事件 // 鼠标点击是234 鼠标移入是 45612345678$('div').on(&#123; 'click': function() &#123; alert(234); &#125;, 'mouseover': function() &#123; alert(456); &#125;&#125;) off() 触发一次就取消 1234$('div').on('click', function() &#123; alert(123); $('div').off();&#125;) 1234$('div').on('click mouseover', function() &#123; console.log(1); $('div').off('mouseover'); // 可以针对其中的一个事件进行取消&#125;); strollTop() // 获取X轴滚动距离 编写弹窗1234567891011$('#login').click(function () &#123; var odiv = $('&lt;div class="modal1"&gt;1111111&lt;/div&gt;'); $('body').append(odiv); odiv.css('left', ($(window).width() - odiv.outerWidth())/2); odiv.css('top', ($(window).height() - odiv.outerHeight())/2 + $(window).scrollTop()) ; &#125;);$(window).on('resize scroll', function () &#123; odiv.css('left', ($(window).width() - odiv.outerWidth())/2); odiv.css('top', ($(window).height() - odiv.outerHeight())/2 + $(window).scrollTop()); // 加上滚动条的距离&#125;) 123$('.clocse').click(function() &#123; $('#login').remove();&#125;) 事件细节 ev : 原生是event ev.pageX(相对于文档) 鼠标的坐标 : 原生用的clientX(相对于可视区) 可视区 + 滚动 = 相对于文档 ev.which : 原生keyCode 键盘的键值 回车是13，which 还可以记录鼠标的左右和滚动 ev.preventDefault(); 阻止默认事件 ev.stopPropagation() 组织冒泡事件 return false; 即阻止默认事件又阻止冒泡事件 one 事件只运行一次123$('div').one('click', function(ev) &#123; console.log('只执行一次')&#125;) 位置方法 (原生)offsetLeft 如果外面有个绝对定位 ，left向左就是到相对定位的距离，如果没有相对定位就是到屏幕左边 offset() 有两个属性 left() 和 top（）无视定位 可以获取到屏幕的总距离 position() 有两个属性 top() 和 left() 会把当前元素转化为类似定位的形式，忽视margin的值， 123&lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt;&lt;/div&gt; 123#div1 &#123;width: 200px; height: 200px; background: red; overflow: hidden; margin: 20px;&#125;#div2 &#123; width: 100px; height: 100px; background: green; margin: 30px; padding: 20px;&#125; 1alert($('#div2').position().left); // 20px 到有定位的父级， 忽视margin 则是20px 如果div1 加position: absolute则会变为0， 如果给div1 加position: absolute，div2 加position: absolute; left: 25px 弹出 25px 获取父级 parent() 获取父级 offsetParent() 获取有定位的父级 如果外面没有定位就是body size() 获取一组元素长度 有点像length each() 循环 // 第一个参数是下标，第二个参数是每个元素 123$('li').each(function (index, elem) &#123; $(elem).html(i)&#125;) 编写拖拽123456789101112131415var disX = 0; var disY = 0; $('div').mousedown(function (ev) &#123; disX = ev.pageX - $(this).offset().left; disY = ev.pageY - $(this).offset().top; $(document).mouseover(function (ev) &#123; $('div').css('left', ev.pageX - disX); $('div').css('top', ev.pageY - disY); &#125;) $(document).mouseup(function () &#123; $(document).off(); &#125;) return false; &#125;) 其他常用 hover 模拟hover() 12345$('#div1').hover(function() &#123; $(this).css('background', 'blue'); // 鼠标移入&#125;, function() &#123; $(this).css('background', 'red'); // 鼠标移出&#125;) show() hide () 接收一个参数 1000 为1s的运动效果 fadeIn() fadeOut() 淡入 淡出 接收一个参数为时间 in -&gt; out 从透明0 到 1 12345$('#div1').hover(function() &#123; $(this).fadeIn();&#125;, function() &#123; $(this).fadeOut();&#125;) slideUp() 卷出 / sideDown() 卷起 fadeTo() 一个参数是时间 第二个参数是透明度 高级基础方法扩充 get(): 把jq转为原生js 1234567&lt;div class="div1"&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 123456$('#div1').get(0).innerHTML;for(var i = 0; i &lt; $('li').get().length; i++) &#123; // $('li').get() 会将一组li转为原生的 $('li')[i].style.background = 'red';&#125; 而此处的$(li).length 也是可以用，因为jq的length也是个方法， 如果给$(‘li’)加下标 也是可以转为原生的 outerWidth() 如果参数写true 会获取margin的值 (原生)offsetWidth 获取不到隐藏元素,而jq中获取元素的宽高，可以获取到隐藏的元素 text() 会获取所有的内容 123&lt;div&gt;111 &lt;span&gt;444&lt;/span&gt;&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;333&lt;/div&gt; 12345$('div').html() //如果用html() 获取到 111&lt;span&gt;4444&lt;/span&gt; $('div').text() // 获取到 111444222333$('div').text('&lt;h3&gt;h3&lt;/h3&gt;'); // 得到文本&lt;h3&gt;h3&lt;/h3&gt; remove() 删除后的返回值就是之前删的元素，但是它自带的事件和操作都会被删掉 1234567$('div').click(function () &#123; alert(123);&#125;)var oDiv = $('div').remove();$('body').append(oDiv); // 但是无法恢复事件 detach() 跟remove方式一样，会保留删除的事件 window.onload = function() {} 所有页面加载完 $(function () {}) // 等dom 加载完，比原生性能好 $(document).ready(function () {}) 就是上面的$(function () {}) // dom加载完成 parent() // 获取父级 parents() //获取当前元素所有的祖先节点,参数是筛选功能，只要条件满足 就能筛选不来，不止一个 1$('#div2').parents('body').css('background', 'red'); // 参数是body ,只能给父级的body变为红色背景 123&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt;&lt;/div&gt; closet() 获取最近的祖先节点，包括当前元素自身, 必须写筛选的参数，找最近只能找到一个元素 1$('#div2').closest('body').css('background', 'red'); // 参数是body ,只能给父级的body变为红色背景 siblings() 获取所有元素的兄弟节点，不包括它自身，也可以写一个参数进行筛选 nextAll() 找下面所有的兄弟节点 next找下一个兄弟节点， 也可以写一个参数进行筛选 prevAll() 上面所有的兄弟节点 也可以写一个参数进行筛选 parentsUntil() 父元素截止 nextUntil() 下一个元素截止 prevUntil() 找上一个元素截止 里面有一个参数来说明 到那个元素截止 clone() 克隆节点 复制节点的操作， 可以接受一个参数作用可以复制之前的操作行为 参数为true ,克隆版本的也会有操作 wrap() 包装 1$('span').wrap('&lt;div&gt;'); // 给每个span 外面包装一个div wrapAll() 整体包装 123&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt; 1$('span').wrapAll('&lt;div&gt;'); // 会在三个span的外面包裹一个div 如果是 1234&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;11&lt;/p&gt;&lt;span&gt;&lt;/span&gt; 使用wrapAll 1234567&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;p&gt;11&lt;/p&gt; wrapInner 在里面包装 123&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt;&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt;&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt; unwrap 删除父级，不包括body 前 1&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; 1$('span').unwrap() 后1&lt;span&gt;&lt;/span&gt; add() 对节点添加组合的一种方法 12&lt;span&gt;111111&lt;/span&gt;&lt;div&gt;2222222&lt;/div&gt; 1234var elem = $('div');var elem = elem.add('span');elem.css('color', red); //两个元素都会变红 slice() 截取指定的范围 1234567&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 1$('li').slice(1,4).css('background', red); // 选择中间三个li 结束的位置不包含 serialize() 串联成字符串 12345&lt;form action=""&gt; &lt;input type="text" name="a" value="1"&gt; &lt;input type="text" name="b" value="2"&gt; &lt;input type="text" name="c" value="3"&gt;&lt;/form&gt; 1console.log($('from').serialize()); // a=1&amp;b=2&amp;c=3 serializeArray() 串联成数组1console.log($('from').serializeArray(); // [&#123;name='a', value='1'&#125;, &#123;name='b', value='2'&#125;, &#123;name='c', value='3'&#125;] // 每个数组是个json jq中复杂的运动 animate() 第一个参数 是一个json 运动的值和属性， 第二个值是时间，调节快慢 默认时间是400 运动形式 只有两种运动形式 （swing(满快慢) linear(匀速)）默认是swing 回调函数 当运动结束运行 12345$('div').click(function() &#123; $(this).animate(&#123;width: 300, height: 300&#125;, 400, 'swing', function () &#123; alert(11); &#125;); // 之前的style 宽高是100 时间是400毫秒&#125;) 12345$('div').click(function() &#123; $(this).animate(&#123;width: 300&#125;, 400, 'swing', function () &#123; $(this).animate(&#123;height: 300&#125;); // &#125;); // 走完宽以后走高&#125;) 链式写法1$(this).animate(&#123;width: 300&#125;, 2000).animate(&#123;height: 300&#125;, 2000); stop() 停止运动 阻止当前的运动，不会阻止所有运动， 如果想阻止所有后续运动 stop(true); 第二个参数如果是stop(true,true)立即停止并到指定的目标点,只针对当前的运动，而不是全部的后续运动 如果想点击停止当前的所有的运动，并且全部到都到指定的目标点 1$('div').finish() //立即停止到指定的目标点 delay() 延迟运动 1$(this).animate(&#123;width: 300&#125;, 2000).delay(1000).animate(&#123;height: 300&#125;,2000); //宽走完停顿1s再走高 delegate() 事件委托 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 将点击事件加在ul身上优点是省略循环操作， 提好性能123$('ul').delegate('li', 'click', function() &#123; this.style.background = 'red';&#125;) undelegate() 组织事件委托的操作 1234$('ul').delegate('li', 'click', function() &#123; this.style.background = 'red'; $('ul').undelegate(); // 取消委托&#125;) trigger() 主动触发事件 12345$('div').on('click', function() &#123; console.log(111111);&#125;)$('div').trigger('click'); // 主动触发 适合自定义事件 事件细节 ev.data 事件带过来的数据 ev.target 事件源 ev.type 事件类型 123$('div').on('click', &#123;name: 'hello'&#125;, function(ev) &#123; alert(ev.data.name); // 弹出aaaa&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Interview_Javascript]]></title>
      <url>%2F2017%2F04%2F08%2FInterview_Javascript%2F</url>
      <content type="text"><![CDATA[一些比较饶人的js题的自测和学习 lesson11123(function () &#123; return typeof arguments;&#125;) (); // 'object' arguments只是个类数组 21234var f = function g() &#123; return 23;&#125;typeof g(); // error 312345(function(x)&#123; delete x; return x;&#125;)(1); // 1 delete 只能删除数组或者对象 412var y = 1, x = y = typeof x;x; // 'undefined' 运算顺序从右向左 5123(function f(f)&#123; return typeof f(); &#125;)(function()&#123; return 1; &#125;); // 'number' 传进去整个函数 返回1 61234567var foo = &#123; bar: function() &#123; return this.baz; &#125;, baz: 1&#125;;(function()&#123; return typeof arguments[0]();&#125;)(foo.bar); // 'undefined' 此处this指向window arguemnts[0] 为undefined 7 12345var foo = &#123; bar: function()&#123; return this.baz; &#125;, baz: 1&#125;typeof (f = foo.bar)(); // 同上 同上 8 12var f = (function f()&#123; return "1"; &#125;, function g()&#123; return 2; &#125;)(); typeof f; // 2 这种括号的运算符，会弹出最后一个值 912345var x = 1; if (function f()&#123;&#125;) &#123; x += typeof f; &#125; x; // 'iundefined' if 里面的函数运算是true, 而f没有定义 undfined 10123var x = [typeof x, typeof y][1];typeof typeof x; // 'string' typeof 输出的类型是字符串类型 111234(function(foo)&#123; return typeof foo.bar;&#125;)(&#123; foo: &#123; bar: 1 &#125; &#125;); // 'undefined' { foo: { bar: 1 } } 作为整个实参传入 而调用的只用一个属性就是 foo 1212345(function f()&#123; function f()&#123; return 1; &#125; return f(); function f()&#123; return 2; &#125;&#125;)(); // 2 跟进预解析个规则，会先走一遍所有的function 1312function f()&#123; return f; &#125; new f() instanceof f; // false instanceof 的作用是看前面的数据 是否是后面的的构造函数，但是如果这个构造函数里面存在return,就指向了return的数据 1412with (function(x, undefined)&#123;&#125;) length; // 2 形参的个数 lesson 2 运行题变量的作用域外层的变量，内层可以找到（全局）内层的变量，外层找不到（局部） 1234567891011var a = 10;function aaa () &#123; alert(a);&#125;function bbb () &#123; var a = 20; aaa();&#125;bbb (); // 10 涉及到作用域的问题， 运行到bbb() 返回到 bbb()函数里面 遇到aaa() ,返回aaa(),只能找到外层的10 变量不加 var 它会变成全局变量12345678function aaa() &#123; var a = b = 10;&#125;aaa()alert(a) // 局部变量undefinedalert(b) // 全局变量 弹出 10 变量的查找是就近原则去寻找var定义的变量，当就近没有找到，就会查找外城， 如果没有找到，找外层的外层12345678var a = 10;function aaa() &#123; alert(a); // 就近查找发现var, 函数做预解析， 所以变量是undefined.所以在定义变量的时候要写在上面，防止出现undefined var a = 20&#125;aaa(); // undefined 123456789var a = 10;function aaa() &#123; var a = 20; alert(a); // 20 寻找就近var定义的变量，&#125;aaa(); 123456789var a = 10;function aaa() &#123; a = 20; alert(a); // 20 寻找就近var定义的变量,寻找到外层定义的a,a进函数后被替换成20&#125;aaa(); 12345678910var a = 10;function aaa() &#123; alert(a); // 10 a = 20;&#125;aaa(); 12345678910var a = 10;function aaa() &#123; bbb(); alert(a); // 10 function bbb() &#123; var a = 20; &#125;&#125; 参数和局部变量重名的时候，优先级是等同，不分彼此12345678var a = 10;function aaa(a) &#123; alert(a); var a = 20;&#125;aaa(a); // 10 基本类型赋值不存在引用关系，对象类型赋值才存在引用关系,除非对象重新赋值，导致地址断开123456var a = 5;var b = a;b += 3;alert(a); // 8 基本类型赋值不存在引用关系 123456var a = [1, 2, 3];var b = a ;b.push(4);alert(a); // [1,2,3,4] 123456var a = [1, 2, 3];var b = a ;b = [1,2,3,4];alert(a); // [1,2,3] 对象赋值后，地址断开 12345678var a = 10; function aaa (a) &#123; a += 3;&#125;aaa(a);alert(a); // 10 传参尽量就相当于重新赋值，不会受函数影响 12345678var a = [1,2,3]function aaa (a) &#123; a.push(4)&#125;aaa(a); // [1,2,3,4]对象的传参相当于引用 alert(a); // [1,2,3,4] 12345678var a = [1,2,3]function aaa (a) &#123; a = [1,2,3,4];&#125;aaa(a); alert(a); // [1,2,3] 对象重新赋值就是断开了引用地址 lesson 3 写一个字符串转成驼峰的方式 border-bottom-color &gt; borderBottomColor 课程方法 123456789function transform(str) &#123; var arr= str.split('-'); arr.forEach(function(data,index) &#123; if(index&gt;=1) &#123; arr[index] = data.charAt(0).toUpperCase() + data.substring(1); &#125; &#125;) return arr.join('') &#125; 正则方法 12345678910var str = 'border-radius';transform(str);function transform(str) &#123; var re = /-(\w)/g // \w就是字母的意思, 括起来的代表正则的子项 return str.replace(re,function($0, $1) &#123; // 第一个参数代表正则的整体，第二个参数担保正则的子祥 return $1.toUpperCase(); &#125;)&#125; 查找字符串中最多的字符和个数 字符串操作 123456789101112131415161718192021222324252627var str = 'sasfdsgdsafdfagfassss';function count(str) &#123; var obj = &#123;&#125;; var num = 0; var value = ''; for (var i = 0; i &lt; str.length; i++) &#123; if(!obj[str[i]]) &#123; obj[str[i]] = []; &#125; obj[str[i]].push(str[i]); &#125; for (item in obj) &#123; if(num &lt; obj[item].length) &#123; num = obj[item].length; value = obj[item][0] &#125; &#125; return '最多出现的字母是' +value+ '重复' + num + '次';&#125;count(str); 正则操作 如何给字符串加千分符 324423143141 &gt; 324,423,143,141 自己方法 12345678910111213141516171819202122var str = '1324423143141';console.log(transform(str));function transform (str) &#123; var arr = str.split(''); var arrh = '' var iNum = arr.length % 3; if(iNum != 0) &#123; var arrh = arr.splice(0,iNum); arrh.push(','); &#125; for(var i = arr.length - 1; i &gt;= 0; i--) &#123; if(i%3 === 0 &amp;&amp; i &gt;= 3) &#123; arr.splice(i, 0, ',') &#125; &#125; return arrh.concat(arr).join('');&#125; 课程方法 1234567891011121314151617181920212223242526272829var str = '1324423143141';console.log(transform(str));function transform (str) &#123; var iNum = str.length % 3; var arr = []; var current = 0; var tmp =''; if(iNum != 0) &#123; prev = str.substring(0, iNum); arr.push(prev) &#125; str = str.substring(iNum); for (var i = 0; i &lt; str.length; i++) &#123; current++; tmp += str[i]; if(current === 3 &amp;&amp; tmp) &#123; arr.push(tmp); current = 0; tmp = ''; &#125; &#125; return arr.join(',')&#125; 正则 // (?=) :前向声明 // (?!) :反前向声明 匹配所有ab变成星号1234567var str = 'abacad';var re = /a/g;str = str.replace(re, '*');console.log(str) // *b*c*d 匹配只有a后有b的才变* 1234567var str = 'abacad';var re = /a(?=b)/g;str = str.replace(re, '*');console.log(str) // *bacad 这就是前向声明的用法 匹配除了a后是b的其他，全都替换成* 1234567var str = 'abacad';var re = /a(?!=b)/g;str = str.replace(re, '*');console.log(str) // ab*c*d 和前向声明相反，匹配 根据上面正则，实现12345678910var str = '1324423143141';function tranform(str) &#123; var re = /(?=(?!\b)(\d&#123;3&#125;)+$)/g; // \b 代表开始结束的位置 return str.replace(re, ',')&#125;console.log(tranform(str)); 返回一个只包含数字类型的数组 js123ldsdkfsf234234 &gt; [123,234234] 字符串 123456789101112131415161718var str = 'js123lf234d234';transform(str);function transform (str) &#123; var arr = str.split('') var tmp = ''; var arrNew = [] for (var i = 0; i &lt; arr.length; i++) &#123; if(!isNaN(arr[i]) &amp;&amp; !isNaN(arr[i+1]) )&#123; tmp += arr[i]; &#125; if (!isNaN(arr[i]) &amp;&amp; isNaN(arr[i+1])) &#123; arrNew.push(tmp+arr[i]); tmp = ''; &#125; &#125; console.log(arrNew);&#125; 正则 lesson 4限制条件补全代码 有a，b两个变量，不用第三个变量来切换两个变量值 12345678var a = 5;var b = 6; a = a + b; // 11 b = a - b; // 6 a = a - b; console.log(a); console.log(b); 以上方法局限于数字，如果是字符串该如何呢？ 12345678var a = 'hello';var b = 'hi';a = [a, b];b = a[0];a = a[1]; console.log(a); console.log(b); 有一个数n = 5, 不要循环返回 [1,2,3,4,5] 不用循环可以考虑递归，不能考虑定时器，它是异步的 递归 123456789101112131415var n = 5;function show (n) &#123; var arr = []; return (function () &#123; arr.unshift(n) n--; if(n!=0) &#123; arguments.callee; &#125; return arr; &#125;)&#125;console.log(show(n)) 正则 利用replace 1234567891011121314var n = 5;function show (n) &#123; var arr = []; var arrNew = []; arr.length = n+1; // 通过数组的逗号替换，所以要多一位 var str = arr.join('a') // aaaaa str.replace(/a/g, function() &#123; arrNew.unshift(n--) &#125;) return arrNew&#125;console.log(show(n)) 一个数n,当n小于100就返回n,否则返回100 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// iffunction show(n) &#123; if(n&lt;100) &#123; return n &#125; else &#123; return 100; &#125;&#125;alert(show(n))// 三目function show(n) &#123; return n&lt;100?n:100;&#125;//switchfunction show(n) &#123; switch(n &lt; 100)&#123; case true: return n; break; case false: return 100; break; &#125;&#125;// Mathfunction show(n) &#123; return Math.min(n,100)&#125;// 数组function show(n) &#123; var arr = [n, 100]; arr.sort(function (a, b) &#123; a - b; &#125;) return arr[0];&#125;// 循环function show (n) &#123; var m = '' + n; //转成字符串 for (var i = 2; i &lt; m.length &amp;&amp; n &gt; 0; i++)&#123; return 100; &#125; return n;&#125;// for infunction show(n) &#123; var json = &#123;name: 'may'&#125; var m = n &lt; 100 || json; for(item in m) &#123; return 100 &#125; return n&#125;// 表达式function show (n) &#123; var m = n &gt;= 100 &amp;&amp; 100; return m || n;&#125; lesson 5 30.38 斐波那契数列 (两个数的和等于第三个数) [1,1,2,3,5…] 递归 123456789function F(n) &#123; if(n&lt;=2) &#123; return 1 &#125; return F(n-1) + F(n-2);&#125;console.log(F(8)) 迭代 1234567891011121314function F(n) &#123; var num1 = 1; var num2 = 1; var num3 =0; for(var i= 0; i &lt; n -2 ;i++) &#123; num3 = num1 + num2; num1 = num2; num2 = num3; &#125; return num3;&#125;console.log(F(8)) 数组排序 冒泡排序是两个两个进行比较 如果前面的数&gt;后面的数，进行位置切换。如果前面的数&lt;后面的数,不进行位置切换。 1234567原数据 4，5，1，7，2第一轮第一次排序 4，5，1，7，2第二次排序 4，1，5，7，2第三次排序 4，1，5，7，2第四次排序 4，1，5，2，7 找到最大值 第二轮 ... 123456789101112131415161718var arr = [ 4,5,1,7,2];for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; arr.length - i; j++) &#123; toCon(j, j+1); &#125; &#125;function toCon(pre,next)&#123; var tmp =''; if(arr[pre] &gt; arr[next]) &#123; tmp = arr[pre]; arr[pre] = arr[next]; arr[next] = tmp; &#125;&#125;console.log(arr); 快速排序 先从数列中取出一个数作为基准数区别过程，将比这个数大的书全放到右边，小于或者等于的数放在左边再对左右区间重复第二步，知道各区间只有一个数 123456789101112131415161718192021function quickSort(arr) &#123; if(arr.length &lt;=1) return arr; var index = Math.floor(arr.length/2); var pivot = arr.splice(index,1)[0]; var left = []; var right = []; for(var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat([pivot], quickSort(right))&#125; 简单排序, 每次找到最小值，把最小值放在前面 12345678910111213141516171819202122var arr = [ 4,5,1,7,2];function sort(arr) &#123; if(arr.length === 1) &#123; return arr &#125; var index = 0; var iMin = arr[0] for (var i = 0 ; i &lt; arr.length; i++ ) &#123; if(arr[i] &lt; iMin) &#123; iMin = arr[i]; index = i; &#125; &#125; var pre = arr.splice(index,1); return pre.concat(sort(arr))&#125;console.log(sort(arr)) 数组去重 12345678910111213141516171819202122232425var arr = [3,5,2,4,3,5,4,1];function q(arr) &#123; var result = [arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if(toCont(arr[i])) &#123; result.push(arr[i]) &#125; &#125; function toCont (val) &#123; for (var i = 0; i &lt; result.length; i++) &#123; if(result[i] === val) &#123; return false &#125; &#125; return true; &#125; return result&#125;console.log(q(arr)) 12345678910111213141516171819var arr = [3,5,2,4,3,5,4,1];function q(arr) &#123; var result = []; var obj = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; if(!obj[arr[i]]) &#123; result.push(arr[i]); obj[arr[i]] = 1; &#125; &#125; return result &#125;console.log(q(arr)) es6 12345678910111213function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))&#125;// orfunction unique (arr) &#123; return Array.from(new Set(arr))&#125;function unique(arr) &#123; return Array.from(new Set(arr))&#125; lesson 6 总结自己面试会问到的 随机生成指定长度的字符串 比如给定 长度 8 输出 4ldkfg9j 123456789function randomstring(n) &#123; var str = 'abcdefghijklmnopqrstuvwxyz9876543210'; var tmp = ''; for (var i = 0; i &lt; n; i++) &#123; tmp += str.charAt(Math.random() * 1); &#125; return tmp;&#125; js打乱数组的最高效方法 12345678910var arr = [];for (var i = 0; i &lt; 100; i++) &#123; arr[i] = i;&#125;arr.sort(function() &#123; return 0.5 - Math.random()&#125;)var str = arr.join() Javascript中callee和caller的作用 caller是返回一个对函数的引用，该函数调用了当前函数； callee是返回正在被执行的function函数，也就是所指定的function对象的正文。 JSONP原理 可以把需要跨域的请求改成用script脚本加载即可，服务器返回执行字符串，但是这个字符串是在window全局作用域下执行的，你需要把他返回到你的代码的作用域内，这里就需要临时创建一个全局的回调函数，并把到传到后台，最后再整合实际要请求的数组，返回给前端，让浏览器直接调用，用回调的形式回到你的原代码流程中。 JavaScript事件模型 原始事件模型，捕获型事件模型，冒泡事件模型， 原始事件模型就是ele.onclick=function(){}这种类型的事件模型 冒泡事件模型是指事件从事件的发生地（目标元素），一直向上传递，直到document 捕获型则恰好相反，事件是从document向下传递，直到事件的发生地（目标元素） event.stopPropagation()event.preventDefault 取消默认时间 li标签间有空白是怎么回事？ 消除li横排后空隙 需要将其设置为display:inline-block;此时会页面效果是两个之间会有一个大约8px的空白间隙.浏览器的默认行为是把inline元素间的空白字符（空格换行tab）渲染成一个空格 既然是因为换行导致的，那就可以将代码全部写在一排 .wrap ul{font-size:0px;} .wrap ul{letter-spacing: -4px;} javascript的本地对象，内置对象和宿主对象 本地对象为array obj regexp等可以new实例化内置对象为gload Math 等不可以实例化的宿主为浏览器自带的document,window 等 CSS中一个冒号和两个冒号有神马区别？ 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 原型对象 每当定义一个对象，对象中都会包含一些预定义的属性，其中函数对象的一个属性就是原型对象 prototype 注： 普通对象没有prototype,但是有 __proto__ 原型底下主要作用是继承 原型链 在js创建对象的时候，都有一个 __proto__的内置属性，用于指向创建它的函数对象的原型对象的 prototype 12345678910var person = function(name) &#123; this.name = name;&#125;person.prototype.getName = function() &#123; return this.name&#125; var m = new person('may'); m.getName(); //may 12console.log(m.__proto__ === person.prototype) //true person.prototype对象也有__proto__属性，它指向创建它的函数对象 1console.log(person.prototype.__proto__ === Object.prototype) //true Object.prototype对象也有proto属性，但它比较特殊，为null 1console.log(Object.prototype.__proto__) //null constructor 原型对象 prototype中都有个预定义的constructor属性，用来引用它的函数对象，这是一张循环引用 123person.prototype.constructor === person //trueFunction.prototype.constructor === Function //trueObject.prototype.constructor === Object //true 作用域 作用域就是变量和函数可以访问的范围，控制着变量和函数的可见性与生命周期 作用域链 当代码在一个环境中执行时，会创建变量对象一个作用域，来保证对执行环境有权访问的变量和函数的有序访问 在函数运行过程中标识符的解析是沿着作用域链一级一级搜索的过程，从第一个对象开始，逐级向后回溯，直到找到同名标识符为止，找到后不再继续遍历，找不到就报错。 html5的新特性 标签语义化，比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签 音视频元素，video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。 新增很多api，比如获取用户地理位置的window.navigator.geoloaction， websocketwebsocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端， webstorage，webstorage是本地存储，存储在客户端，包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了， 缓存 web worker，web worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。 js继承 http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html 第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color; &#125; var cat1 = new Cat("大毛","黄色"); alert(cat1.species); // 动物 第二种代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。 原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。 这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。 1234Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; var cat1 = new Cat("大毛","黄色"); alert(cat1.species); // 动物 第三种由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。现在，我们先将Animal对象改写： 123456function Animal()&#123; &#125; Animal.prototype.species = "动物";Cat.prototype = Animal.prototype; Cat.prototype.constructor = Cat; var cat1 = new Cat("大毛","黄色"); alert(cat1.species); // 动物 什么时候需要清浮动，清楚浮动都有哪些方法 通常使用浮动来实现某些元素的布局，但是往往这些元素浮动会影响其他元素的布局，因此会产生副作用。浮动不再占据文档流的位置，也使浮动元素周围的元素表现的如同浮动元素不存在一样，给布局带来了一些副作用如果我们不希望要这些效果，就需要清除浮动来解决后患 绝对定位与相对定位 相对定位 position: relative; 相对定位是相对于元素在文档中的初始位置绝对定位 position: absolute; 绝对定位是相对于元素最近的已定位的祖先元素 字符串转对象 JSON.parse 从对象解析到字符串 json.stringify 响应布局 px 与 rem jquery append()方法与html()方法用法区别 如果美化一个弹出对话框 闭包的用途一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。123.p &#123;vertical-align: middle;&#125; angularjs作用域 AngularJS中，子作用域一般都会通过JavaScript原型继承机制继承其父作用域的属性和方法。但有一个例外：在directive中使用scope: { … }，这种方式创建的作用域是一个独立的”Isolate”作用域，它也有父作用域，但父作用域不在其原型链上，不会对父作用域进行原型继承。 angularjs 指令的封装 事件委托 es6 与之前 相比有什么新特性 作用链和作用域 let const 作用域和 var 有什么区别 字符图标的优劣 优点不变形缺点 纯色]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax原理]]></title>
      <url>%2F2017%2F04%2F05%2Fajax%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[ajax 学习总结 什么是ajax?异步的的js和xml,用js异步形式操作xml,工作主要是数据交互 借阅用户操作时间，减少数据请求，可以无刷新请求数据 创建一个对象123456789101112131415oBtn.onclick = function () &#123; // 打开浏览器 var xhr = new XMLHttpRequest(); // 打开地址 xhr.open('get', './1.txt', true); // 提交 xhr.send(); // 等待服务器返回内容 xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; alert(xhr.responseText); &#125; &#125;&#125; 不兼容ie6一下，需要写判断 window.XMLHttpRequest 1234567try &#123; &#125; catch(e) &#123; &#125;// 代码尝试执行这个`try`块中的内容，如果有错误，则会执行catch&#123;&#125;不会影响程序执行 1xhr = new XMLHttpRequest(); open 方法参数 打开的方式，数据地址，是否异步 异步： 非阻塞 前面的代码不会影响后面代码的执行 setTimeout true 一般用异步的形式同步： 阻塞 当前面的工作没有做完，后面会阻塞 比如jq库的加载 false 后续的内容需要前面挂钩， 表单 数据提交action: 数据提交的地址，默认的当前页面method: 数据提交的方式，默认get方式 get把数据名称和数据值用=连接，如果有多个数据，会用&amp;进行连接，然后把数据放到url?后面不要通过get传递过多的数据，数据多少根据各个浏览器决定 post数据在请求头，发送数据是串联形式，但是位置不一样，理论上没有限制enctype: 提交的数据格式，默认application/x-www-form-urlencoded需要在表格中 method=&quot;post&quot; get请求和post一般用于何种需求 get 方式的历史记录会被记录，影响用户隐私，不太安全，只能传字符串 post 通过请求头，可以用于多种数据类型 数据的获取怎么得到ajax 返回的数据 xhr.responseText: 返回的数据会放在这个属性，类型是字符串类型 readyState: ajax工作状态 0 1 2 3 4 0 初始化 1 调用xhr.send() 2 载入完成，请求已经发送，收到响应内容 3 解析 正在解析内容 4 解析完成 onreadychange 当状态值改变的时候触发 12345xhr.onreadystatechange = function() &#123; if(xhr.readyState = 4) &#123; // code &#125;&#125; 请求资源的时候，服务器会返回一个状态值 1 代表消息 2 成功类型 3 重定向 调到其他页面，缓存就是一种重定向 4 错误 5 服务器性错误 可以做更好的容错处理123456789xhr.onreadystatechange = function() &#123; if(xhr.readyState = 4) &#123; if(xhr.status === 200) &#123; // 请求正确 &#125; else &#123; alert('error'); &#125; &#125;&#125; 请求的处理 get 请求文件，传输数据 1234567891011121314151617var oBtn = document.getElementById('btn');oBtn.onclick = function () &#123; var xhr = new XMLHttpRequest(); xhr.open('get','form.get.php?username=may&amp;age=30',true); xhr.send(); xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; alert(xhr.responseText) &#125; else &#123; alert('error') &#125; &#125; &#125;&#125; 注意： 1 如果不想存在缓存问题 可以给请求后面加随机数或者时间戳 1xhr.open('get','form.get.php?username=may&amp;age=30&amp;' + new Date(),true); 2 中文乱码问题，可以用编码 encodeURI 1xhr.open('get','form.get.php?username='+encodeURI('文件') +'&amp;age=30&amp;' + new Date(),true); post 方式请求文件 数据作为参数放在send方法里面，并且设置请求头 12345678910111213141516var oBtn = document.getElementById('btn');oBtn.onclick = function ()&#123; var xhr = new XMLHttpRequest(); xhr.open('post', 'form.post.php', true); xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded'); // 需要告诉后端发送数据的类型 xhr.send('username=may&amp;age=30'); xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if(xhr.status = 200) &#123; alert(xhr.responseText); &#125; &#125; &#125; &#125; post没有缓存问题，它本身就是提交数据post没有转码的问题 数据获取的问题 JSON.stringify(arr): 可以把一个对象转成对应字符串 JSON.parse(str); key值必须是双引号才可以转为json 123456789101112131415161718192021var oBtn = document.getElementById('btn');var oul = document.getElementById('ul');oBtn.onclick = function () &#123; var xhr = new XMLHttpRequest(); xhr.open('get', 'getNew.php', true); xhr.send(); xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if(xhr.status === 200) &#123; var data = JSON.parse(xhr.responseText); var html = ''; for (var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;&lt;a href=""&gt;' + data[i].title + '&lt;/a&gt;&lt;span&gt;' + data[i].date+ '&lt;/span&gt;&lt;/li&gt;' &#125; oul.innerHTML = html; &#125; &#125; &#125;&#125; 瀑布流展示demo瀑布流布局需求 每次最短的li,然后添加位置 需要知道图片的高度，否则图片加载还没有加载完成，就会自动计算那一列最短而去添加。可以有两种解决方案 拉到最底下加载 计算最短的li的高度 + top值 &lt; 可视区的高度 + 滚动条的高度 document.documentElement.scrollTop || document.body.scrollTop 往下拉， 不仅仅加载一次，可能会触发 第二页 第三页，可以设置个标识位 数据加载完的时候 应该对每次取到的数据进行判断，如果没有数据， return 出去 后端传值宽高 如果宽度确定 200 高度就是 123element.height * (200/element.width)document.createElement('li'); 预加载 跨域解决一个域名的文件去请求和它不一样的域名下的资源文件，就会产生跨域请求 浏览器因为安全问题不允许跨域请求，可以采用 通过本地代理 本地建立一个代理，这个代理请求服务器，需要资源的时候，在请求服务器 通过flash flash请求资源，服务器端有xml文件，里面存一些资源域名，如果能找到允许你访问 通过jsonp （json with Padding） 从另外的域名，把资源拿取过来 script标签， 可以加载.js以外的文件类型吗？文件的后缀名是辨识的不是文件类型决定， 跟根据文件里面的实质内容。只认内容，不认文件名字 用script标签加载资源没有跨域问题 在资源加载进来之前定义好一个函数，这个函数接收一个参数（数据），函数利用这个参数做一些事情然后需要的时候通过script标签加载对应远程文件资源，当远程的问价资源被加载进来的时候，就会去执行我们前面定义好的函数，并且把数据当做这个函数的参数传入进来 如果想实现按需加载，比如当用户点击的时候？ 当用户点击的时候创建 script 标签，加载到 body标签后面，从而实现按需加载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[问题总结]]></title>
      <url>%2F2017%2F04%2F05%2F%E8%AF%84%E7%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[记录之前面试的总结.. BOM和DOM 含义，全拼document object model 文档对象模型，把文档当做一个对象来看待browser object model 浏览器对象模型 把浏览器当做一个对象来看 javascript基础数据类型数字、字符串、undefined、对象、null、boolean 如何判断数据类型：typeof 常见类型的判断instanceof 对已知对象类型的判断其中typeof返回的类型都是字符串形式，在判断object类型是比较方便instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支 如何判断一个数据是数组类型：constructorinstanceofisArray 判断浮点数正则将这个浮点数转为字符串，判断里面是否有点 有一个div，它内部宽度不确定，我想让它相对于父元素垂直水平居中，如何设计？flex布局line-height 垂直， margin: 0 autoclentWidth - offsetWidthtransform: translate(-50%, -50%);利用伪类实现123456789101112131415161718192021.wrapper &#123; width: 200px; height: 200px; text-align: center; background-color: #ccc; &#125; .goal &#123; display: inline-block; width: 100px; height: 100px; vertical-align: middle; background-color: deeppink; &#125; .wrapper:after &#123; content: ' '; display: inline-block; width: 0; height: 100%; vertical-align: middle; background-color: deeppink; &#125; html语义化的理解便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析方便其他设备解析 http状态码：1 开头 代表消息2 代表成功3 重定向4 请求错误5，6 服务器错误 cookie，sessionStorage与localStorage区别 共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不能在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。。 css3新特性 css3 选择器 css3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是 ::selection. 媒体查询，多栏布局 border-image css选择器 兄弟选择器 属性选择器 引入normalize的作用。是保留浏览器的原来样式并且做到每个浏览显示一致 性能优化：减少请求、简化页面结构、优化代码、压缩机制、图片。css雪碧图的优缺点优点：减少请求，提升页面性能减少图片的字节数解决了图片命名的困扰更换风格方便统一缺点在图片合并的时候，多张图片合并在一张图片，要保留好足够的空间，防止出现不必要的背景图片可维护性查，每次的修改都要在这个图片上修改，如果图片较多，你要记住位置图片的位置需要固定绝对值定位，失去了灵活性 display有哪些值:none、block、inline、inline-block,table。img元素是什么元素？inlineXMLHttpRequest原生12345678var xhr = new XMLHttpRequest();xhr.open(method, url, true);xhr.send();xhr.onreadystatechange = function() &#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; &#125;&#125; 哪些事件会触发脏检查？当在view绑定数据，触发事件都会触发脏检测 ng-model ng-click $digest和$apply有什么区别？$scope.$apply()会自动调用$rootScope.$digest()。$apply()函数可以以两种方式运行。第一种是将函数作为参数，并且评估他，然后触发$digest循环。第二种并不传入任何参数，仅仅是执行一个$digest循环。如果我们更改一个不在AngularJS执行上下文中的数据模型(model)，就需要人为的调用$apply()来提醒AngularJS数据发生变化了。就像是要告诉AngularJS，我们改变了一些数据，他应该启用监听器以便于让我们所做的改变能够反映出来。当你为$apply()传入函数的时候，这个函数在调用的时候是包含在try..catch中的，并且，任何发生的异常都能够被$exceptionHandler服务所接收。 https://segmentfault.com/a/1190000004523893 数据请求和前端资源优化？配置超长时间的本地缓存 —— 节省带宽，提高性能采用内容摘要作为缓存更新依据 —— 精确的缓存控制静态资源CDN部署 —— 优化网络请求资源发布路径实现非覆盖式发布 —— 平滑升级]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack]]></title>
      <url>%2F2017%2F04%2F02%2Fwebpack%2F</url>
      <content type="text"><![CDATA[webpack说的很简单，项目中也一直在用别人搭好的脚手架，一直很忙没有功夫细细研究下，这次一定认真研究下，以后使用再有问题和坑一并记录到这来 参考api http://webpack.github.io/docs/configuration.html中文api https://doc.webpack-china.org/guides/get-started/简易使用指南 https://github.com/petehunt/webpack-howto 为什么用webpack？目标是什么？ 将依赖切分到不同的代码块里面，按需加载依赖保持初始化加载更少整合第三方模块 区别 code splitting 代码分隔 loaders 模块热更新 插件系统 当你拿到一个项目你需要 初始化项目1npm init 一路回车生成package.json 接下来你需要全局安装webpack 1npm i -g webpack 在项目中安装 1npm i -D webpack 创建如下目录结构 1234+ src - app.js+ distpackage.json 就可以使用webpack 进行简单的打包 app.js 1console.log(&apos;hello from app.js&apos;) 可以使用webpack进行简单打包 1webpack ./src/app.js ./dist/app.bundle.js 1webpack ./src/app.js ./dist/app.bundle.js -p //打包出来的文件被压缩处理 1webpack ./src/app.js ./dist/app.bundle.js --watch //打包出来的文件被压缩处理,并且实时监听文件的变化 可以看到打包好的文件生成在dist文件中，现在我们简化指令 创建webpack.config.js 123456module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; filename: &apos;./dist/app.bundle.js&apos; &#125;&#125; 再输入 1webpack 修改package.json 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack -d --watch&quot; //这条是添加的&#125; 这时我们在终端只需输入 1npm run dev 而实际上线我们需要代码压缩 12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack -d --watch&quot;, &quot;prod&quot;: &quot;webpack -p&quot; // 对代码进行压缩&#125;, webpack plugins 创建自定义的index在dist目录中创建index.html,并进入打包好的js文件 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;content goes here&lt;/p&gt; &lt;script src="./app.bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此刻我们不想通过手动在dist中创建html文件，利用webpack的plugin来帮我们创建 1npm i html-webpack-plugin --save-dev 修改webpack.config.js,并删除dist目录中的index.html 12345678910var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;app.bundle.js&apos; &#125;, plugins: [new HtmlWebpackPlugin()]&#125; 然后运行 1npm run dev 这时候你会看见目录里面自动生成index.html文件 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果想根据自己的模板创建index.html,需要修改webpack.config.js 12345678910111213141516171819var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;app.bundle.js&apos; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;myApp&apos;, minify: &#123; collapseWhitespace: true //生成被压缩的html文件 &#125;, hash: true, template: &apos;./src/index.html&apos;, // 自定义的html路径 &#125;) ]&#125; 在src目录添加index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is my template&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; css-load、sass-loadcss-load1npm install css-loader style-loader --save-dev 在app目录下生成app.css 1234567html,body&#123; height:100%; margin:0; background:green; color:#fff; font-size:20px;&#125; 修改webpack.config.js 123456module: &#123; rules: [ &#123;test: /\.css$/, loaders: &apos;style-loader!css-loader&apos;&#125; // &#123;test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;]&#125; ] &#125;, 修改app.js 12import &apos;./app.css&apos;console.log(&apos;hello from app.js again&apos;) sass-loader1npm install --save-dev sass-loader node-sass 修改webpack.config.js 123456module: &#123; rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;]&#125;, &#123;test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;]&#125; ] &#125;, 修改app.js 12import &apos;./main.scss&apos;console.log(&apos;hello from app.js again&apos;) 在src目录新建main.scss 1body&#123;background:#ff0;&#125; 这样的打包方式最终加载页面head里面，但是如果吓你文件的方式引入进去 1npm install --save-dev extract-text-webpack-plugin 修改webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);var path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;app.bundle.js&apos; &#125;, module: &#123; rules: [ &#123;test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [&apos;css-loader&apos;] &#125;)&#125;, &#123;test: /\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [&apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;)&#125; ] &#125;, plugins: [ new ExtractTextPlugin(&#123; filename: (getPath) =&gt; &#123; return getPath(&apos;css/[name].css&apos;).replace(&apos;css/js&apos;, &apos;css&apos;); &#125;, allChunks: true &#125;), new HtmlWebpackPlugin(&#123; title: &apos;myApp&apos;, minify: &#123; collapseWhitespace: true //生成被压缩的html文件 &#125;, hash: true, template: &apos;./src/index.html&apos;, // Load a custom template (ejs by default see the FAQ for details) &#125;) ]&#125; webpack-dev-server1npm i webpack-dev-server -D 修改package.json 12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;, // 这里是刚修改的 &quot;prod&quot;: &quot;webpack -p&quot;&#125; 然后 1npm run dev 修改webpack.config.js，添加如下 1234567devServer: &#123; contentBase: path.join(__dirname, &apos;dist&apos;), compress: true, port: 8080, stats: &apos;errors-only&apos;, open: true // 启动后自动打开浏览器窗口&#125;, 清理dist1npm i -D rimraf package.json修改 123456&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;, &quot;prod&quot;: &quot;npm run clean &amp;&amp; webpack -p&quot;, &quot;clean&quot;: &quot;rimraf ./dist/*&quot;&#125; 这样的话会在每次打包的时候将dist目录清空，然后重新生成，以确保dist目录没有多余的无用文件 多模块的使用一般情况一个项目肯定不止一个页面吧，解析来创建contact模块，修改webpack.config.js,在plugins中添加： 123456new HtmlWebpackPlugin(&#123; title: &apos;contact&apos;, hash: true, filename: &apos;contact.html&apos;, template: &apos;./src/contact.html&apos;&#125;) 在src根目录创建一个新的html模板contact.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is contact!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 新建contact.js 12console.log('contact page') 由于有多个入口文件，修改webpack.config.js的entry和output 12345678entry: &#123; app: &apos;./src/app.js&apos;, contact: &apos;./src/contact.js&apos;&#125;,output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos;&#125;, 这时候再次启动服务器，我们发现contact.js被调用，这不是我们需要的，指向在contact.js在contact页面中被调用 1234567891011121314new HtmlWebpackPlugin(&#123; title: 'myApp', hash: true, filename: './index.html', excludeChunks: ['contact'], //新增 template: './src/index.html',&#125;),new HtmlWebpackPlugin(&#123; title: 'contact', hash: true, filename: 'contact.html', chunks: ['contact'], //新增 template: './src/contact.html'&#125;) 这样两个模块就不会互相干扰 css js的局部刷新伴随项目越来越大，每次保存都会从新刷新打包，现在我们需要局部刷新 修改webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);var path = require(&apos;path&apos;)var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &#123; app: &apos;./src/app.js&apos;, contact: &apos;./src/contact.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos; &#125;, module: &#123; rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;]&#125;, &#123;test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;]&#125;, &#123;test: /\.pug$/, use: [&apos;html-loader&apos;, &apos;pug-html-loader&apos;]&#125; ] &#125;, devServer: &#123; contentBase: path.join(__dirname, &apos;dist&apos;), compress: true, port: 8080, stats: &apos;errors-only&apos;, hot: true, open: true // 启动后自动打开浏览器窗口 &#125;, plugins: [ new ExtractTextPlugin(&#123; filename: (getPath) =&gt; &#123; return getPath(&apos;css/[name].css&apos;).replace(&apos;css/js&apos;, &apos;css&apos;); &#125;, disable: true, allChunks: true &#125;), new HtmlWebpackPlugin(&#123; title: &apos;myApp&apos;, // minify: &#123; // collapseWhitespace: true //生成被压缩的html文件 // &#125;, hash: true, filename: &apos;./index.html&apos;, excludeChunks: [&apos;contact&apos;], template: &apos;./src/index.pug&apos;, // Load a custom template (ejs by default see the FAQ for details) &#125;), new HtmlWebpackPlugin(&#123; title: &apos;contact&apos;, hash: true, filename: &apos;contact.html&apos;, chunks: [&apos;contact&apos;], template: &apos;./src/contact.html&apos; &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin() ]&#125; 打包图片1npm i -D file-loader 123456// add &#123;test: /\.jpg$/, use: &apos;file-loader&apos;&#125;``` 在html中增加使用 12 npm i -D image-webpack-loader 12 { test: /.(png|jpe?g|svg|gif|webp)$/, use: [ ‘file-loader?name=images/[name].[ext]’, // ‘file-loader?name=[hash:6].[ext]&amp;publicPath=images/‘, ‘image-webpack-loader?{optimizationLevel: 7, interlaced: false, pngquant:{quality: “65-90”, speed: 4}, mozjpeg: {quality: 65}}’ ]}1234&gt; 具体参考：https://www.npmjs.com/package/image-webpack-loader# babel的使用 npm i -D babel babel-preset-es2015 babel-loader babel-core 12 //add{ test: /.js$/, use: ‘babel-loader’, exclude: /node_modules/},1在根目录新增.babelrc文件 { “presets”: [“es2015”]} ``` 具体参考 http://babeljs.io/docs/setup/#installation webpack 详解 http://www.viscode.cn/2017/03/30/webpack%E8%AF%A6%E8%A7%A3/#more]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angularjs问题总结]]></title>
      <url>%2F2017%2F04%2F01%2Fangularjs%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[之前在知乎上看过一个问题 如何衡量一个人的 AngularJS 水平？ https://www.zhihu.com/question/36040694 感觉自己也用了快一年了，但是很多会用答不上来，吓得我赶紧打开我的项目，发现我用angularjs啦，难道我遇见假的angularjs了。而且用完就忘了，开此贴特来记录一些问题和坑！ angular的数据采用什么机制？ 详述原理脏检测机制 angular在scope模型上设置了一个监听队列，用来监听数据变化并更新view。当绑定一个东西到view上时angular就会往$watch队列里插入一条$watch,用来检测它监听的model里面是否有变化的东西。当浏览器接收可以被angular content 处理的事件是，$digest循环就会触发，遍历所有$watch, 最后更新dom 举个例子 1&lt;button ng-click = 'val=val+1'&gt;&lt;/button&gt; click 时会产生一次更新的操作（至少触发两次$digest循环） 按下按钮 浏览器接收一个事件，进入到angular context $digest循环开始执行，查询每个$watch是否变化 由于监听$scope.val的$watch报告了变化，因此强制再执行一次$digest循环 新的$digest循环没有检测到变化 浏览器拿回控制器，更新$scope.val新值对应的dom $digest的循环上限是10次 两个平级界面a和b,如果a触发一个时间，有哪些方式能让b知道，详述原理其实就是两个评级界面模块进行通信。有两种方式 共用服务 基于事件 eventBus 事件发布和订阅的框架 共用服务在angular中，通过factory可以生成一个单例对象，在与需要通信的模块a和b中注入这个对象即可 基于事件 借助父controller.在子controller中向父controller触发$emit事件，然后在父controller中监听$on事件，再广播$broadcast给子controller,这样通过事件携带参数，实现了数据经过父controller,在同级controller之间传播 借助$rootScope。每个angular应该默认一个根作用域$rootScope,根作用域位于最顶层，从它往下挂着各种作用域。所以，如果子控制器直接使用$rootScope广播和接收事件，那么久可以实现同级之间的通信 EventBus 事件发布、订阅总线提供事件订阅，事件发布，事件解绑 将定义的事件和事件函数push到一个数组里面这个是事件订阅，当需要触发函数通过事件发布，完成后事件解绑 一个angular应用应当如何良好的分层 目录结构的划分 如果是小型的文件类型，可以按照文件类型组织 cssjs controller model services filters templates 但如果是规模较大的项目，最好按照业务模块划分 业务文件夹最好还有个公共的common文件来存放公共的东西，比如抽出的组件，图片，css 逻辑代码的划分 作为一个mvvm框架，angular应用本身应该按照模型，视图模型，视图来划分 这里的逻辑代码的拆分，尽量让controller这一层很薄。提取共用的逻辑到service中，比如后台数据的请求，数据的共享和缓存，基于事件的模块间通信，提取共同的界面操作到directive中，提取共用的格式化造作到filter中 在复杂的应用中，也可以为实体建立对应的构造函数 angular应用常用那些路由库，各自的区别angular1.x中常用ngRoute 和 ui.router,还有一种为angular2设计的new router ngRouter 是angular自带的angular模块，ui.router是第三方提供的模块 ui.router是基于state状态的，ngRouter是基于url的，ui.router模块具有强大的功能，主要体现在视图的嵌套方面 使用ui.router能够定义有明确父子关系的路由，并通过ui-view指令将子路由模板插入到父路由模板的中去，从而实现视图嵌套。而在ngRouter中不能这样定义，如果同时在父子视图中使用的会陷入死循环 如果angular的directive规划一套全组件化体系，会遇到哪些挑战？ 对外暴露的接口是否满足不断变化的需求 能否做到一套组件化的细节例如disabled 默认值 css等细节的统一 能否做到统一的版本控制，当升级组件版本时，基础逻辑不会影响，做到兼容 及时fix bug 分属不同团队进行开发的angular应用，如果要做整合，会遇到哪些问题，如何解决可能会遇到模块之间的冲突，一个在moduleA中，一个在moduleB中，导致两个module在会发生覆盖 最好在开发的时候就统一空间命名，避免冲突 angular缺点有哪些？ 约束性强学习成本高，对前端不友好 不利于seo, 一种解决的办法是对应正常用户的访问，响应angular,对于搜索引擎访问，响应针对seo的html页面 性能问题 作为MVVM框架，因为实现了数据的双向绑定，对应大数组，复杂对象会存在性能问题 优化angular应用性能的办法 减少监控项 对不会变化的使用单向绑定 1&#123;&#123;::yourModel&#125;&#125; 主动设置索引 指定track by， 无限滚动加载避免用ng-repeat 降低渲染数量 设置分页，每次渲染有限的数量 数据扁平化 (对于树状结构，使用扁平化解构，构建一个map和梳妆数据，对数操作) 如何看待 controller as 的语法在1.2以前，view任何的绑定都是直接绑定$scope。使用controllerAs,不需要再注入$scope, controller 变成一个简单的js对象，一个更纯粹的viewModel 从源码实现上来看，controllerAs语法只是把controller这个对象的实例用as别名在$scope上创建一个属性 避免遇到angular作用域相关的一个坑（比如ng-if，会产生以及作用域的坑，其实也是js原型链继承中值类型继承的坑）使用controllerAs的话view上所有的字符都绑定在一个引用的属性上，就可以避免这个坑 不过不引入$scope会导致$emit $broadcast $on $watch等方法无法使用，这些个跟事件相关的操作可以封装起来统一处理，或者在单个controller中引入 $scope 详述angular的依赖注入angular是通过构造函数的参数名字来推断依赖服务名称，通过toString来找到这个定义的function的字符串，然后用正则解析出其中的参数，再去依赖映射种渠道的对应的依赖，实例化之后传入 因为angular的inject是假设函数的参数名字就是依赖名字，如果去查找依赖项，代码压缩后，参数会重命名，就无法查找到依赖项 依赖注入写法数组注释法123myApp.controller('myCtrl', ['$scope', function ($scope) &#123;&#125;]) 显示$inject1myCtrl.$inject = ['$scope', '$http'] 对于依赖注入必须具备三个要素：依赖项的注册，依赖关系的声明和对象的获取，在angularjs中，module和$provide都可以提供依赖项的注入，内置的injector可以获取对象 ng-if和ng-show区别ng-if 为true 才创建dom节点，ng-show起始就创建了。用样式控制 ng-if 会隐式的产生新作用域，ng-switch，ng-include等会动态创建一块界面也是如此 ng-repeat 迭代数组，有相同值可以加$track by $index可以解决，也可以任何一个普通的值，只要能唯一标识数组中的每一项即可（建立dom和数据之间的关系） ng-click中写的表达式，能使用js原生对象上的方法，比如math.max之类的吗不可以。只要在页面中，就不能直接调用原生的js方法，因为这些并不属于在页面对应的controller的$scope,除非在$scope中添加这个函数 下面这种表达实例，实现后面的参数通过什么方法自定义12&#123;&#123;now | 'yyyy-mm-dd'&#125;&#125;` filter 有两种使用方法1&lt;p&gt;&#123;&#123;now | data: 'yyyy-mm-dd'&#125;&#125;&lt;/p&gt; 另一种在js里面用 1$filter('date')(now, 'yyyy-mm-dd') 自定义12345app.filter('过滤器名字', function() &#123; return function (需要过滤的对象,过滤参数,过滤参数) &#123; return 处理后的对象 &#125;&#125;) factory、service和provider是什么关系？factory把service的方法和数据放在一个对象里面，并返回一个对象 12345678app.factory('FooService', function()&#123; return &#123; target: 'factory', sayHello: function()&#123; return 'hello ' + this.target; &#125; &#125;&#125;); service通过构造函数方式创建service，返回一个实例化对象 1234567app.service('FooService', function()&#123; var self = this; this.target = 'service'; this.sayHello = function()&#123; return 'hello ' + self.target; &#125;&#125;); provider创建一个可通过config配置的service,$get中返回的，就是用factory创建的service 12345678910111213141516171819202122app.provider('FooService', function()&#123; this.configData = 'init data'; this.setConfigData = function(data)&#123; if(data)&#123; this.configData = data; &#125; &#125; this.$get = function()&#123; var self = this; return &#123; target: 'provider', sayHello: function()&#123; return self.configData + ' hello ' + this.target; &#125; &#125; &#125;&#125;);// 此处注入的是 FooService 的 providerapp.config(function(FooServiceProvider)&#123; FooServiceProvider.setConfigData('config data');&#125;); 从底层实现来看，service调用了factory,返回其实例，factory调用了provider,返回其$get中定义的内容， $factory和service功能类似，只不过factory是普通的函数，可以返回任何东西service是构造器，可以不返回provider是加强版的factory,返回一个可配置的factory $rootscope和$scope的区别$rootScope页面所有的$scope的父亲 angular 解析ng-app然后在内存中创建$rootScopeangular会继续解析找到双括号表达式表达式，并解析变量 接着会解析带有ng-controller的div然后指向某个controller函数，这个时候在这个controller函数变成一个$scope对象的实例 表达式是如何工作的每出现一个双括号表达式就会设置一个$watch而$interpolation会返回一个带有上下文参数的函数，最后改函数执行，算是表达式$parse作用域上 angular的digest周期angular总会对比scope module的值，一般digest周期都是自动触发的，也可以使用$apply进行手动触发 取消 $timeout,停止$watch取消1$timeout.cancel(customTime) 停止 12345678var deregisterWatchFn = $rootScope.$watch('someGloballyAvailableProperty', function (newVal) &#123; if (newVal) &#123; // we invoke that deregistration function, to disable the watch deregisterWatchFn(); &#125;&#125;); 要取消watch的话，一开始将$watch的返回值保存就好啦，要取消watch的时候，在调用。 angular directive中restrict中分别怎么设置A 属性匹配E 标签匹配C class匹配M 注释匹配 在scope中 @ 设置一个字符串= 双向绑定&amp; 用于执行父级scope上的一些表达式 $apply 和 $digest的区别$apply 可以接收一个参数作为function，这个参数会被包装在try..catch中，一旦异常就会被$exceptionHandler service 处理 $apply会使ng进入$digest cycle,并从$rootScope开始遍历检查数据变更 $digest仅会检查scope和它的子scope 写controller逻辑 需要注意简化代码 尽量减少dom节点操作，dom最好出现在指令中，angular提倡驱动开发，service或者controller中出现dom操作意味这，测试驱动无法通过，angular专注上相数据绑定，无需关系一对dom操作 angular是mvc还是mvvm首先说明一下mvc 和 mvvm理解 为什么需要mvc,随着代码规模化，必须切分职责，方便后期的维护，修改一块功能，不能影响其他功能，也方便复用，mvc只是一种手段，终极目标的模块化和复用 mvvm的优点 低耦合 可复用 独立开发 可测试 angularjs的mvvm 模式分为四个部分 view 专注界面的显示和渲染，在angular中则是包含一堆声明式的directive视图模板 viewModel 是view和model的粘合体，负责view和model的交互和协作，负责给view提供显示的数据，以及view中事件的操作 model 它是应用程序的业务逻辑相关的数据的封装载体，是业务领域的对象，model不会关心如何显示或操作，大部分model来自服务端返回数据或者全局配置angualr的service则是封装和处理相关业务逻辑的场所 controller 它负责初始化viewModel，将组合一个或者多个service来获取业务领域model放在viewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态 angularjs 核心 mvc 模块化 双向绑定 语义化标签 注入依赖 directive中compile和link的区别使用compile函数可以改变原始的dom,在ng创建原始dom实例以及创建scope之前 可以应用于当需要生成多个element实例，compile函数阶段改变原始的dom生成多个原始dom节点,然后每个又生成element实例.因为compile只会运行一次,所以当你需要生成多个element实例的时候是可以提高性能的. pre-link 可以运行一些业务代码在ng执行完compile函数之后，但是在它所有子指令的post-link函数将要执行之前 post-link 来执行业务逻辑，这个阶段，它已经知道所有的子指令已经编译完成并且pre-link以及post-link函数已经执行完成 当同时设置compile和link函数，compile所返回的函数当做link函数，而link选择本书则会被忽略，如果注释掉compile，link就起作用了 默认的angular路由中，#号怎么去掉这个原因是因为angular框架提供一种html5模式的路由可以设置$locationProvider1$locationProvider.html5Mode(true) 缺点是无法刷新，404需要配置服务器来修复]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angularjs组件化开发]]></title>
      <url>%2F2017%2F03%2F30%2Fangularjs%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[正在码字中。。。 特点： MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等 模块化来分隔组织打包软件，每个模块完成一个特定的子功能，所有的模块按某种特定的方法组装起来。成为一个整体，完成整个系统，完成整个系统所要求的功能 模块化的目的就是为了降低程序复杂度，使程序设计、调试和维护等操作简单化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[软件测试基础教程]]></title>
      <url>%2F2017%2F03%2F28%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[和测试沟通，了解测试的黑白测试，知己知彼，少出bug 第五章 动态分析-测试设计技术软件测试被看成是在计算机上执行测试对象的过程。这个过程被称为动态分析，这里的测试对象程序必须是可以执行的，程序执行之前需要提供输入数据。在低级别的测试阶段，测试对象往往无法单独运行，为了能运行测试对象，必须将测试对象继承到测试台。 测试对象通常需要通过事先定义的接口来调用程序的不同部分，当程序的某些部分还没有完成，也就是还不能够调用程序的不同部分。可以用桩来模拟。 桩模拟程序通常由测试对象调用的那部分的输入/输出行为。 测试台必须能够为测试对象提供输入数据，有时还需要模拟程序中调用测试对象的部分，这就是驱动器的工作。 驱动器和桩组合构成了测试台，测试台和测试对象一起形成了一个可执行的程序。 测试人员要创建测试台，扩展或修改标准的测试台，为了适合测试对象的接口调整测试台。这个过程可以使用测试台生成器完成。 在执行是，测试必须以尽可能少的成本尽量多地发现失效，验证尽量多的需求。采用系统化的测试方法，理想的当然是对测试对象工作的所有可能情况都进行测试。 测试执行的主要步骤 确定测试条件和前置条件，以及测试需要达到的目标 指定单个测试用例 确定如何执行 在设计测试用例是，必须确定如何将每个需求和测试用例之间想关联，从而可以确定测试对需求的覆盖率 执行单个测试用例没有意义，需要按照一定的方式进行组合，从而按照一定的顺序执行，这样的测试记录应该记录在测试规程规格说明，同时应该包含测试优先级，以及测试与回归测试用例之间的技术上和逻辑上的依赖关系 为了使测试用例按顺序执行，需要使用测试脚本，测试脚本包含是测试自动按顺序执行的指令 JUnit 对象测试有几种不同的方法黑盒测试和白盒测试 黑盒测试/功能测试/行为测试 测试对象呗看成一个黑色的盒子，测试用例从测试对象的规格说明中获取，测试用例的设计基于测试对象的规格说明或者需求文档，值观察程序的输入输出行为 白盒测试/结构测试 需要熟悉代码进行测试设计，实行测试用例的时候，需要分析测试对象内部的工作过程以及测试输出，白盒测试技术可以应用在低级别的测试中，如组件测试和集成测试 黑盒测试技术测试人员不用考虑内部结构和具体设计 等价类划分每个输入数据元素的各种可能的输入值的域被划分为等价类。等价类是测试人员认为测试对象将以相同的方式来处理的一组数据值，对等价类的一个代表性数据进行测试就够了，而对等价类中的任何其他输入值进行测试，对象都不会有不同的反应和行为。在测试过程中不仅要对有效输入的等价类进行测试，而且还要对无效输入值得等价类进行测试。 最好的测试值是验证等价类边界的那些值 由所有代表值组合而成的测试用例按使用频率进行排序，并按照这个序列设置优先级 优先级考虑包含边界值或者边界值组合的测试用例 将一个等价类的每个代表值和其他等价类的 保证满足最小原则，一个等价类的每个代表值至少在一个测试用例中出现 无效等价类的代表值不与其他无效等价类的代表值进行组合 独立测试无效值 边界值分析边界值分析是对等价类划分导出的测试用例的一个非常合理的补充。程序中错误经常出现在等价类的边界值上，出现这种现象的原因是没有明确定义边界值 在每个边界值上，需要测试一个边界值和两个最近值，测试的边界值一个在等价类内部，另一个在等价类外部 状态转换测试很多情况下，测试对象的输出和行为方式不仅受当前输入数据的影响，同时还与测试对象之前的执行情况，或之前的状况或者以前输入的数据有关。为了说明测试对象和历史数据之间的关系，引入了状态图。 因果图技术和决策表技术白盒测试技术基于代码的测试，基本思想是吧测试对象的每个部分代码至少执行一次，分析程序逻辑，然后执行用例 语句覆盖确定执行了那些语句，当达到实现定义的测试覆盖率后，就可以认为测试已经足够并且可以终止测试 分支覆盖更加有效的覆盖准则是控制流图的分支覆盖控制流图中的边是分支覆盖关注的交单，它不考虑每条语句的执行情况，而是考虑判定的执行情况，判定的解构决定接下来执行那条语句]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react 慕课网入门笔记]]></title>
      <url>%2F2017%2F03%2F15%2Freact%E5%85%A5%E9%97%A8%E6%85%95%E8%AF%BE%E7%BD%91%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[学习慕课网的react 入门教程 视频地址 http://www.imooc.com/learn/504 API http://reactjs.cn/react/docs/getting-started-zh-CN.html React 介绍 react 不是完整的mvc框架，mvvm框架 用组件的方式，通过组合来实现大的模块 应用场景 复杂场景的高性能 组件高度可重用 JSX = JS + XML 语法糖，计算机语言中没有添加的某种语法，对功能没有影响，增加可阅读性，减少出错。例如 JSX 最终都会编译成JS react 里面的 不能看成 dom ,而是react component的实例 React 的 style demo http://jsfiddle.net/reactjs/69z2wepo/ React-components-lifecycleMounted -&gt; Update -&gt; Unmounted Mounted React Components被render解析生成对应的dom节点并被插入浏览器的DOM解构的一个过程,当在浏览器从无到有的渲染的一个过程，就是Mounted结束，我们就说这个component组件已经被Mounted Update 一个mounted的react Components 被重新render的过程,而这个重新被渲染的过程并不是说dom解构会发生改变，react 会把这个component的当前state 和最近一次state进行对比，只有发现确实发生的改变并且影响的当前的DOM结构，react 才会改变对应的dom解构 Unmounted 一个Mounted的React Components 对应的DOM节点被从DOM解构中移除的一个过程 hook() 函数每一个状态react都封装了对应的hook函数，设计思想是will和did, 将要做什么了和已经做了什么。 Mounted getDefaultProps() -&gt; getInitialState() -&gt; componentWillMount() -&gt; render -&gt; componentDidMount() componentWillMount() 将要Mounted调用 componentDIdMount() 已经Mounted调用 getInitialState() 初始化react state的 props和state都可以设置css样式state值是可变的，props是通过组件调用方，通过组件决定，一旦定义不改变 this 指调用函数的对象 当前this compoentent 的实例 如果在setTimeout里面this指代globl对象 如果在构造函数中，this就指这个新生成的对象 通过调用apply call bind 调用后的this对象 demo http://codepen.io/mayufo/pen/EWQmKN state 值每次变化，会进入updating 状态，使其进入一个render的过程 updating componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate - componentWillReceiveProps() Mounted Component将要接收新的props时，这个函数会被调用，其函数参数就是新的props对象，可以通过参数和this.props进行比较，来执行一些例如修改state的操作 - shouldComponentUpdate 当接收到新的props和state之后，判断是否有必要去更新dom结构，有两个参数，一个是新的props对象，另一个是新的state对象，可以分别对比，来决定是否更新dom,返回true是更新dom节点，返回false是不更新dom节点。 Unmounting componentWillUnmount() 可以释放内存资源，图片资源 react component state的更新，会触发页面更新，而传统的页面更新时通过修改页面dom实现 传统的事件处理通过 event listener， demo http://codepen.io/mayufo/pen/GWQvxM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[犀牛书第三章]]></title>
      <url>%2F2017%2F03%2F15%2F%E7%8A%80%E7%89%9B%E4%B9%A6%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[重读犀牛书 第三章 ##chapter 3 类型、值和变量 能表示或操作的值的类型叫做操作类型 变量是一个值的符号名称，通过名称来获得对值得引用。 javascript的数据类型分数据类型为原始数据类型和对象数据类型。 原始数据类型包括数字、字符串、布尔值、null和undefined。对象数据类型除了上面的类型都是对象，对象是property的集合。以下属于对象数组是特殊的对象，带编号有序列的集合。函数是特殊的对象，具有与它相关联的可执行代码的对象，通过调用函数来运行可执行代码，并返回结果。构造函数使用 new运算符来初始化函数类每个构造函数定义了一类（class）对象—由初始化的对象组成的集合。类可以看做是对象类型的子类型。日期正则错误 javascript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收。按需创建，不用担心销毁和回收。 javascript面向对象的语言，不用全局定义函数去操作不同类型的值，数据类型本身可以定义方法来使用。 javacript 还可以分为可变类型和不可变类型。对象和数组可以修改为可变类型。数字、布尔值、字符串、null和undefined 不可变类型。 javascript 中变量是无类型的，不在任何函数内声明的变量叫做全局变量 数字（p35）javascript 不区分整数值和浮点值。均用浮点表示。（IEEE 754：一种二进制表示法，可以精确的表示分数）一个数字出现在javascript程序中，叫做数字直接量。任何数字直接量前添加负号，得到负值。负号是一元求反运算符，不是直接量语法。 整型直接量javascript支持十进制、十六进制。不直接支持八进制，但某些实现支持八进制，八进制的某些数字已0开始。严格模式下不支持。 浮点型直接量浮点型由整数、小数、小数部分组成。还可以使用指数计数法使用浮点型直接量。 javascript中的算术运算符 + - * / % Math对象的属性定义 函数 说明 Math.pow (2, 53) 2的53次幂 Math.round(.6) 四舍五入 Math.ceil(.6) 向上求整 Math.floor(.6) 向下求整 Math.abs(-5) 求绝对值 Math.max(x, y, z) 求最大值 Math.min(x, y, z) 求最小值 Math.random() 生成一个大于0 小于1.0的随机数 Math.PI 圆周率 打乱arr数组的顺序1234567891011121314151617181920212223var arr = [1, 2, 3, 4, 5];arr.sort(function (a, b) &#123; return 0.5 - Math.random();&#125;)``` javascript的算术运算符在溢出、下溢、被0整除不会报错。- 当数字溢出的时候，结果作为无穷大。- 当出现下溢的时候，结果返回0- 被0整除，返回无穷大或者负无穷大- 0除0， 无穷大除无穷大，无法转换的数字都用NAN表示Infinity(无穷大值)、NaN(非数字)。NaN和任何都不相等，包括本身。**isNaN()** 如果参数是NaN或者是一个非数字值，返回true**isFinite()** 参数不是NaN、Infinity、-Infinity，返回true## 二进制浮点数和四舍五入 javascript通过浮点数的形式只能表示其中有限的个数, 采用IEEE-754浮点数表示法，是一种二进制表示法，可以精确表示分数，不能正确表示十进制分数。因此带来误差，要使用大整数来解决。## 日期和时间 var then = new Date(2011,0,1) //Sat Jan 01 2011 00:00:00 GMT+0800 (中国标准时间)var later = new Date(2011,0,1,17,10,30) //Sat Jan 01 2011 17:10:30 GMT+0800 (中国标准时间)var now = new Date() //当前日期 //Tue Mar 22 2016 16:18:30 GMT+0800 (中国标准时间)var elapsed = now - then; //时间间隔是毫秒 164823510655later.getFullYear(); //年 2011later.getMonth(); //月 0later.getDate(); //天 1later.getDay() // 星期几 6later.getHours() // 时间 17later.getUTChours() // 时区时间 91234567891011121314# 文本**字符串**是一组有16位组成的不可变的有序数列，每个字符通常来自于Unicode字符集。 Javascript通过字符串类型便是文本。**空字符串**长度为0，Javacript中没有表示单个字符的‘字符型’一个长度为2的字符串可能表示一个Unicode字符。## 字符串直接量字符串必须写在一行中，可以拆分数行每行以(\)结束。如果希望另起一行可以用\n。单引号和撇号同用时 ，撇号可以用 \&apos; 可以作为区分。## 转义字符```js&apos;You\&apos; re right, it can\&apos;t be a quote &apos; \n换行符\&#39;撇号（单引号） 字符串的使用+运用于数字，表示两数相加。用于字符串，可以链接字符串。 注意: 字符串调用的方法不会改变字符串本身，都是返回一个新的。 模式匹配正则表达式 和 Date 都是一种具有实用API的特殊对象 布尔值任意的js值可以转为布尔值。undefined null 0 -0 NaN &quot;&quot; 都是false其他都是true 布尔值包含toString()方法 null和defined 值 typeof 说明 null object 表示数字、字符串、对象无值 undefined undefined 未定义的空值，元素不存在 ==认为两者相等===不等null 和 undefined 不包含任何属性和方法赋值给变量首选null 全局对象全局对象是全局定义的符号，js可以直接使用 比如 Math JSON 在代码的最顶级——不在任何js代码内可以使用this来引用全局对象 window对象充当全局对象如果代码声明一个全局变量，则这个全局变量就是全局对象的一个属性 包装对象对象是一种复合值，通过.符号引用属性值，当属性值是一个函数的时候，称其为方法。 12var s = 'hello';var world = s.substring(s.indexOf('')+1, s.length); 只要引用了字符串s的属性，js将字符串通过 new String(s)方式转换成对象，这个对象继承了字符串的方法。一旦属性引用结束，这个新建对象就会销毁。 123var s = &quot;test&quot;;s.len = 4; //对象包装var t = s.len //undefine 字符串、数字和布尔值读取属性值的时候，如果试图给其赋值，则会忽略操作，而临时创建的对象叫做包装对象原始值和包装对象的typeof是不同的 12var s = &quot;test&quot;; //stringvar S = new String(s); //Object 他们类型不一样 不可变的原始值和可变的引用对象（p47） 原始值不可更改，比较的是值。比如字符串必须长度字符都相等才是相等。对象是可变的，它们的值可以修改。两个对象包含同样的属性及相同的值，它们也不等。各个索引值相等也不相等，对象称为引用类型。对象的比较均是引用比较，当且仅当他们引用同一个基对象，才相等。 12345var a = [];var b = a;b[0] = 1;console.log(a[0]); // 1a === b // true 复制一个数组对象12345var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var b = [];for(var i = 0; i &lt; a.length; i++)&#123; b[i] = a[i]&#125; 比较两个数组对象 123456789function equal (a,b)&#123; if( a.length != b.length) return false; for( var i = 0; i &lt; a.length; i++)&#123; if(a[i]!=b[i])&#123; return false &#125; &#125; return true;&#125; 类型转换 值 转换为字符串 数字 布尔 对象 undefined “undefined” NaN false throws TypeError null “null” NaN 0 false throws TypeError true “true” 1 new Boolean(true) false “false” 0 false new Boolean(false) “” (空字符串) 0 false new String(“”) “1.2”（非空，数字） 1.2 true new String(“1.2”) “one”（非空，非数字） NaN true new String(“one”) 0 “0” false new Number(0) -0 “0” false new Number(0) NaN “NaN” false new Number(NaN) Infinity “Infinity” true new Number(Infinity) Infinity “-Infinity” true new Number(-Infinity) 1(无穷大，非0) “1” true new Number(1) {} (任意对象) “1” true “” 0 true ‘[ ‘ 9 ‘]’ ( 1个数字元素 ) “9” 9 true ‘[‘ a ‘]’( 其他数组 ) 使用join()方法 NaN true functtion (){} (任意函数) NaN true 转换和相等性 undefined 可以转换为布尔值，但是不表明 undefined == false显示类型转换 Boolean()、Number()、String() toString() Object()隐式转换 + !123x + &quot; &quot; //等价与String()+x //等价Number.!!x //等价于Boolean(x) toString()可以接受转换基数12var n =17;n.toString(2); //转化为10001 Number 定义了三种数字转换字符串的场景 n.toFixed(m); 根据m的值确定小数点后数字个数。12var n = 123456.789n.toFixed(2) // 123456.78 n.toExponential (m);用指数计数法，其中小数点前只有一位，小数点后有m-1位。12var n = 123456.789n.toExponential (2) //1.2e+5 n.toPrecision(m) 有效的数字位数将数字转换为字符串。1n.toPrecision(7) //123456.8 Number()转换传入一个字符串，会试图转换为一个整数或者浮点，这个方法只能基于十进制书。 parseInt() 只能解析整数，parseFloat() 可以解析整数和浮点数。如果字符串前是0x或者0X，则parseInt()将解释为十六进制数。如果是非法字符，返回NaN。parseFloat() 可以跳过前空格并可以解析’.1’，而parseInt不可以解析’.1’。第二个可选参数是转换的基数。12parseInt(&apos;11&apos;,2); // 3parseInt(&apos; ff &apos;, 16); //255 对象转换为原始值(p52) #####toString() 1234[1,2,3].toString(); //1,2,3(function(x)&#123; f(x)&#125;).toString() //function (x)&#123; f(x)&#125;/\d+/g.toString() ///\d+/gnew Date(2010,0,1).toString() //Fri Jan 01 2010 00:00:00 GMT+0800 (中国标准时间) #####valueOf()返回对象本身，而不是返回一个原始值。 1234[1,2,3].valueOf(); //[ 1, 2, 3 ](function(x)&#123; f(x)&#125;).valueOf() //[Function]/\d+/g.valueOf() ///\d+/gnew Date(2010,0,1).valueOf() //1262275200000 方法 对象 toString原始值结果 valueOf原始值结果 toString() 数组 字符串 数组 toString() 函数 函数的实现定义的表示方法 [Function] toString() 日期 可读的日期和时间字符串 以毫秒来表示 toString() 正则 表示正则的表达式直接量 表示正则的表达式直接量 对象到字符串转换先用toString返回字符串，如果不成功再用valueOf()返回字符串,否则抛出异常。对象到数字转换先用到valueOf返回数字，如果不成功再用toString()返回数字,否则抛出异常。 数组继承了valueOf方法，这也就是为什么空数组和单个的数组转换原始值会一个0或者数字。“+”、“==”都是将对象转换为原始值。对象到原始值的转换基本都是对象到数字的转换。而日期对象通过valueOf或toString()可以直接用。 12345var now = new Date()typeof (now +1 ) //stringtypeof (now -1) //numbernow == now.toString() //隐式和显式的字符串转换now &gt; (now -1) // &gt; 将日期转为数字 声明变量var 声明 初始undefine 变量作用域函数体内局部变量的优先级高于全局变量，声明局部变量时候一定写var 否则赋值就是给全局变量js使用函数作用域，变量在声明函数体以及这个函数体的任意嵌套都是有定义的。 1234567891011121314function test(o)&#123; var i = 0; if(typeof o == &quot;object&quot;)&#123; var j = 0; for(var k = 0; k &lt; 10 ; k++)&#123; console.log(k); &#125; console.log(k); &#125; console.log(&apos;j =&apos; + j) // undefine&#125; test(5); JS 可以声明提前。在函数体内局部变量遮盖了同名全局变量。123456var name=&quot;global&quot;; if(true)&#123; var name=&quot;local&quot;; console.log(name) //local&#125; console.log(name); // local 当声明了一个js全局变量时，实际是定义了全局对象的一个属性。如果没有通过var 声明变量，那么他们都可以通过delete删除。12345678910function t(flag)&#123; if(flag)&#123; s=&quot;ifscope&quot;; for(var i=0;i&lt;2;i++) ; &#125; console.log(i); &#125; t(true); console.log(s); // ifsope s是全局变量 js关键子来引用全局对象，却没有办法引用局部变量。 js最顶层代码中，作用域由一个全局对象组成。 不嵌套的函数体，有两个对象，一是函数参数和局部变量的对象，二是全局对象。 嵌套函数至少在三个以上。 当调用一个函数的时候，创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的的那个作用域链上，同时创建一个新的更长的表示函数调用作用的“链”。 参考文件https://segmentfault.com/a/1190000002692982https://segmentfault.com/a/1190000003935661http://www.2cto.com/kf/201405/298344.htmlhttp://web.jobbole.com/84041/http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dom详解]]></title>
      <url>%2F2017%2F03%2F13%2Fdom%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[用mvc框架多了，已经忘了dom 看dom详解，做的一些笔记。方便以后巩固加强，方便自己查询。 初始DOMjs由三部分组成ECMAscript 是js的核心标准，也是一个解析器DOM 是document提供的一些方法或熟悉用来操作页面BOM是window提供的一些方法或者属性用来操作浏览器 （拉倒底部数据加载） DOM (document object model) 文本对象模型 就是document提供一些api赋予开发者操作页面的能力 DOM结构是树形，顶端为DOM -&gt; 根元素 -&gt; …一般分为三大关系 父级关系 只有一层上下级关系（从当前往上走） 子级关系 只有一层以下一层的关系 兄弟关系 同一个父级 （同一级） 按照层级划分 父子节点： 上下两层节点之间的关系 祖先节点： 当前节点上面的所有节点 子孙节点： 当前节点下面的所有节点的统称 节点类型按照节点的类型划分 查看某个节点类型 nodeType 返回一个数字 表示节点的类型 整个页面都是节点都可以看做节点 节点分类 元素节点 nodeType: 1 element 就是一个标签 document nodeType: 9 元素中的文字(包括空格回车换行) nodeType: 3 注释节点 nodeType: 8 attributes 代表元素的属性 是一个集合 nodeType代表数字2 找到属性查看值nodeValue, nodeName查看节点的属性名 如果是&lt;p&gt; 输出P 如果是&lt;div&gt; 输出DIV 如果是文字输出 #text 子节点childNodes 某个节点下的所有子节点，是一个类数组下标为0 的时候可以打出标签的内容 1&lt;div id='div'&gt;12345&lt;/div&gt; 1234var odiv = document.getElementById('div');console.log(odiv.childNodes) // [text] 类数组console.log(odiv.childNodes[0]) // 12345console.log(odiv.childNodes[0].nodeType) demo https://jsfiddle.net/mayufo/6p26L8wd/ 12&lt;div id='div'&gt;&lt;!--注释--&gt;2222&lt;/div&gt; 两个子节点之所以没有空格 因为空格回车代表节点3类型 12345var odiv = document.getElementById('div');console.log(odiv.childNodes[0].nodeType); // 8console.log(odiv.childNodes[1].nodeType); // 3console.log(odiv.childNodes.length); // 2 demo https://jsfiddle.net/mayufo/qk3znLft/ 注释节点如果查看注释的值? div.childNode[0].nodeValue demo 当点击页面的时候 li 改变宽度 123456li &#123; transition: 1s; width: 20px; height: 20px; background: red;&#125; 12345678&lt;ul id="ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; childNodes查找到除元素外还能查找到空格回车元素123456789var ul = document.getElementById('ul');var lis = ul.childNodes; // 11 个 包括空格和换行 &lt;li&gt;标签前后的document.onclick = function () &#123; for (var i = 0; i &lt; lis.length; i++ )&#123; if(lis[i].nodeType === 1 ) &#123; lis[i].style.width = '150px'; &#125; &#125;&#125; children: 不是标准的属性，但是所有浏览器都支持，找到摸个元素下所有元素子节点1234567var ul = document.getElementById('ul');var lis = ul.children; // 5 document.onclick = function () &#123; for (var i = 0; i &lt; lis.length; i++ )&#123; lis[i].style.width = '150px'; &#125;&#125; demo https://jsfiddle.net/mayufo/0h1yfdox/ 父节点parentNode查找某个元素的父节点 12345678&lt;ul id="ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 12345678 var ul = document.getElementById('ul'); var alis = ul.children; console.log(alis[0].innerHTML); // 1console.log(alis[0].parentNode); // &lt;ul id="ul"&gt;..&lt;/ul&gt;console.log(alis[0].parentNode. parentNode); // &lt;body&gt;console.log(alis[0].parentNode. parentNode. parentNode); // 页面中最大的父元素是document 再大就是null demo https://jsfiddle.net/mayufo/27q1dacp/ parentNode 例子 12345&lt;ul&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;22&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;22&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 123456var a = document.getElementsByTagName('a');for (var i = 0; i &lt; a.length; i++) &#123; a[i].onclick = function () &#123; this.parentNode.style.display = 'none'; &#125;&#125; demo https://jsfiddle.net/mayufo/5r41hv2e/ 兄弟节点nextElementSibling 找到某个元素的下个兄弟节点 nextElementSibling举例 12345&lt;ul id='ul'&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;22&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;33&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 12345var ul = document.getElementById('ul');var alis = ul.children;console.log(alis[0].nextElementSibling); // &lt;li&gt;22&lt;/li&gt;console.log(alis[0].nextElementSibling. nextElementSibling); // &lt;li&gt;33&lt;/li&gt; 超出为null previousElementSibling 找到某个元素的上个兄弟节点 previousElementSibling 举例同 nextElementSibling firstElementChild找到第一个子节点 lastElementChild 找到最后一个子节点 1234var ul = document.getElementById('ul');ul.firstElementChild; // &lt;li&gt;111&lt;/li&gt;ul.lastElementChild; // &lt;li&gt;333&lt;/li&gt; offsetLeft、offsetParentoffsetParent 最近的有定位属性的祖先节点, 如果父节点都没有定位，默认定位是body，否则是定位该元素父级上设置position: relative的元素。 12345&lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12var div3 = document.getElementById('div3'); console.log(div3.offsetParent); 123456789101112131415div &#123; padding: 100px;&#125;#div1 &#123; background: red; position: relative;&#125;#div2 &#123; background: blue;&#125;#div3 &#123; background: green;&#125; demo https://jsfiddle.net/mayufo/pnkcogjy/ offsetLeft、offsetTopoffsetLeft 外边框到有定位父级的内边框的距离, 如果没有父级position: relative的定位，子级也没有position: absolute,定位默认到body。和offsetParent有关, 得到的数字没有单位。 offsetTop 上边框到有定位父级的上呗边框的距离 这里注意没有offsetRight和offsetBottom 使用场景：方便获取元素的位置 getComputedStyle(div3).left 也可以得到，有单位。 例子 当点击按钮，将div3移动到左顶边 12345678&lt;input type="button" id="btn" value="btn"&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132*&#123; margin: 0; padding: 0;&#125;#div1&#123; background: red; width:100px; height:100px; margin-left: 50px; position: relative; border: 10px solid #000;&#125;#div2&#123; background: blue; position: relative; width:60px; height:60px; top:20px; left:30px; border: 10px solid #000;&#125;#div3&#123; width:30px; height:30px; background: yellow; position: absolute; top:20px; border: 1px solid #000; left:0; transition:1s left;&#125; 1234567891011121314151617var div3 = document.getElementById('div3');var btn = document.getElementById('btn');var div3Border = parseInt(getComputedStyle(div3).borderLeftWidth); // 减去自身的边框btn.onclick = function () &#123; var left = 0; var elem = div3; while(elem) &#123; left += elem.offsetLeft + parseInt(getComputedStyle(elem).borderLeftWidth); elem = elem.offsetParent; &#125; left -= div3Border; div3.style.left = - left + 'px';&#125; demo https://jsfiddle.net/mayufo/q7d1bozj/ 计算绝对位置getBoundingClientRect()getBoundingClientRect()获取某个元素的信息，left、top、bottom、right、width、height,返回值是一个对象。 注意： 获取的值会根据滚动条变化 123&lt;input type="button" id="btn" value="btn"&gt;&lt;div id="div1"&gt;&lt;/div&gt; 123456var div = document.getElementById('div1');var btn = document.getElementById('btn');btn.onclick = function () &#123; console.log(div.getBoundingClientRect()) // bottom:130,height:100,left:58, right:158, top:30, width:10&#125; demo https://jsfiddle.net/mayufo/cL50o17d/ 元素属性操作getAttribute获取元素属性,操作某个元素的行间属性.不是行间无法获取到。 1&lt;div id="div1" index="2"&gt;&lt;/div&gt; 12345678910111213141516171819var div = document.getElementById('div1');// 想获取id的值console.log(div['id']); // div1console.log(div.getAttribute('id'));// 如果是div.index = 2 直接设置，getAttribute无法获取到index的值div.index = 2;console.log(div['index']); // 主要取对象属性的值，有时候不能取到行间属性的值console.log(div.getAttribute('index')); // 主要取对象属性的值，无法取到对象属性设置的值div.setAttribute('index', '4'); // 删除元素行间属性div.removeAttribute('index'); demo https://jsfiddle.net/mayufo/ng629u96/ setAttribute设置元素的行间属性 removeAttribute 删除元素的行间属性 上面三种方法可以获取href或src的相对路径 如果图片中存在中文的路径，打出图片地址的时候，有的浏览器中文的路径会显示乱码。所有通常情况不能直接拿此console.log(img.src)作为判断 可以通过getAttribute来得到写的路径 元素宽高的获取clientWidth 可视内容的宽度，没有单位，不计算边框border, 不会计算padding， 不计算margin clientHeight 可视内容的高度，没有单位，不计算边框border, 不会计算padding, 不计算margin 注意：如果div内容超出，只算div显示的宽高 1234#div1 &#123; height: 200px; width: 200px;&#125; 1&lt;div id="div1"&gt;&lt;/div&gt; 123var odiv = document.getElementById('div1');console.log(odiv.clientWidth);console.log(odiv.offsetWidth); offsetWidth 获取某个元素的宽度，会计算border的, 计算padding, 不计算margin offsetHeight 获取某个元素的宽度，会计算border的, 计算padding, 不计算margin document.documentElement.clentWidth 可视区的宽度 document.documentElement.clentHeight 可视区的高度 让一个不确定宽高的元素居中显示 元素的left = （可视区 - 元素的宽）/ 2 元素的top = (可视区 - 元素的高) / 2 1&lt;div id='div1'&gt;2222&lt;/div&gt; 123456#div1 &#123; height: 100px; width: 100px; background: red; position: absolute;&#125; 123456789101112var odiv = document.getElementById('div1'); // 记得div1 position: absolutevar clientW = document.documentElement.clientWidth;var clientH = document.documentElement.clientHeight;console.log(odiv);var iW = odiv.offsetWidth;var iH = odiv.offsetHeight;odiv.style.left = (clientW - iW) / 2 + 'px';odiv.style.top = (clientH - iH) / 2 + 'px'; demo https://jsfiddle.net/mayufo/eLLuspjp/ 创建元素 点击添加元素 可以通过字符串的拼接 通过createElement(‘标签的名字’), 如果创建没有的标签，也会出现自定义的标签 插入元素 parentNode.appendChild(childNode) 向父级的尾部添加一个元素 插入元素 插入元素 parentNode.inserBefore (新添加的元素， 添加的元素位置，会添加到这个元素之前) 向父级中的某个元素前插入元素 特性 如果第二个参数为假的，则将这个元素添加到父元素的第一个 删除元素 父级.removeChild（自定的子级点) 如果指定的子节点没有会报错 1234&lt;input type="button" id="btn" value="button"&gt;&lt;ul id="ul"&gt; &lt;li&gt;0&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526272829303132333435363738var btn = document.getElementById('btn');var oul = document.getElementById('ul');var html = '';var num = 0;btn.onclick = function() &#123; num++; html += '&lt;li&gt;' + num + '&lt;/li&gt;'; oul.innerHTML = html;&#125;;// appendChildbtn.onclick = function() &#123; num++; var li = document.createElement('li'); //创建li标签 li.innerHTML = num; ul.appendChild(li); console.log(li.nodeType); // 1 元素节点&#125;;// insertBefore btn.onclick = function() &#123; num++; var li = document.createElement('li'); //创建li标签 li.innerHTML = num; ul.insertBefore(li, ul.children[0]);// 将ul的第一个子节点插入元素 console.log(li.nodeType); // 1 元素节点 &#125;; // removeChild btn.onclick = function() &#123; if(ul.lastElementChild) &#123; ul.removeChild(ul.lastElementChild); &#125; &#125; demo https://jsfiddle.net/mayufo/vyzxgmnf/1/ 元素替换 当点击按钮的时候，将红色替换成蓝色 123456&lt;input type="button" id="btn" value="button"&gt;&lt;div id="box"&gt; &lt;div id="red"&gt;&lt;/div&gt; &lt;hr id="hr"&gt; &lt;div id="blue"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910var red = document.getElementById('red');var hr = document.getElementById('hr');var blue = document.getElementById('blue');var btn = document.getElementById('btn');var box = document.getElementById('box');btn.onclick = function () &#123; box.replaceChild(red, blue);&#125; demo https://jsfiddle.net/mayufo/ofp5Lv19/ 父级.replaceChild(node(要替换成什么), childNode（谁被替换）) 都是剪切的操作 克隆 将蓝色方块克隆，放到红色方块下 要复制的元素.cloneNode(false); 克隆某个元素，克隆只克隆元素本身，克隆不会克隆下面的子节点, 如果参数改为true 就可以默认赋值子节点,默认值为false.事件不会被克隆的克隆才是真正的赋值 12345678var red = document.getElementById('red');var hr = document.getElementById('hr');var blue = document.getElementById('blue');var btn = document.getElementById('btn');var box = document.getElementById('box');var elem = blue.cloneNode();box.insertBefore(elem,hr); demo https://jsfiddle.net/mayufo/cymoh67c/ 表格12345678910111213141516171819202122232425262728293031323334 &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;head1&lt;/th&gt; &lt;th&gt;head2&lt;/th&gt; &lt;th&gt;head3&lt;/th&gt; &lt;th&gt;head4&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;content1&lt;/td&gt; &lt;td&gt;content2&lt;/td&gt; &lt;td&gt;content3&lt;/td&gt; &lt;td&gt;content4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;content1&lt;/td&gt; &lt;td&gt;content2&lt;/td&gt; &lt;td&gt;content3&lt;/td&gt; &lt;td&gt;content4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;foot1&lt;/td&gt; &lt;td&gt;foot2&lt;/td&gt; &lt;td&gt;foot3&lt;/td&gt; &lt;td&gt;foot4&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; 123456789101112var table = document.getElementById('box');table.tHead.style.borderColor = 'red';table.rows[1].style.background= 'blue';console.log(table.tBodies);table.tBodies[0].style.background = 'red';table.rows[1].cells[2].style.background = 'pink'; table.tHead 选取表格的表头 table.rows 获取tr 获取表格中所有的tr, 得到一个数组，指定某个需要下标 表头和表尾也会算入tr的list中, 比tbody优先级高 table.tBodies 获取表格中所有的tbody, 得到一个数组，指定某个需要下标 table.row[n].cells[i] 获取表格中其中一个td,需要指定下标。前面也可以结合tBodies demo https://jsfiddle.net/mayufo/aum5cz9n/ 渲染一个表格 demo https://jsfiddle.net/mayufo/uLLmm7t6/ #练习 - 留言板 https://jsfiddle.net/mayufo/4u5v6tno/2/ - 上移下移 https://jsfiddle.net/mayufo/sLj50rwx/ - 排序 https://jsfiddle.net/mayufo/LvenLyy3/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[犀牛书第二章 词法结构]]></title>
      <url>%2F2017%2F03%2F13%2F%E7%8A%80%E7%89%9B%E4%B9%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[重读犀牛书 第二章 2.1 字符集 javascript 程序是Unicode字符集编写的。 javascript 区分大小写。 HTML 不区分大小写。 Unicode允许多种方法进行编码，显示结果一样，但是处理方式不一样。 2.2 注释 可以使用 // 或者 /**/注释，但是不能嵌套。(P27) 2.3 直接量 可以直接使用的数据值 2.4 标识符和保留字标识符就是用来对变量和函数进行命名，或者循环语句中位置标记JavaScript必须以字母，下划线或$开始。后接的可以字母，数字，下划线，美元符。（数字不能出现在首字母）也可以用非英文语言或数字作为标识符，比如π也不能使用保留字作为标识符。 2.5 可选分号语句用分号分开。（P30）如果独占一行可以省略分号。无法解析的两个例外 return break和continue随后的表达式之间不能换行，系统会自动添加分号。 ++ --作为表达式的后缀，应该和表达式在同一行。 否则，行尾将填补分号。 1234567var aa=3//解析为 // var a // a = 3 如果以 （ [ / + - 开始极有可能和之前语句合在一起解析。1234var y = x+ f(a+b).toString()//解析//var y = x+ f(a+b).toString(); 涉及return、break、continue。则不能换行 12345returntrue //解析 //teturn; //true 涉及到 ++ 或 – 123456x++y//解析//x;//++y;]]></content>
    </entry>

    
  
  
</search>
